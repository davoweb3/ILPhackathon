{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n    i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.qrcode.encoder {*/\nvar EncodeHintType_1 = require(\"../../EncodeHintType\");\nvar BitArray_1 = require(\"../../common/BitArray\");\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\");\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\nvar ReedSolomonEncoder_1 = require(\"../../common/reedsolomon/ReedSolomonEncoder\");\nvar Mode_1 = require(\"../decoder/Mode\");\nvar Version_1 = require(\"../decoder/Version\");\nvar MaskUtil_1 = require(\"./MaskUtil\");\nvar ByteMatrix_1 = require(\"./ByteMatrix\");\nvar QRCode_1 = require(\"./QRCode\");\nvar MatrixUtil_1 = require(\"./MatrixUtil\");\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\nvar BlockPair_1 = require(\"./BlockPair\");\nvar WriterException_1 = require(\"../../WriterException\");\n/*import java.io.UnsupportedEncodingException;*/\n/*import java.util.ArrayList;*/\n/*import java.util.Collection;*/\n/*import java.util.Map;*/\n/**\n * @author satorux@google.com (Satoru Takabayashi) - creator\n * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n */\nvar Encoder = /** @class */function () {\n  // TYPESCRIPTPORT: changed to UTF8, the default for js\n  function Encoder() {}\n  // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.\n  // Basically it applies four rules and summate all penalties.\n  Encoder.calculateMaskPenalty = function (matrix) {\n    return MaskUtil_1.default.applyMaskPenaltyRule1(matrix) + MaskUtil_1.default.applyMaskPenaltyRule2(matrix) + MaskUtil_1.default.applyMaskPenaltyRule3(matrix) + MaskUtil_1.default.applyMaskPenaltyRule4(matrix);\n  };\n  /**\n   * @param content text to encode\n   * @param ecLevel error correction level to use\n   * @return {@link QRCode} representing the encoded QR code\n   * @throws WriterException if encoding can't succeed, because of for example invalid content\n   *   or configuration\n   */\n  // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {\n  //   return encode(content, ecLevel, null)\n  // }\n  Encoder.encode = function (content, ecLevel, hints) {\n    if (hints === void 0) {\n      hints = null;\n    }\n    // Determine what character encoding has been specified by the caller, if any\n    var encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;\n    var hasEncodingHint = hints !== null && undefined !== hints.get(EncodeHintType_1.default.CHARACTER_SET);\n    if (hasEncodingHint) {\n      encoding = hints.get(EncodeHintType_1.default.CHARACTER_SET).toString();\n    }\n    // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n    // multiple modes / segments even if that were more efficient. Twould be nice.\n    var mode = this.chooseMode(content, encoding);\n    // This will store the header information, like mode and\n    // length, as well as \"header\" segments like an ECI segment.\n    var headerBits = new BitArray_1.default();\n    // Append ECI segment if applicable\n    if (mode === Mode_1.default.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {\n      var eci = CharacterSetECI_1.default.getCharacterSetECIByName(encoding);\n      if (eci !== undefined) {\n        this.appendECI(eci, headerBits);\n      }\n    }\n    // (With ECI in place,) Write the mode marker\n    this.appendModeInfo(mode, headerBits);\n    // Collect data within the main segment, separately, to count its size if needed. Don't add it to\n    // main payload yet.\n    var dataBits = new BitArray_1.default();\n    this.appendBytes(content, mode, dataBits, encoding);\n    var version;\n    if (hints !== null && undefined !== hints.get(EncodeHintType_1.default.QR_VERSION)) {\n      var versionNumber = Number.parseInt(hints.get(EncodeHintType_1.default.QR_VERSION).toString(), 10);\n      version = Version_1.default.getVersionForNumber(versionNumber);\n      var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);\n      if (!this.willFit(bitsNeeded, version, ecLevel)) {\n        throw new WriterException_1.default('Data too big for requested version');\n      }\n    } else {\n      version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);\n    }\n    var headerAndDataBits = new BitArray_1.default();\n    headerAndDataBits.appendBitArray(headerBits);\n    // Find \"length\" of main segment and write it\n    var numLetters = mode === Mode_1.default.BYTE ? dataBits.getSizeInBytes() : content.length;\n    this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);\n    // Put data together into the overall payload\n    headerAndDataBits.appendBitArray(dataBits);\n    var ecBlocks = version.getECBlocksForLevel(ecLevel);\n    var numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();\n    // Terminate the bits properly.\n    this.terminateBits(numDataBytes, headerAndDataBits);\n    // Interleave data bits with error correction code.\n    var finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());\n    var qrCode = new QRCode_1.default();\n    qrCode.setECLevel(ecLevel);\n    qrCode.setMode(mode);\n    qrCode.setVersion(version);\n    //  Choose the mask pattern and set to \"qrCode\".\n    var dimension = version.getDimensionForVersion();\n    var matrix = new ByteMatrix_1.default(dimension, dimension);\n    var maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);\n    qrCode.setMaskPattern(maskPattern);\n    // Build the matrix and set it to \"qrCode\".\n    MatrixUtil_1.default.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);\n    qrCode.setMatrix(matrix);\n    return qrCode;\n  };\n  /**\n   * Decides the smallest version of QR code that will contain all of the provided data.\n   *\n   * @throws WriterException if the data cannot fit in any version\n   */\n  Encoder.recommendVersion = function (ecLevel, mode, headerBits, dataBits) {\n    // Hard part: need to know version to know how many bits length takes. But need to know how many\n    // bits it takes to know version. First we take a guess at version by assuming version will be\n    // the minimum, 1:\n    var provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version_1.default.getVersionForNumber(1));\n    var provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);\n    // Use that guess to calculate the right version. I am still not sure this works in 100% of cases.\n    var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);\n    return this.chooseVersion(bitsNeeded, ecLevel);\n  };\n  Encoder.calculateBitsNeeded = function (mode, headerBits, dataBits, version) {\n    return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();\n  };\n  /**\n   * @return the code point of the table used in alphanumeric mode or\n   *  -1 if there is no corresponding code in the table.\n   */\n  Encoder.getAlphanumericCode = function (code /*int*/) {\n    if (code < Encoder.ALPHANUMERIC_TABLE.length) {\n      return Encoder.ALPHANUMERIC_TABLE[code];\n    }\n    return -1;\n  };\n  // public static chooseMode(content: string): Mode {\n  //   return chooseMode(content, null);\n  // }\n  /**\n   * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;\n   * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.\n   */\n  Encoder.chooseMode = function (content, encoding) {\n    if (encoding === void 0) {\n      encoding = null;\n    }\n    if (CharacterSetECI_1.default.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {\n      // Choose Kanji mode if all input are double-byte characters\n      return Mode_1.default.KANJI;\n    }\n    var hasNumeric = false;\n    var hasAlphanumeric = false;\n    for (var i = 0, length_1 = content.length; i < length_1; ++i) {\n      var c = content.charAt(i);\n      if (Encoder.isDigit(c)) {\n        hasNumeric = true;\n      } else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {\n        hasAlphanumeric = true;\n      } else {\n        return Mode_1.default.BYTE;\n      }\n    }\n    if (hasAlphanumeric) {\n      return Mode_1.default.ALPHANUMERIC;\n    }\n    if (hasNumeric) {\n      return Mode_1.default.NUMERIC;\n    }\n    return Mode_1.default.BYTE;\n  };\n  Encoder.isOnlyDoubleByteKanji = function (content) {\n    var bytes;\n    try {\n      bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS); // content.getBytes(\"Shift_JIS\"))\n    } catch (ignored /*: UnsupportedEncodingException*/) {\n      return false;\n    }\n    var length = bytes.length;\n    if (length % 2 !== 0) {\n      return false;\n    }\n    for (var i = 0; i < length; i += 2) {\n      var byte1 = bytes[i] & 0xFF;\n      if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  Encoder.chooseMaskPattern = function (bits, ecLevel, version, matrix) {\n    var minPenalty = Number.MAX_SAFE_INTEGER; // Lower penalty is better.\n    var bestMaskPattern = -1;\n    // We try all mask patterns to choose the best one.\n    for (var maskPattern = 0; maskPattern < QRCode_1.default.NUM_MASK_PATTERNS; maskPattern++) {\n      MatrixUtil_1.default.buildMatrix(bits, ecLevel, version, maskPattern, matrix);\n      var penalty = this.calculateMaskPenalty(matrix);\n      if (penalty < minPenalty) {\n        minPenalty = penalty;\n        bestMaskPattern = maskPattern;\n      }\n    }\n    return bestMaskPattern;\n  };\n  Encoder.chooseVersion = function (numInputBits /*int*/, ecLevel) {\n    for (var versionNum = 1; versionNum <= 40; versionNum++) {\n      var version = Version_1.default.getVersionForNumber(versionNum);\n      if (Encoder.willFit(numInputBits, version, ecLevel)) {\n        return version;\n      }\n    }\n    throw new WriterException_1.default('Data too big');\n  };\n  /**\n   * @return true if the number of input bits will fit in a code with the specified version and\n   * error correction level.\n   */\n  Encoder.willFit = function (numInputBits /*int*/, version, ecLevel) {\n    // In the following comments, we use numbers of Version 7-H.\n    // numBytes = 196\n    var numBytes = version.getTotalCodewords();\n    // getNumECBytes = 130\n    var ecBlocks = version.getECBlocksForLevel(ecLevel);\n    var numEcBytes = ecBlocks.getTotalECCodewords();\n    // getNumDataBytes = 196 - 130 = 66\n    var numDataBytes = numBytes - numEcBytes;\n    var totalInputBytes = (numInputBits + 7) / 8;\n    return numDataBytes >= totalInputBytes;\n  };\n  /**\n   * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).\n   */\n  Encoder.terminateBits = function (numDataBytes /*int*/, bits) {\n    var capacity = numDataBytes * 8;\n    if (bits.getSize() > capacity) {\n      throw new WriterException_1.default('data bits cannot fit in the QR Code' + bits.getSize() + ' > ' + capacity);\n    }\n    for (var i = 0; i < 4 && bits.getSize() < capacity; ++i) {\n      bits.appendBit(false);\n    }\n    // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.\n    // If the last byte isn't 8-bit aligned, we'll add padding bits.\n    var numBitsInLastByte = bits.getSize() & 0x07;\n    if (numBitsInLastByte > 0) {\n      for (var i = numBitsInLastByte; i < 8; i++) {\n        bits.appendBit(false);\n      }\n    }\n    // If we have more space, we'll fill the space with padding patterns defined in 8.4.9 (p.24).\n    var numPaddingBytes = numDataBytes - bits.getSizeInBytes();\n    for (var i = 0; i < numPaddingBytes; ++i) {\n      bits.appendBits((i & 0x01) === 0 ? 0xEC : 0x11, 8);\n    }\n    if (bits.getSize() !== capacity) {\n      throw new WriterException_1.default('Bits size does not equal capacity');\n    }\n  };\n  /**\n   * Get number of data bytes and number of error correction bytes for block id \"blockID\". Store\n   * the result in \"numDataBytesInBlock\", and \"numECBytesInBlock\". See table 12 in 8.5.1 of\n   * JISX0510:2004 (p.30)\n   */\n  Encoder.getNumDataBytesAndNumECBytesForBlockID = function (numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/, blockID /*int*/, numDataBytesInBlock, numECBytesInBlock) {\n    if (blockID >= numRSBlocks) {\n      throw new WriterException_1.default('Block ID too large');\n    }\n    // numRsBlocksInGroup2 = 196 % 5 = 1\n    var numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;\n    // numRsBlocksInGroup1 = 5 - 1 = 4\n    var numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;\n    // numTotalBytesInGroup1 = 196 / 5 = 39\n    var numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);\n    // numTotalBytesInGroup2 = 39 + 1 = 40\n    var numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;\n    // numDataBytesInGroup1 = 66 / 5 = 13\n    var numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);\n    // numDataBytesInGroup2 = 13 + 1 = 14\n    var numDataBytesInGroup2 = numDataBytesInGroup1 + 1;\n    // numEcBytesInGroup1 = 39 - 13 = 26\n    var numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;\n    // numEcBytesInGroup2 = 40 - 14 = 26\n    var numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;\n    // Sanity checks.\n    // 26 = 26\n    if (numEcBytesInGroup1 !== numEcBytesInGroup2) {\n      throw new WriterException_1.default('EC bytes mismatch');\n    }\n    // 5 = 4 + 1.\n    if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {\n      throw new WriterException_1.default('RS blocks mismatch');\n    }\n    // 196 = (13 + 26) * 4 + (14 + 26) * 1\n    if (numTotalBytes !== (numDataBytesInGroup1 + numEcBytesInGroup1) * numRsBlocksInGroup1 + (numDataBytesInGroup2 + numEcBytesInGroup2) * numRsBlocksInGroup2) {\n      throw new WriterException_1.default('Total bytes mismatch');\n    }\n    if (blockID < numRsBlocksInGroup1) {\n      numDataBytesInBlock[0] = numDataBytesInGroup1;\n      numECBytesInBlock[0] = numEcBytesInGroup1;\n    } else {\n      numDataBytesInBlock[0] = numDataBytesInGroup2;\n      numECBytesInBlock[0] = numEcBytesInGroup2;\n    }\n  };\n  /**\n   * Interleave \"bits\" with corresponding error correction bytes. On success, store the result in\n   * \"result\". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.\n   */\n  Encoder.interleaveWithECBytes = function (bits, numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/) {\n    var e_1, _a, e_2, _b;\n    // \"bits\" must have \"getNumDataBytes\" bytes of data.\n    if (bits.getSizeInBytes() !== numDataBytes) {\n      throw new WriterException_1.default('Number of bits and data bytes does not match');\n    }\n    // Step 1.  Divide data bytes into blocks and generate error correction bytes for them. We'll\n    // store the divided data bytes blocks and error correction bytes blocks into \"blocks\".\n    var dataBytesOffset = 0;\n    var maxNumDataBytes = 0;\n    var maxNumEcBytes = 0;\n    // Since, we know the number of reedsolmon blocks, we can initialize the vector with the number.\n    var blocks = new Array(); // new Array<BlockPair>(numRSBlocks)\n    for (var i = 0; i < numRSBlocks; ++i) {\n      var numDataBytesInBlock = new Int32Array(1);\n      var numEcBytesInBlock = new Int32Array(1);\n      Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);\n      var size = numDataBytesInBlock[0];\n      var dataBytes = new Uint8Array(size);\n      bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);\n      var ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);\n      blocks.push(new BlockPair_1.default(dataBytes, ecBytes));\n      maxNumDataBytes = Math.max(maxNumDataBytes, size);\n      maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);\n      dataBytesOffset += numDataBytesInBlock[0];\n    }\n    if (numDataBytes !== dataBytesOffset) {\n      throw new WriterException_1.default('Data bytes does not match offset');\n    }\n    var result = new BitArray_1.default();\n    // First, place data blocks.\n    for (var i = 0; i < maxNumDataBytes; ++i) {\n      try {\n        for (var blocks_1 = __values(blocks), blocks_1_1 = blocks_1.next(); !blocks_1_1.done; blocks_1_1 = blocks_1.next()) {\n          var block = blocks_1_1.value;\n          var dataBytes = block.getDataBytes();\n          if (i < dataBytes.length) {\n            result.appendBits(dataBytes[i], 8);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (blocks_1_1 && !blocks_1_1.done && (_a = blocks_1.return)) _a.call(blocks_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n    // Then, place error correction blocks.\n    for (var i = 0; i < maxNumEcBytes; ++i) {\n      try {\n        for (var blocks_2 = __values(blocks), blocks_2_1 = blocks_2.next(); !blocks_2_1.done; blocks_2_1 = blocks_2.next()) {\n          var block = blocks_2_1.value;\n          var ecBytes = block.getErrorCorrectionBytes();\n          if (i < ecBytes.length) {\n            result.appendBits(ecBytes[i], 8);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (blocks_2_1 && !blocks_2_1.done && (_b = blocks_2.return)) _b.call(blocks_2);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n    if (numTotalBytes !== result.getSizeInBytes()) {\n      // Should be same.\n      throw new WriterException_1.default('Interleaving error: ' + numTotalBytes + ' and ' + result.getSizeInBytes() + ' differ.');\n    }\n    return result;\n  };\n  Encoder.generateECBytes = function (dataBytes, numEcBytesInBlock /*int*/) {\n    var numDataBytes = dataBytes.length;\n    var toEncode = new Int32Array(numDataBytes + numEcBytesInBlock); // int[numDataBytes + numEcBytesInBlock]\n    for (var i = 0; i < numDataBytes; i++) {\n      toEncode[i] = dataBytes[i] & 0xFF;\n    }\n    new ReedSolomonEncoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);\n    var ecBytes = new Uint8Array(numEcBytesInBlock);\n    for (var i = 0; i < numEcBytesInBlock; i++) {\n      ecBytes[i] = /*(byte) */toEncode[numDataBytes + i];\n    }\n    return ecBytes;\n  };\n  /**\n   * Append mode info. On success, store the result in \"bits\".\n   */\n  Encoder.appendModeInfo = function (mode, bits) {\n    bits.appendBits(mode.getBits(), 4);\n  };\n  /**\n   * Append length info. On success, store the result in \"bits\".\n   */\n  Encoder.appendLengthInfo = function (numLetters /*int*/, version, mode, bits) {\n    var numBits = mode.getCharacterCountBits(version);\n    if (numLetters >= 1 << numBits) {\n      throw new WriterException_1.default(numLetters + ' is bigger than ' + ((1 << numBits) - 1));\n    }\n    bits.appendBits(numLetters, numBits);\n  };\n  /**\n   * Append \"bytes\" in \"mode\" mode (encoding) into \"bits\". On success, store the result in \"bits\".\n   */\n  Encoder.appendBytes = function (content, mode, bits, encoding) {\n    switch (mode) {\n      case Mode_1.default.NUMERIC:\n        Encoder.appendNumericBytes(content, bits);\n        break;\n      case Mode_1.default.ALPHANUMERIC:\n        Encoder.appendAlphanumericBytes(content, bits);\n        break;\n      case Mode_1.default.BYTE:\n        Encoder.append8BitBytes(content, bits, encoding);\n        break;\n      case Mode_1.default.KANJI:\n        Encoder.appendKanjiBytes(content, bits);\n        break;\n      default:\n        throw new WriterException_1.default('Invalid mode: ' + mode);\n    }\n  };\n  Encoder.getDigit = function (singleCharacter) {\n    return singleCharacter.charCodeAt(0) - 48;\n  };\n  Encoder.isDigit = function (singleCharacter) {\n    var cn = Encoder.getDigit(singleCharacter);\n    return cn >= 0 && cn <= 9;\n  };\n  Encoder.appendNumericBytes = function (content, bits) {\n    var length = content.length;\n    var i = 0;\n    while (i < length) {\n      var num1 = Encoder.getDigit(content.charAt(i));\n      if (i + 2 < length) {\n        // Encode three numeric letters in ten bits.\n        var num2 = Encoder.getDigit(content.charAt(i + 1));\n        var num3 = Encoder.getDigit(content.charAt(i + 2));\n        bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);\n        i += 3;\n      } else if (i + 1 < length) {\n        // Encode two numeric letters in seven bits.\n        var num2 = Encoder.getDigit(content.charAt(i + 1));\n        bits.appendBits(num1 * 10 + num2, 7);\n        i += 2;\n      } else {\n        // Encode one numeric letter in four bits.\n        bits.appendBits(num1, 4);\n        i++;\n      }\n    }\n  };\n  Encoder.appendAlphanumericBytes = function (content, bits) {\n    var length = content.length;\n    var i = 0;\n    while (i < length) {\n      var code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));\n      if (code1 === -1) {\n        throw new WriterException_1.default();\n      }\n      if (i + 1 < length) {\n        var code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));\n        if (code2 === -1) {\n          throw new WriterException_1.default();\n        }\n        // Encode two alphanumeric letters in 11 bits.\n        bits.appendBits(code1 * 45 + code2, 11);\n        i += 2;\n      } else {\n        // Encode one alphanumeric letter in six bits.\n        bits.appendBits(code1, 6);\n        i++;\n      }\n    }\n  };\n  Encoder.append8BitBytes = function (content, bits, encoding) {\n    var bytes;\n    try {\n      bytes = StringEncoding_1.default.encode(content, encoding);\n    } catch (uee /*: UnsupportedEncodingException*/) {\n      throw new WriterException_1.default(uee);\n    }\n    for (var i = 0, length_2 = bytes.length; i !== length_2; i++) {\n      var b = bytes[i];\n      bits.appendBits(b, 8);\n    }\n  };\n  /**\n   * @throws WriterException\n   */\n  Encoder.appendKanjiBytes = function (content, bits) {\n    var bytes;\n    try {\n      bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS);\n    } catch (uee /*: UnsupportedEncodingException*/) {\n      throw new WriterException_1.default(uee);\n    }\n    var length = bytes.length;\n    for (var i = 0; i < length; i += 2) {\n      var byte1 = bytes[i] & 0xFF;\n      var byte2 = bytes[i + 1] & 0xFF;\n      var code = byte1 << 8 & 0xFFFFFFFF | byte2;\n      var subtracted = -1;\n      if (code >= 0x8140 && code <= 0x9ffc) {\n        subtracted = code - 0x8140;\n      } else if (code >= 0xe040 && code <= 0xebbf) {\n        subtracted = code - 0xc140;\n      }\n      if (subtracted === -1) {\n        throw new WriterException_1.default('Invalid byte sequence');\n      }\n      var encoded = (subtracted >> 8) * 0xc0 + (subtracted & 0xff);\n      bits.appendBits(encoded, 13);\n    }\n  };\n  Encoder.appendECI = function (eci, bits) {\n    bits.appendBits(Mode_1.default.ECI.getBits(), 4);\n    // This is correct for values up to 127, which is all we need now.\n    bits.appendBits(eci.getValue(), 8);\n  };\n  // The original table is defined in the table 5 of JISX0510:2004 (p.19).\n  Encoder.ALPHANUMERIC_TABLE = Int32Array.from([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1]);\n  Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI_1.default.UTF8.getName(); // \"ISO-8859-1\"\n  return Encoder;\n}();\nexports.default = Encoder;","map":{"version":3,"sources":["../../../../src/core/qrcode/encoder/Encoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.qrcode.encoder {*/\nvar EncodeHintType_1 = require(\"../../EncodeHintType\");\nvar BitArray_1 = require(\"../../common/BitArray\");\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\");\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\nvar ReedSolomonEncoder_1 = require(\"../../common/reedsolomon/ReedSolomonEncoder\");\nvar Mode_1 = require(\"../decoder/Mode\");\nvar Version_1 = require(\"../decoder/Version\");\nvar MaskUtil_1 = require(\"./MaskUtil\");\nvar ByteMatrix_1 = require(\"./ByteMatrix\");\nvar QRCode_1 = require(\"./QRCode\");\nvar MatrixUtil_1 = require(\"./MatrixUtil\");\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\nvar BlockPair_1 = require(\"./BlockPair\");\nvar WriterException_1 = require(\"../../WriterException\");\n/*import java.io.UnsupportedEncodingException;*/\n/*import java.util.ArrayList;*/\n/*import java.util.Collection;*/\n/*import java.util.Map;*/\n/**\n * @author satorux@google.com (Satoru Takabayashi) - creator\n * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n */\nvar Encoder = /** @class */ (function () {\n    // TYPESCRIPTPORT: changed to UTF8, the default for js\n    function Encoder() {\n    }\n    // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.\n    // Basically it applies four rules and summate all penalties.\n    Encoder.calculateMaskPenalty = function (matrix) {\n        return MaskUtil_1.default.applyMaskPenaltyRule1(matrix)\n            + MaskUtil_1.default.applyMaskPenaltyRule2(matrix)\n            + MaskUtil_1.default.applyMaskPenaltyRule3(matrix)\n            + MaskUtil_1.default.applyMaskPenaltyRule4(matrix);\n    };\n    /**\n     * @param content text to encode\n     * @param ecLevel error correction level to use\n     * @return {@link QRCode} representing the encoded QR code\n     * @throws WriterException if encoding can't succeed, because of for example invalid content\n     *   or configuration\n     */\n    // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {\n    //   return encode(content, ecLevel, null)\n    // }\n    Encoder.encode = function (content, ecLevel, hints) {\n        if (hints === void 0) { hints = null; }\n        // Determine what character encoding has been specified by the caller, if any\n        var encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;\n        var hasEncodingHint = hints !== null && undefined !== hints.get(EncodeHintType_1.default.CHARACTER_SET);\n        if (hasEncodingHint) {\n            encoding = hints.get(EncodeHintType_1.default.CHARACTER_SET).toString();\n        }\n        // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n        // multiple modes / segments even if that were more efficient. Twould be nice.\n        var mode = this.chooseMode(content, encoding);\n        // This will store the header information, like mode and\n        // length, as well as \"header\" segments like an ECI segment.\n        var headerBits = new BitArray_1.default();\n        // Append ECI segment if applicable\n        if (mode === Mode_1.default.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {\n            var eci = CharacterSetECI_1.default.getCharacterSetECIByName(encoding);\n            if (eci !== undefined) {\n                this.appendECI(eci, headerBits);\n            }\n        }\n        // (With ECI in place,) Write the mode marker\n        this.appendModeInfo(mode, headerBits);\n        // Collect data within the main segment, separately, to count its size if needed. Don't add it to\n        // main payload yet.\n        var dataBits = new BitArray_1.default();\n        this.appendBytes(content, mode, dataBits, encoding);\n        var version;\n        if (hints !== null && undefined !== hints.get(EncodeHintType_1.default.QR_VERSION)) {\n            var versionNumber = Number.parseInt(hints.get(EncodeHintType_1.default.QR_VERSION).toString(), 10);\n            version = Version_1.default.getVersionForNumber(versionNumber);\n            var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);\n            if (!this.willFit(bitsNeeded, version, ecLevel)) {\n                throw new WriterException_1.default('Data too big for requested version');\n            }\n        }\n        else {\n            version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);\n        }\n        var headerAndDataBits = new BitArray_1.default();\n        headerAndDataBits.appendBitArray(headerBits);\n        // Find \"length\" of main segment and write it\n        var numLetters = mode === Mode_1.default.BYTE ? dataBits.getSizeInBytes() : content.length;\n        this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);\n        // Put data together into the overall payload\n        headerAndDataBits.appendBitArray(dataBits);\n        var ecBlocks = version.getECBlocksForLevel(ecLevel);\n        var numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();\n        // Terminate the bits properly.\n        this.terminateBits(numDataBytes, headerAndDataBits);\n        // Interleave data bits with error correction code.\n        var finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());\n        var qrCode = new QRCode_1.default();\n        qrCode.setECLevel(ecLevel);\n        qrCode.setMode(mode);\n        qrCode.setVersion(version);\n        //  Choose the mask pattern and set to \"qrCode\".\n        var dimension = version.getDimensionForVersion();\n        var matrix = new ByteMatrix_1.default(dimension, dimension);\n        var maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);\n        qrCode.setMaskPattern(maskPattern);\n        // Build the matrix and set it to \"qrCode\".\n        MatrixUtil_1.default.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);\n        qrCode.setMatrix(matrix);\n        return qrCode;\n    };\n    /**\n     * Decides the smallest version of QR code that will contain all of the provided data.\n     *\n     * @throws WriterException if the data cannot fit in any version\n     */\n    Encoder.recommendVersion = function (ecLevel, mode, headerBits, dataBits) {\n        // Hard part: need to know version to know how many bits length takes. But need to know how many\n        // bits it takes to know version. First we take a guess at version by assuming version will be\n        // the minimum, 1:\n        var provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version_1.default.getVersionForNumber(1));\n        var provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);\n        // Use that guess to calculate the right version. I am still not sure this works in 100% of cases.\n        var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);\n        return this.chooseVersion(bitsNeeded, ecLevel);\n    };\n    Encoder.calculateBitsNeeded = function (mode, headerBits, dataBits, version) {\n        return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();\n    };\n    /**\n     * @return the code point of the table used in alphanumeric mode or\n     *  -1 if there is no corresponding code in the table.\n     */\n    Encoder.getAlphanumericCode = function (code /*int*/) {\n        if (code < Encoder.ALPHANUMERIC_TABLE.length) {\n            return Encoder.ALPHANUMERIC_TABLE[code];\n        }\n        return -1;\n    };\n    // public static chooseMode(content: string): Mode {\n    //   return chooseMode(content, null);\n    // }\n    /**\n     * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;\n     * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.\n     */\n    Encoder.chooseMode = function (content, encoding) {\n        if (encoding === void 0) { encoding = null; }\n        if (CharacterSetECI_1.default.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {\n            // Choose Kanji mode if all input are double-byte characters\n            return Mode_1.default.KANJI;\n        }\n        var hasNumeric = false;\n        var hasAlphanumeric = false;\n        for (var i = 0, length_1 = content.length; i < length_1; ++i) {\n            var c = content.charAt(i);\n            if (Encoder.isDigit(c)) {\n                hasNumeric = true;\n            }\n            else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {\n                hasAlphanumeric = true;\n            }\n            else {\n                return Mode_1.default.BYTE;\n            }\n        }\n        if (hasAlphanumeric) {\n            return Mode_1.default.ALPHANUMERIC;\n        }\n        if (hasNumeric) {\n            return Mode_1.default.NUMERIC;\n        }\n        return Mode_1.default.BYTE;\n    };\n    Encoder.isOnlyDoubleByteKanji = function (content) {\n        var bytes;\n        try {\n            bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS); // content.getBytes(\"Shift_JIS\"))\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            return false;\n        }\n        var length = bytes.length;\n        if (length % 2 !== 0) {\n            return false;\n        }\n        for (var i = 0; i < length; i += 2) {\n            var byte1 = bytes[i] & 0xFF;\n            if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Encoder.chooseMaskPattern = function (bits, ecLevel, version, matrix) {\n        var minPenalty = Number.MAX_SAFE_INTEGER; // Lower penalty is better.\n        var bestMaskPattern = -1;\n        // We try all mask patterns to choose the best one.\n        for (var maskPattern = 0; maskPattern < QRCode_1.default.NUM_MASK_PATTERNS; maskPattern++) {\n            MatrixUtil_1.default.buildMatrix(bits, ecLevel, version, maskPattern, matrix);\n            var penalty = this.calculateMaskPenalty(matrix);\n            if (penalty < minPenalty) {\n                minPenalty = penalty;\n                bestMaskPattern = maskPattern;\n            }\n        }\n        return bestMaskPattern;\n    };\n    Encoder.chooseVersion = function (numInputBits /*int*/, ecLevel) {\n        for (var versionNum = 1; versionNum <= 40; versionNum++) {\n            var version = Version_1.default.getVersionForNumber(versionNum);\n            if (Encoder.willFit(numInputBits, version, ecLevel)) {\n                return version;\n            }\n        }\n        throw new WriterException_1.default('Data too big');\n    };\n    /**\n     * @return true if the number of input bits will fit in a code with the specified version and\n     * error correction level.\n     */\n    Encoder.willFit = function (numInputBits /*int*/, version, ecLevel) {\n        // In the following comments, we use numbers of Version 7-H.\n        // numBytes = 196\n        var numBytes = version.getTotalCodewords();\n        // getNumECBytes = 130\n        var ecBlocks = version.getECBlocksForLevel(ecLevel);\n        var numEcBytes = ecBlocks.getTotalECCodewords();\n        // getNumDataBytes = 196 - 130 = 66\n        var numDataBytes = numBytes - numEcBytes;\n        var totalInputBytes = (numInputBits + 7) / 8;\n        return numDataBytes >= totalInputBytes;\n    };\n    /**\n     * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).\n     */\n    Encoder.terminateBits = function (numDataBytes /*int*/, bits) {\n        var capacity = numDataBytes * 8;\n        if (bits.getSize() > capacity) {\n            throw new WriterException_1.default('data bits cannot fit in the QR Code' + bits.getSize() + ' > ' +\n                capacity);\n        }\n        for (var i = 0; i < 4 && bits.getSize() < capacity; ++i) {\n            bits.appendBit(false);\n        }\n        // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.\n        // If the last byte isn't 8-bit aligned, we'll add padding bits.\n        var numBitsInLastByte = bits.getSize() & 0x07;\n        if (numBitsInLastByte > 0) {\n            for (var i = numBitsInLastByte; i < 8; i++) {\n                bits.appendBit(false);\n            }\n        }\n        // If we have more space, we'll fill the space with padding patterns defined in 8.4.9 (p.24).\n        var numPaddingBytes = numDataBytes - bits.getSizeInBytes();\n        for (var i = 0; i < numPaddingBytes; ++i) {\n            bits.appendBits((i & 0x01) === 0 ? 0xEC : 0x11, 8);\n        }\n        if (bits.getSize() !== capacity) {\n            throw new WriterException_1.default('Bits size does not equal capacity');\n        }\n    };\n    /**\n     * Get number of data bytes and number of error correction bytes for block id \"blockID\". Store\n     * the result in \"numDataBytesInBlock\", and \"numECBytesInBlock\". See table 12 in 8.5.1 of\n     * JISX0510:2004 (p.30)\n     */\n    Encoder.getNumDataBytesAndNumECBytesForBlockID = function (numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/, blockID /*int*/, numDataBytesInBlock, numECBytesInBlock) {\n        if (blockID >= numRSBlocks) {\n            throw new WriterException_1.default('Block ID too large');\n        }\n        // numRsBlocksInGroup2 = 196 % 5 = 1\n        var numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;\n        // numRsBlocksInGroup1 = 5 - 1 = 4\n        var numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;\n        // numTotalBytesInGroup1 = 196 / 5 = 39\n        var numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);\n        // numTotalBytesInGroup2 = 39 + 1 = 40\n        var numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;\n        // numDataBytesInGroup1 = 66 / 5 = 13\n        var numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);\n        // numDataBytesInGroup2 = 13 + 1 = 14\n        var numDataBytesInGroup2 = numDataBytesInGroup1 + 1;\n        // numEcBytesInGroup1 = 39 - 13 = 26\n        var numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;\n        // numEcBytesInGroup2 = 40 - 14 = 26\n        var numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;\n        // Sanity checks.\n        // 26 = 26\n        if (numEcBytesInGroup1 !== numEcBytesInGroup2) {\n            throw new WriterException_1.default('EC bytes mismatch');\n        }\n        // 5 = 4 + 1.\n        if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {\n            throw new WriterException_1.default('RS blocks mismatch');\n        }\n        // 196 = (13 + 26) * 4 + (14 + 26) * 1\n        if (numTotalBytes !==\n            ((numDataBytesInGroup1 + numEcBytesInGroup1) *\n                numRsBlocksInGroup1) +\n                ((numDataBytesInGroup2 + numEcBytesInGroup2) *\n                    numRsBlocksInGroup2)) {\n            throw new WriterException_1.default('Total bytes mismatch');\n        }\n        if (blockID < numRsBlocksInGroup1) {\n            numDataBytesInBlock[0] = numDataBytesInGroup1;\n            numECBytesInBlock[0] = numEcBytesInGroup1;\n        }\n        else {\n            numDataBytesInBlock[0] = numDataBytesInGroup2;\n            numECBytesInBlock[0] = numEcBytesInGroup2;\n        }\n    };\n    /**\n     * Interleave \"bits\" with corresponding error correction bytes. On success, store the result in\n     * \"result\". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.\n     */\n    Encoder.interleaveWithECBytes = function (bits, numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/) {\n        var e_1, _a, e_2, _b;\n        // \"bits\" must have \"getNumDataBytes\" bytes of data.\n        if (bits.getSizeInBytes() !== numDataBytes) {\n            throw new WriterException_1.default('Number of bits and data bytes does not match');\n        }\n        // Step 1.  Divide data bytes into blocks and generate error correction bytes for them. We'll\n        // store the divided data bytes blocks and error correction bytes blocks into \"blocks\".\n        var dataBytesOffset = 0;\n        var maxNumDataBytes = 0;\n        var maxNumEcBytes = 0;\n        // Since, we know the number of reedsolmon blocks, we can initialize the vector with the number.\n        var blocks = new Array(); // new Array<BlockPair>(numRSBlocks)\n        for (var i = 0; i < numRSBlocks; ++i) {\n            var numDataBytesInBlock = new Int32Array(1);\n            var numEcBytesInBlock = new Int32Array(1);\n            Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);\n            var size = numDataBytesInBlock[0];\n            var dataBytes = new Uint8Array(size);\n            bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);\n            var ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);\n            blocks.push(new BlockPair_1.default(dataBytes, ecBytes));\n            maxNumDataBytes = Math.max(maxNumDataBytes, size);\n            maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);\n            dataBytesOffset += numDataBytesInBlock[0];\n        }\n        if (numDataBytes !== dataBytesOffset) {\n            throw new WriterException_1.default('Data bytes does not match offset');\n        }\n        var result = new BitArray_1.default();\n        // First, place data blocks.\n        for (var i = 0; i < maxNumDataBytes; ++i) {\n            try {\n                for (var blocks_1 = __values(blocks), blocks_1_1 = blocks_1.next(); !blocks_1_1.done; blocks_1_1 = blocks_1.next()) {\n                    var block = blocks_1_1.value;\n                    var dataBytes = block.getDataBytes();\n                    if (i < dataBytes.length) {\n                        result.appendBits(dataBytes[i], 8);\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (blocks_1_1 && !blocks_1_1.done && (_a = blocks_1.return)) _a.call(blocks_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        // Then, place error correction blocks.\n        for (var i = 0; i < maxNumEcBytes; ++i) {\n            try {\n                for (var blocks_2 = __values(blocks), blocks_2_1 = blocks_2.next(); !blocks_2_1.done; blocks_2_1 = blocks_2.next()) {\n                    var block = blocks_2_1.value;\n                    var ecBytes = block.getErrorCorrectionBytes();\n                    if (i < ecBytes.length) {\n                        result.appendBits(ecBytes[i], 8);\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (blocks_2_1 && !blocks_2_1.done && (_b = blocks_2.return)) _b.call(blocks_2);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n        if (numTotalBytes !== result.getSizeInBytes()) { // Should be same.\n            throw new WriterException_1.default('Interleaving error: ' + numTotalBytes + ' and ' +\n                result.getSizeInBytes() + ' differ.');\n        }\n        return result;\n    };\n    Encoder.generateECBytes = function (dataBytes, numEcBytesInBlock /*int*/) {\n        var numDataBytes = dataBytes.length;\n        var toEncode = new Int32Array(numDataBytes + numEcBytesInBlock); // int[numDataBytes + numEcBytesInBlock]\n        for (var i = 0; i < numDataBytes; i++) {\n            toEncode[i] = dataBytes[i] & 0xFF;\n        }\n        new ReedSolomonEncoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);\n        var ecBytes = new Uint8Array(numEcBytesInBlock);\n        for (var i = 0; i < numEcBytesInBlock; i++) {\n            ecBytes[i] = /*(byte) */ toEncode[numDataBytes + i];\n        }\n        return ecBytes;\n    };\n    /**\n     * Append mode info. On success, store the result in \"bits\".\n     */\n    Encoder.appendModeInfo = function (mode, bits) {\n        bits.appendBits(mode.getBits(), 4);\n    };\n    /**\n     * Append length info. On success, store the result in \"bits\".\n     */\n    Encoder.appendLengthInfo = function (numLetters /*int*/, version, mode, bits) {\n        var numBits = mode.getCharacterCountBits(version);\n        if (numLetters >= (1 << numBits)) {\n            throw new WriterException_1.default(numLetters + ' is bigger than ' + ((1 << numBits) - 1));\n        }\n        bits.appendBits(numLetters, numBits);\n    };\n    /**\n     * Append \"bytes\" in \"mode\" mode (encoding) into \"bits\". On success, store the result in \"bits\".\n     */\n    Encoder.appendBytes = function (content, mode, bits, encoding) {\n        switch (mode) {\n            case Mode_1.default.NUMERIC:\n                Encoder.appendNumericBytes(content, bits);\n                break;\n            case Mode_1.default.ALPHANUMERIC:\n                Encoder.appendAlphanumericBytes(content, bits);\n                break;\n            case Mode_1.default.BYTE:\n                Encoder.append8BitBytes(content, bits, encoding);\n                break;\n            case Mode_1.default.KANJI:\n                Encoder.appendKanjiBytes(content, bits);\n                break;\n            default:\n                throw new WriterException_1.default('Invalid mode: ' + mode);\n        }\n    };\n    Encoder.getDigit = function (singleCharacter) {\n        return singleCharacter.charCodeAt(0) - 48;\n    };\n    Encoder.isDigit = function (singleCharacter) {\n        var cn = Encoder.getDigit(singleCharacter);\n        return cn >= 0 && cn <= 9;\n    };\n    Encoder.appendNumericBytes = function (content, bits) {\n        var length = content.length;\n        var i = 0;\n        while (i < length) {\n            var num1 = Encoder.getDigit(content.charAt(i));\n            if (i + 2 < length) {\n                // Encode three numeric letters in ten bits.\n                var num2 = Encoder.getDigit(content.charAt(i + 1));\n                var num3 = Encoder.getDigit(content.charAt(i + 2));\n                bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);\n                i += 3;\n            }\n            else if (i + 1 < length) {\n                // Encode two numeric letters in seven bits.\n                var num2 = Encoder.getDigit(content.charAt(i + 1));\n                bits.appendBits(num1 * 10 + num2, 7);\n                i += 2;\n            }\n            else {\n                // Encode one numeric letter in four bits.\n                bits.appendBits(num1, 4);\n                i++;\n            }\n        }\n    };\n    Encoder.appendAlphanumericBytes = function (content, bits) {\n        var length = content.length;\n        var i = 0;\n        while (i < length) {\n            var code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));\n            if (code1 === -1) {\n                throw new WriterException_1.default();\n            }\n            if (i + 1 < length) {\n                var code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));\n                if (code2 === -1) {\n                    throw new WriterException_1.default();\n                }\n                // Encode two alphanumeric letters in 11 bits.\n                bits.appendBits(code1 * 45 + code2, 11);\n                i += 2;\n            }\n            else {\n                // Encode one alphanumeric letter in six bits.\n                bits.appendBits(code1, 6);\n                i++;\n            }\n        }\n    };\n    Encoder.append8BitBytes = function (content, bits, encoding) {\n        var bytes;\n        try {\n            bytes = StringEncoding_1.default.encode(content, encoding);\n        }\n        catch (uee /*: UnsupportedEncodingException*/) {\n            throw new WriterException_1.default(uee);\n        }\n        for (var i = 0, length_2 = bytes.length; i !== length_2; i++) {\n            var b = bytes[i];\n            bits.appendBits(b, 8);\n        }\n    };\n    /**\n     * @throws WriterException\n     */\n    Encoder.appendKanjiBytes = function (content, bits) {\n        var bytes;\n        try {\n            bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS);\n        }\n        catch (uee /*: UnsupportedEncodingException*/) {\n            throw new WriterException_1.default(uee);\n        }\n        var length = bytes.length;\n        for (var i = 0; i < length; i += 2) {\n            var byte1 = bytes[i] & 0xFF;\n            var byte2 = bytes[i + 1] & 0xFF;\n            var code = ((byte1 << 8) & 0xFFFFFFFF) | byte2;\n            var subtracted = -1;\n            if (code >= 0x8140 && code <= 0x9ffc) {\n                subtracted = code - 0x8140;\n            }\n            else if (code >= 0xe040 && code <= 0xebbf) {\n                subtracted = code - 0xc140;\n            }\n            if (subtracted === -1) {\n                throw new WriterException_1.default('Invalid byte sequence');\n            }\n            var encoded = ((subtracted >> 8) * 0xc0) + (subtracted & 0xff);\n            bits.appendBits(encoded, 13);\n        }\n    };\n    Encoder.appendECI = function (eci, bits) {\n        bits.appendBits(Mode_1.default.ECI.getBits(), 4);\n        // This is correct for values up to 127, which is all we need now.\n        bits.appendBits(eci.getValue(), 8);\n    };\n    // The original table is defined in the table 5 of JISX0510:2004 (p.19).\n    Encoder.ALPHANUMERIC_TABLE = Int32Array.from([\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1,\n        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n    ]);\n    Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI_1.default.UTF8.getName(); // \"ISO-8859-1\"\n    return Encoder;\n}());\nexports.default = Encoder;\n//# sourceMappingURL=Encoder.js.map"]},"metadata":{},"sourceType":"script"}