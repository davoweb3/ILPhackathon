{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar GlobalHistogramBinarizer_1 = require(\"./GlobalHistogramBinarizer\");\nvar BitMatrix_1 = require(\"./BitMatrix\");\n/**\n * This class implements a local thresholding algorithm, which while slower than the\n * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for\n * high frequency images of barcodes with black data on white backgrounds. For this application,\n * it does a much better job than a global blackpoint with severe shadows and gradients.\n * However it tends to produce artifacts on lower frequency images and is therefore not\n * a good general purpose binarizer for uses outside ZXing.\n *\n * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,\n * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already\n * inherently local, and only fails for horizontal gradients. We can revisit that problem later,\n * but for now it was not a win to use local blocks for 1D.\n *\n * This Binarizer is the default for the unit tests and the recommended class for library users.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar HybridBinarizer = /** @class */function (_super) {\n  __extends(HybridBinarizer, _super);\n  function HybridBinarizer(source) {\n    var _this = _super.call(this, source) || this;\n    _this.matrix = null;\n    return _this;\n  }\n  /**\n   * Calculates the final BitMatrix once for all requests. This could be called once from the\n   * constructor instead, but there are some advantages to doing it lazily, such as making\n   * profiling easier, and not doing heavy lifting when callers don't expect it.\n   */\n  /*@Override*/\n  HybridBinarizer.prototype.getBlackMatrix = function () {\n    if (this.matrix !== null) {\n      return this.matrix;\n    }\n    var source = this.getLuminanceSource();\n    var width = source.getWidth();\n    var height = source.getHeight();\n    if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {\n      var luminances = source.getMatrix();\n      var subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;\n      if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n        subWidth++;\n      }\n      var subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;\n      if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n        subHeight++;\n      }\n      var blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);\n      var newMatrix = new BitMatrix_1.default(width, height);\n      HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);\n      this.matrix = newMatrix;\n    } else {\n      // If the image is too small, fall back to the global histogram approach.\n      this.matrix = _super.prototype.getBlackMatrix.call(this);\n    }\n    return this.matrix;\n  };\n  /*@Override*/\n  HybridBinarizer.prototype.createBinarizer = function (source) {\n    return new HybridBinarizer(source);\n  };\n  /**\n   * For each block in the image, calculate the average black point using a 5x5 grid\n   * of the blocks around it. Also handles the corner cases (fractional blocks are computed based\n   * on the last pixels in the row/column which are also used in the previous block).\n   */\n  HybridBinarizer.calculateThresholdForBlock = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/, blackPoints, matrix) {\n    var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n    var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n    for (var y = 0; y < subHeight; y++) {\n      var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n      if (yoffset > maxYOffset) {\n        yoffset = maxYOffset;\n      }\n      var top_1 = HybridBinarizer.cap(y, 2, subHeight - 3);\n      for (var x = 0; x < subWidth; x++) {\n        var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n        if (xoffset > maxXOffset) {\n          xoffset = maxXOffset;\n        }\n        var left = HybridBinarizer.cap(x, 2, subWidth - 3);\n        var sum = 0;\n        for (var z = -2; z <= 2; z++) {\n          var blackRow = blackPoints[top_1 + z];\n          sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n        }\n        var average = sum / 25;\n        HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n      }\n    }\n  };\n  HybridBinarizer.cap = function (value /*int*/, min /*int*/, max /*int*/) {\n    return value < min ? min : value > max ? max : value;\n  };\n  /**\n   * Applies a single threshold to a block of pixels.\n   */\n  HybridBinarizer.thresholdBlock = function (luminances, xoffset /*int*/, yoffset /*int*/, threshold /*int*/, stride /*int*/, matrix) {\n    for (var y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {\n      for (var x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {\n        // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.\n        if ((luminances[offset + x] & 0xFF) <= threshold) {\n          matrix.set(xoffset + x, yoffset + y);\n        }\n      }\n    }\n  };\n  /**\n   * Calculates a single black point for each block of pixels and saves it away.\n   * See the following thread for a discussion of this algorithm:\n   *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0\n   */\n  HybridBinarizer.calculateBlackPoints = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/) {\n    var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n    var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n    // tslint:disable-next-line:whitespace\n    var blackPoints = new Array(subHeight); // subWidth\n    for (var y = 0; y < subHeight; y++) {\n      blackPoints[y] = new Int32Array(subWidth);\n      var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n      if (yoffset > maxYOffset) {\n        yoffset = maxYOffset;\n      }\n      for (var x = 0; x < subWidth; x++) {\n        var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n        if (xoffset > maxXOffset) {\n          xoffset = maxXOffset;\n        }\n        var sum = 0;\n        var min = 0xFF;\n        var max = 0;\n        for (var yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n          for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n            var pixel = luminances[offset + xx] & 0xFF;\n            sum += pixel;\n            // still looking for good contrast\n            if (pixel < min) {\n              min = pixel;\n            }\n            if (pixel > max) {\n              max = pixel;\n            }\n          }\n          // short-circuit min/max tests once dynamic range is met\n          if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {\n            // finish the rest of the rows quickly\n            for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n              for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n                sum += luminances[offset + xx] & 0xFF;\n              }\n            }\n          }\n        }\n        // The default estimate is the average of the values in the block.\n        var average = sum >> HybridBinarizer.BLOCK_SIZE_POWER * 2;\n        if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {\n          // If variation within the block is low, assume this is a block with only light or only\n          // dark pixels. In that case we do not want to use the average, as it would divide this\n          // low contrast area into black and white pixels, essentially creating data out of noise.\n          //\n          // The default assumption is that the block is light/background. Since no estimate for\n          // the level of dark pixels exists locally, use half the min for the block.\n          average = min / 2;\n          if (y > 0 && x > 0) {\n            // Correct the \"white background\" assumption for blocks that have neighbors by comparing\n            // the pixels in this block to the previously calculated black points. This is based on\n            // the fact that dark barcode symbology is always surrounded by some amount of light\n            // background for which reasonable black point estimates were made. The bp estimated at\n            // the boundaries is used for the interior.\n            // The (min < bp) is arbitrary but works better than other heuristics that were tried.\n            var averageNeighborBlackPoint = (blackPoints[y - 1][x] + 2 * blackPoints[y][x - 1] + blackPoints[y - 1][x - 1]) / 4;\n            if (min < averageNeighborBlackPoint) {\n              average = averageNeighborBlackPoint;\n            }\n          }\n        }\n        blackPoints[y][x] = average;\n      }\n    }\n    return blackPoints;\n  };\n  // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels.\n  // So this is the smallest dimension in each axis we can accept.\n  HybridBinarizer.BLOCK_SIZE_POWER = 3;\n  HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER; // ...0100...00\n  HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1; // ...0011...11\n  HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;\n  HybridBinarizer.MIN_DYNAMIC_RANGE = 24;\n  return HybridBinarizer;\n}(GlobalHistogramBinarizer_1.default);\nexports.default = HybridBinarizer;","map":{"version":3,"names":["GlobalHistogramBinarizer_1","require","BitMatrix_1","HybridBinarizer","_super","__extends","source","_this","call","matrix","prototype","getBlackMatrix","getLuminanceSource","width","getWidth","height","getHeight","MINIMUM_DIMENSION","luminances","getMatrix","subWidth","BLOCK_SIZE_POWER","BLOCK_SIZE_MASK","subHeight","blackPoints","calculateBlackPoints","newMatrix","default","calculateThresholdForBlock","createBinarizer","maxYOffset","BLOCK_SIZE","maxXOffset","y","yoffset","top_1","cap","x","xoffset","left","sum","z","blackRow","average","thresholdBlock","value","min","max","threshold","stride","offset","set","Array","Int32Array","yy","xx","pixel","MIN_DYNAMIC_RANGE","averageNeighborBlackPoint"],"sources":["../../../src/core/common/HybridBinarizer.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script"}