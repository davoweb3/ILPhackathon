{"ast":null,"code":"/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nimport * as utils from '../utils.js';\nexport { shimGetUserMedia } from './getusermedia';\nexport { shimGetDisplayMedia } from './getdisplaymedia';\nexport function shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\nexport function shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      if (!this._ontrackpoly) {\n        this._ontrackpoly = e => {\n          // onaddstream does not fire when a track is added to an existing\n          // stream. But stream.onaddtrack is implemented so we use that.\n          e.stream.addEventListener('addtrack', te => {\n            let receiver;\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === te.track.id);\n            } else {\n              receiver = {\n                track: te.track\n              };\n            }\n            const event = new Event('track');\n            event.track = te.track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n          e.stream.getTracks().forEach(track => {\n            let receiver;\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === track.id);\n            } else {\n              receiver = {\n                track\n              };\n            }\n            const event = new Event('track');\n            event.track = track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n        };\n        this.addEventListener('addstream', this._ontrackpoly);\n      }\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver', {\n          value: {\n            receiver: e.receiver\n          }\n        });\n      }\n      return e;\n    });\n  }\n}\nexport function shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function (pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        let sender = origAddTrack.apply(this, arguments);\n        if (!sender) {\n          sender = shimSenderWithDtmf(this, track);\n          this._senders.push(sender);\n        }\n        return sender;\n      };\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        origRemoveTrack.apply(this, arguments);\n        const idx = this._senders.indexOf(sender);\n        if (idx !== -1) {\n          this._senders.splice(idx, 1);\n        }\n      };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      this._senders = this._senders || [];\n      origRemoveStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        const sender = this._senders.find(s => s.track === track);\n        if (sender) {\n          // remove sender\n          this._senders.splice(this._senders.indexOf(sender), 1);\n        }\n      });\n    };\n  } else if (typeof window === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\nexport function shimGetStats(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n\n    // If selector is a function then we are in the old style stats so just\n    // pass back the original getStats format to avoid breaking old users.\n    if (arguments.length > 0 && typeof selector === 'function') {\n      return origGetStats.apply(this, arguments);\n    }\n\n    // When spec-style getStats is supported, return those when called with\n    // either no arguments or the selector argument is null.\n    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {\n      return origGetStats.apply(this, []);\n    }\n    const fixChromeStats_ = function (response) {\n      const standardReport = {};\n      const reports = response.result();\n      reports.forEach(report => {\n        const standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: 'local-candidate',\n            remotecandidate: 'remote-candidate'\n          }[report.type] || report.type\n        };\n        report.names().forEach(name => {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n      return standardReport;\n    };\n\n    // shim getStats with maplike support\n    const makeMapStats = function (stats) {\n      return new Map(Object.keys(stats).map(key => [key, stats[key]]));\n    };\n    if (arguments.length >= 2) {\n      const successCallbackWrapper_ = function (response) {\n        onSucc(makeMapStats(fixChromeStats_(response)));\n      };\n      return origGetStats.apply(this, [successCallbackWrapper_, selector]);\n    }\n\n    // promise-support\n    return new Promise((resolve, reject) => {\n      origGetStats.apply(this, [function (response) {\n        resolve(makeMapStats(fixChromeStats_(response)));\n      }, reject]);\n    }).then(onSucc, onErr);\n  };\n}\nexport function shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n      /* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */\n      utils.filterStats(result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n        const receivers = origGetReceivers.apply(this, []);\n        receivers.forEach(receiver => receiver._pc = this);\n        return receivers;\n      };\n    }\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result => utils.filterStats(result, receiver.track, false));\n    };\n  }\n  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || sender && receiver) {\n        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\nexport function shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    return Object.keys(this._shimmedLocalStreams).map(streamId => this._shimmedLocalStreams[streamId][0]);\n  };\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (!stream) {\n      return origAddTrack.apply(this, arguments);\n    }\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    const sender = origAddTrack.apply(this, arguments);\n    if (!this._shimmedLocalStreams[stream.id]) {\n      this._shimmedLocalStreams[stream.id] = [stream, sender];\n    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n      this._shimmedLocalStreams[stream.id].push(sender);\n    }\n    return sender;\n  };\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders().filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    delete this._shimmedLocalStreams[stream.id];\n    return origRemoveStream.apply(this, arguments);\n  };\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    if (sender) {\n      Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n        if (idx !== -1) {\n          this._shimmedLocalStreams[streamId].splice(idx, 1);\n        }\n        if (this._shimmedLocalStreams[streamId].length === 1) {\n          delete this._shimmedLocalStreams[streamId];\n        }\n      });\n    }\n    return origRemoveTrack.apply(this, arguments);\n  };\n}\nexport function shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    const nativeStreams = origGetLocalStreams.apply(this);\n    this._reverseStreams = this._reverseStreams || {};\n    return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n  };\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);\n    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n    delete this._streams[stream.id];\n  };\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    }\n    const streams = [].slice.call(arguments, 1);\n    if (streams.length !== 1 || !streams[0].getTracks().find(t => t === track)) {\n      // this is not fully correct but all we can manage without\n      // [[associated MediaStreams]] internal slot.\n      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');\n    }\n    const alreadyExists = this.getSenders().find(s => s.track === track);\n    if (alreadyExists) {\n      throw new DOMException('Track already exists.', 'InvalidAccessError');\n    }\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    const oldStream = this._streams[stream.id];\n    if (oldStream) {\n      // this is using odd Chrome behaviour, use with caution:\n      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n      // Note: we rely on the high-level addTrack/dtmf shim to\n      // create the sender with a dtmf sender.\n      oldStream.addTrack(track);\n\n      // Trigger ONN async.\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new Event('negotiationneeded'));\n      });\n    } else {\n      const newStream = new window.MediaStream([track]);\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      this.addStream(newStream);\n    }\n    return this.getSenders().find(s => s.track === track);\n  };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function (method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {\n      [method]() {\n        const args = arguments;\n        const isLegacyCall = arguments.length && typeof arguments[0] === 'function';\n        if (isLegacyCall) {\n          return nativeMethod.apply(this, [description => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          }, err => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]]);\n        }\n        return nativeMethod.apply(this, arguments).then(description => replaceInternalStreamId(this, description));\n      }\n    };\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n  const origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    if (!arguments.length || !arguments[0].type) {\n      return origSetLocalDescription.apply(this, arguments);\n    }\n    arguments[0] = replaceExternalStreamId(this, arguments[0]);\n    return origSetLocalDescription.apply(this, arguments);\n  };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {\n    get() {\n      const description = origLocalDescription.get.apply(this);\n      if (description.type === '') {\n        return description;\n      }\n      return replaceInternalStreamId(this, description);\n    }\n  });\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    }\n    // We can not yet check for sender instanceof RTCRtpSender\n    // since we shim RTPSender. So we check if sender._pc is set.\n    if (!sender._pc) {\n      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');\n    }\n    const isLocal = sender._pc === this;\n    if (!isLocal) {\n      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');\n    }\n\n    // Search for the native stream the senders track belongs to.\n    this._streams = this._streams || {};\n    let stream;\n    Object.keys(this._streams).forEach(streamid => {\n      const hasTrack = this._streams[streamid].getTracks().find(track => sender.track === track);\n      if (hasTrack) {\n        stream = this._streams[streamid];\n      }\n    });\n    if (stream) {\n      if (stream.getTracks().length === 1) {\n        // if this is the last track of the stream, remove the stream. This\n        // takes care of any shimmed _senders.\n        this.removeStream(this._reverseStreams[stream.id]);\n      } else {\n        // relying on the same odd chrome behaviour as above.\n        stream.removeTrack(sender.track);\n      }\n      this.dispatchEvent(new Event('negotiationneeded'));\n    }\n  };\n}\nexport function shimPeerConnection(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n      };\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n}\n\n// Attempt to fix ONN in plan-b mode.\nexport function fixNegotiationNeeded(window, browserDetails) {\n  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n    return e;\n  });\n}","map":{"version":3,"names":["utils","shimGetUserMedia","shimGetDisplayMedia","shimMediaStream","window","MediaStream","webkitMediaStream","shimOnTrack","RTCPeerConnection","prototype","Object","defineProperty","get","_ontrack","set","f","removeEventListener","addEventListener","enumerable","configurable","origSetRemoteDescription","setRemoteDescription","_ontrackpoly","e","stream","te","receiver","getReceivers","find","r","track","id","event","Event","transceiver","streams","dispatchEvent","getTracks","forEach","apply","arguments","wrapPeerConnectionEvent","value","shimGetSendersWithDtmf","shimSenderWithDtmf","pc","dtmf","_dtmf","undefined","kind","createDTMFSender","_pc","getSenders","_senders","slice","origAddTrack","addTrack","sender","push","origRemoveTrack","removeTrack","idx","indexOf","splice","origAddStream","addStream","origRemoveStream","removeStream","s","RTCRtpSender","origGetSenders","senders","shimGetStats","origGetStats","getStats","selector","onSucc","onErr","length","fixChromeStats_","response","standardReport","reports","result","report","standardStats","timestamp","type","localcandidate","remotecandidate","names","name","stat","makeMapStats","stats","Map","keys","map","key","successCallbackWrapper_","Promise","resolve","reject","then","shimSenderReceiverGetStats","RTCRtpReceiver","filterStats","origGetReceivers","receivers","srcElement","MediaStreamTrack","err","DOMException","shimAddTrackRemoveTrackWithNative","getLocalStreams","_shimmedLocalStreams","streamId","alreadyExists","existingSenders","newSenders","filter","newSender","concat","shimAddTrackRemoveTrack","browserDetails","version","origGetLocalStreams","nativeStreams","_reverseStreams","_streams","newStream","signalingState","call","t","oldStream","replaceInternalStreamId","description","sdp","internalId","externalStream","internalStream","replace","RegExp","RTCSessionDescription","replaceExternalStreamId","method","nativeMethod","methodObj","args","isLegacyCall","desc","origSetLocalDescription","setLocalDescription","origLocalDescription","getOwnPropertyDescriptor","isLocal","streamid","hasTrack","shimPeerConnection","webkitRTCPeerConnection","RTCIceCandidate","fixNegotiationNeeded","target","getConfiguration","sdpSemantics"],"sources":["C:/Users/DAVOTRADE/Desktop/Rezy Acme Company/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js"],"sourcesContent":["/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\nimport * as utils from '../utils.js';\n\nexport {shimGetUserMedia} from './getusermedia';\nexport {shimGetDisplayMedia} from './getdisplaymedia';\n\nexport function shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\n\nexport function shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n      window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription =\n        window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription =\n      function setRemoteDescription() {\n        if (!this._ontrackpoly) {\n          this._ontrackpoly = (e) => {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', te => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === te.track.id);\n              } else {\n                receiver = {track: te.track};\n              }\n\n              const event = new Event('track');\n              event.track = te.track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(track => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === track.id);\n              } else {\n                receiver = {track};\n              }\n              const event = new Event('track');\n              event.track = track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n          };\n          this.addEventListener('addstream', this._ontrackpoly);\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n      };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver',\n          {value: {receiver: e.receiver}});\n      }\n      return e;\n    });\n  }\n}\n\nexport function shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection &&\n      !('getSenders' in window.RTCPeerConnection.prototype) &&\n      'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function(pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack =\n        function addTrack(track, stream) {\n          let sender = origAddTrack.apply(this, arguments);\n          if (!sender) {\n            sender = shimSenderWithDtmf(this, track);\n            this._senders.push(sender);\n          }\n          return sender;\n        };\n\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack =\n        function removeTrack(sender) {\n          origRemoveTrack.apply(this, arguments);\n          const idx = this._senders.indexOf(sender);\n          if (idx !== -1) {\n            this._senders.splice(idx, 1);\n          }\n        };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream =\n      function removeStream(stream) {\n        this._senders = this._senders || [];\n        origRemoveStream.apply(this, [stream]);\n\n        stream.getTracks().forEach(track => {\n          const sender = this._senders.find(s => s.track === track);\n          if (sender) { // remove sender\n            this._senders.splice(this._senders.indexOf(sender), 1);\n          }\n        });\n      };\n  } else if (typeof window === 'object' && window.RTCPeerConnection &&\n             'getSenders' in window.RTCPeerConnection.prototype &&\n             'createDTMFSender' in window.RTCPeerConnection.prototype &&\n             window.RTCRtpSender &&\n             !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\n\nexport function shimGetStats(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n\n    // If selector is a function then we are in the old style stats so just\n    // pass back the original getStats format to avoid breaking old users.\n    if (arguments.length > 0 && typeof selector === 'function') {\n      return origGetStats.apply(this, arguments);\n    }\n\n    // When spec-style getStats is supported, return those when called with\n    // either no arguments or the selector argument is null.\n    if (origGetStats.length === 0 && (arguments.length === 0 ||\n        typeof selector !== 'function')) {\n      return origGetStats.apply(this, []);\n    }\n\n    const fixChromeStats_ = function(response) {\n      const standardReport = {};\n      const reports = response.result();\n      reports.forEach(report => {\n        const standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: 'local-candidate',\n            remotecandidate: 'remote-candidate'\n          }[report.type] || report.type\n        };\n        report.names().forEach(name => {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n\n      return standardReport;\n    };\n\n    // shim getStats with maplike support\n    const makeMapStats = function(stats) {\n      return new Map(Object.keys(stats).map(key => [key, stats[key]]));\n    };\n\n    if (arguments.length >= 2) {\n      const successCallbackWrapper_ = function(response) {\n        onSucc(makeMapStats(fixChromeStats_(response)));\n      };\n\n      return origGetStats.apply(this, [successCallbackWrapper_,\n        selector]);\n    }\n\n    // promise-support\n    return new Promise((resolve, reject) => {\n      origGetStats.apply(this, [\n        function(response) {\n          resolve(makeMapStats(fixChromeStats_(response)));\n        }, reject]);\n    }).then(onSucc, onErr);\n  };\n}\n\nexport function shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n        /* Note: this will include stats of all senders that\n         *   send a track with the same id as sender.track as\n         *   it is not possible to identify the RTCRtpSender.\n         */\n        utils.filterStats(result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers =\n        function getReceivers() {\n          const receivers = origGetReceivers.apply(this, []);\n          receivers.forEach(receiver => receiver._pc = this);\n          return receivers;\n        };\n    }\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result =>\n        utils.filterStats(result, receiver.track, false));\n    };\n  }\n\n  if (!('getStats' in window.RTCRtpSender.prototype &&\n      'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 &&\n        arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || (sender && receiver)) {\n        return Promise.reject(new DOMException(\n          'There are more than one sender or receiver for the track.',\n          'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException(\n        'There is no sender or receiver for the track.',\n        'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\n\nexport function shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      return Object.keys(this._shimmedLocalStreams)\n        .map(streamId => this._shimmedLocalStreams[streamId][0]);\n    };\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (!stream) {\n        return origAddTrack.apply(this, arguments);\n      }\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      const sender = origAddTrack.apply(this, arguments);\n      if (!this._shimmedLocalStreams[stream.id]) {\n        this._shimmedLocalStreams[stream.id] = [stream, sender];\n      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n        this._shimmedLocalStreams[stream.id].push(sender);\n      }\n      return sender;\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders()\n      .filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      delete this._shimmedLocalStreams[stream.id];\n      return origRemoveStream.apply(this, arguments);\n    };\n\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      if (sender) {\n        Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n          if (idx !== -1) {\n            this._shimmedLocalStreams[streamId].splice(idx, 1);\n          }\n          if (this._shimmedLocalStreams[streamId].length === 1) {\n            delete this._shimmedLocalStreams[streamId];\n          }\n        });\n      }\n      return origRemoveTrack.apply(this, arguments);\n    };\n}\n\nexport function shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack &&\n      browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype\n      .getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      const nativeStreams = origGetLocalStreams.apply(this);\n      this._reverseStreams = this._reverseStreams || {};\n      return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n\n      origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);\n      delete this._reverseStreams[(this._streams[stream.id] ?\n          this._streams[stream.id].id : stream.id)];\n      delete this._streams[stream.id];\n    };\n\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      const streams = [].slice.call(arguments, 1);\n      if (streams.length !== 1 ||\n          !streams[0].getTracks().find(t => t === track)) {\n        // this is not fully correct but all we can manage without\n        // [[associated MediaStreams]] internal slot.\n        throw new DOMException(\n          'The adapter.js addTrack polyfill only supports a single ' +\n          ' stream which is associated with the specified track.',\n          'NotSupportedError');\n      }\n\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n      const oldStream = this._streams[stream.id];\n      if (oldStream) {\n        // this is using odd Chrome behaviour, use with caution:\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n        // Note: we rely on the high-level addTrack/dtmf shim to\n        // create the sender with a dtmf sender.\n        oldStream.addTrack(track);\n\n        // Trigger ONN async.\n        Promise.resolve().then(() => {\n          this.dispatchEvent(new Event('negotiationneeded'));\n        });\n      } else {\n        const newStream = new window.MediaStream([track]);\n        this._streams[stream.id] = newStream;\n        this._reverseStreams[newStream.id] = stream;\n        this.addStream(newStream);\n      }\n      return this.getSenders().find(s => s.track === track);\n    };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\n          externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\n          internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function(method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {[method]() {\n      const args = arguments;\n      const isLegacyCall = arguments.length &&\n          typeof arguments[0] === 'function';\n      if (isLegacyCall) {\n        return nativeMethod.apply(this, [\n          (description) => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          },\n          (err) => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]\n        ]);\n      }\n      return nativeMethod.apply(this, arguments)\n      .then(description => replaceInternalStreamId(this, description));\n    }};\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n\n  const origSetLocalDescription =\n      window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription =\n    function setLocalDescription() {\n      if (!arguments.length || !arguments[0].type) {\n        return origSetLocalDescription.apply(this, arguments);\n      }\n      arguments[0] = replaceExternalStreamId(this, arguments[0]);\n      return origSetLocalDescription.apply(this, arguments);\n    };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(\n      window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype,\n      'localDescription', {\n        get() {\n          const description = origLocalDescription.get.apply(this);\n          if (description.type === '') {\n            return description;\n          }\n          return replaceInternalStreamId(this, description);\n        }\n      });\n\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      // We can not yet check for sender instanceof RTCRtpSender\n      // since we shim RTPSender. So we check if sender._pc is set.\n      if (!sender._pc) {\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\n            'does not implement interface RTCRtpSender.', 'TypeError');\n      }\n      const isLocal = sender._pc === this;\n      if (!isLocal) {\n        throw new DOMException('Sender was not created by this connection.',\n            'InvalidAccessError');\n      }\n\n      // Search for the native stream the senders track belongs to.\n      this._streams = this._streams || {};\n      let stream;\n      Object.keys(this._streams).forEach(streamid => {\n        const hasTrack = this._streams[streamid].getTracks()\n          .find(track => sender.track === track);\n        if (hasTrack) {\n          stream = this._streams[streamid];\n        }\n      });\n\n      if (stream) {\n        if (stream.getTracks().length === 1) {\n          // if this is the last track of the stream, remove the stream. This\n          // takes care of any shimmed _senders.\n          this.removeStream(this._reverseStreams[stream.id]);\n        } else {\n          // relying on the same odd chrome behaviour as above.\n          stream.removeTrack(sender.track);\n        }\n        this.dispatchEvent(new Event('negotiationneeded'));\n      }\n    };\n}\n\nexport function shimPeerConnection(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          const nativeMethod = window.RTCPeerConnection.prototype[method];\n          const methodObj = {[method]() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          }};\n          window.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n  }\n}\n\n// Attempt to fix ONN in plan-b mode.\nexport function fixNegotiationNeeded(window, browserDetails) {\n  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (browserDetails.version < 72 || (pc.getConfiguration &&\n        pc.getConfiguration().sdpSemantics === 'plan-b')) {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n    return e;\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}