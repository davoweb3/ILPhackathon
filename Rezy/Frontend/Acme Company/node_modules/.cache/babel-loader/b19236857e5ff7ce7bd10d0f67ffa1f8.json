{"ast":null,"code":"\"use strict\";\n\n/*\n* Copyright 2013 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n    i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.ChecksumException;\nvar ChecksumException_1 = require(\"../../ChecksumException\");\n// import com.google.zxing.FormatException;\nvar FormatException_1 = require(\"../../FormatException\");\n// import com.google.zxing.NotFoundException;\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n// import com.google.zxing.common.detector.MathUtils;\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\");\n// import com.google.zxing.pdf417.PDF417Common;\nvar PDF417Common_1 = require(\"../PDF417Common\");\n// import com.google.zxing.pdf417.decoder.ec.ErrorCorrection;\nvar ErrorCorrection_1 = require(\"./ec/ErrorCorrection\");\n// local\nvar BoundingBox_1 = require(\"./BoundingBox\");\nvar DetectionResultRowIndicatorColumn_1 = require(\"./DetectionResultRowIndicatorColumn\");\nvar DetectionResult_1 = require(\"./DetectionResult\");\nvar DetectionResultColumn_1 = require(\"./DetectionResultColumn\");\nvar Codeword_1 = require(\"./Codeword\");\nvar BarcodeValue_1 = require(\"./BarcodeValue\");\nvar PDF417CodewordDecoder_1 = require(\"./PDF417CodewordDecoder\");\nvar DecodedBitStreamParser_1 = require(\"./DecodedBitStreamParser\");\n// utils\nvar Formatter_1 = require(\"../../util/Formatter\");\n// import java.util.ArrayList;\n// import java.util.Collection;\n// import java.util.Formatter;\n// import java.util.List;\n/**\n * @author Guenther Grau\n */\nvar PDF417ScanningDecoder = /** @class */function () {\n  function PDF417ScanningDecoder() {}\n  /**\n   * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern\n   *\n   * columns. That way width can be deducted from the pattern column.\n   * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider\n   * than it should be. This can happen if the scanner used a bad blackpoint.\n   *\n   * @param BitMatrix\n   * @param image\n   * @param ResultPoint\n   * @param imageTopLeft\n   * @param ResultPoint\n   * @param imageBottomLeft\n   * @param ResultPoint\n   * @param imageTopRight\n   * @param ResultPoint\n   * @param imageBottomRight\n   * @param int\n   * @param minCodewordWidth\n   * @param int\n   * @param maxCodewordWidth\n   *\n   * @throws NotFoundException\n   * @throws FormatException\n   * @throws ChecksumException\n   */\n  PDF417ScanningDecoder.decode = function (image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {\n    var boundingBox = new BoundingBox_1.default(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);\n    var leftRowIndicatorColumn = null;\n    var rightRowIndicatorColumn = null;\n    var detectionResult;\n    for (var firstPass /*boolean*/ = true;; firstPass = false) {\n      if (imageTopLeft != null) {\n        leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);\n      }\n      if (imageTopRight != null) {\n        rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);\n      }\n      detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);\n      if (detectionResult == null) {\n        throw NotFoundException_1.default.getNotFoundInstance();\n      }\n      var resultBox = detectionResult.getBoundingBox();\n      if (firstPass && resultBox != null && (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {\n        boundingBox = resultBox;\n      } else {\n        break;\n      }\n    }\n    detectionResult.setBoundingBox(boundingBox);\n    var maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;\n    detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);\n    detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);\n    var leftToRight = leftRowIndicatorColumn != null;\n    for (var barcodeColumnCount /*int*/ = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {\n      var barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;\n      if (detectionResult.getDetectionResultColumn(barcodeColumn) !== /* null */undefined) {\n        // This will be the case for the opposite row indicator column, which doesn't need to be decoded again.\n        continue;\n      }\n      var detectionResultColumn = void 0;\n      if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {\n        detectionResultColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, barcodeColumn === 0);\n      } else {\n        detectionResultColumn = new DetectionResultColumn_1.default(boundingBox);\n      }\n      detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);\n      var startColumn = -1;\n      var previousStartColumn = startColumn;\n      // TODO start at a row for which we know the start position, then detect upwards and downwards from there.\n      for (var imageRow /*int*/ = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {\n        startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);\n        if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {\n          if (previousStartColumn === -1) {\n            continue;\n          }\n          startColumn = previousStartColumn;\n        }\n        var codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n        if (codeword != null) {\n          detectionResultColumn.setCodeword(imageRow, codeword);\n          previousStartColumn = startColumn;\n          minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());\n          maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());\n        }\n      }\n    }\n    return PDF417ScanningDecoder.createDecoderResult(detectionResult);\n  };\n  /**\n   *\n   * @param leftRowIndicatorColumn\n   * @param rightRowIndicatorColumn\n   *\n   * @throws NotFoundException\n   */\n  PDF417ScanningDecoder.merge = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {\n    if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {\n      return null;\n    }\n    var barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);\n    if (barcodeMetadata == null) {\n      return null;\n    }\n    var boundingBox = BoundingBox_1.default.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));\n    return new DetectionResult_1.default(barcodeMetadata, boundingBox);\n  };\n  /**\n   *\n   * @param rowIndicatorColumn\n   *\n   * @throws NotFoundException\n   */\n  PDF417ScanningDecoder.adjustBoundingBox = function (rowIndicatorColumn) {\n    var e_1, _a;\n    if (rowIndicatorColumn == null) {\n      return null;\n    }\n    var rowHeights = rowIndicatorColumn.getRowHeights();\n    if (rowHeights == null) {\n      return null;\n    }\n    var maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);\n    var missingStartRows = 0;\n    try {\n      for (var rowHeights_1 = __values(rowHeights), rowHeights_1_1 = rowHeights_1.next(); !rowHeights_1_1.done; rowHeights_1_1 = rowHeights_1.next()) {\n        var rowHeight = rowHeights_1_1.value /*int*/;\n        missingStartRows += maxRowHeight - rowHeight;\n        if (rowHeight > 0) {\n          break;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (rowHeights_1_1 && !rowHeights_1_1.done && (_a = rowHeights_1.return)) _a.call(rowHeights_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    var codewords = rowIndicatorColumn.getCodewords();\n    for (var row /*int*/ = 0; missingStartRows > 0 && codewords[row] == null; row++) {\n      missingStartRows--;\n    }\n    var missingEndRows = 0;\n    for (var row /*int*/ = rowHeights.length - 1; row >= 0; row--) {\n      missingEndRows += maxRowHeight - rowHeights[row];\n      if (rowHeights[row] > 0) {\n        break;\n      }\n    }\n    for (var row /*int*/ = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {\n      missingEndRows--;\n    }\n    return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());\n  };\n  PDF417ScanningDecoder.getMax = function (values) {\n    var e_2, _a;\n    var maxValue = -1;\n    try {\n      for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {\n        var value = values_1_1.value /*int*/;\n        maxValue = Math.max(maxValue, value);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return maxValue;\n  };\n  PDF417ScanningDecoder.getBarcodeMetadata = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {\n    var leftBarcodeMetadata;\n    if (leftRowIndicatorColumn == null || (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {\n      return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();\n    }\n    var rightBarcodeMetadata;\n    if (rightRowIndicatorColumn == null || (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {\n      return leftBarcodeMetadata;\n    }\n    if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() && leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() && leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {\n      return null;\n    }\n    return leftBarcodeMetadata;\n  };\n  PDF417ScanningDecoder.getRowIndicatorColumn = function (image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {\n    var rowIndicatorColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, leftToRight);\n    for (var i /*int*/ = 0; i < 2; i++) {\n      var increment = i === 0 ? 1 : -1;\n      var startColumn = Math.trunc(Math.trunc(startPoint.getX()));\n      for (var imageRow /*int*/ = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() && imageRow >= boundingBox.getMinY(); imageRow += increment) {\n        var codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n        if (codeword != null) {\n          rowIndicatorColumn.setCodeword(imageRow, codeword);\n          if (leftToRight) {\n            startColumn = codeword.getStartX();\n          } else {\n            startColumn = codeword.getEndX();\n          }\n        }\n      }\n    }\n    return rowIndicatorColumn;\n  };\n  /**\n   *\n   * @param detectionResult\n   * @param BarcodeValue\n   * @param param2\n   * @param param3\n   * @param barcodeMatrix\n   *\n   * @throws NotFoundException\n   */\n  PDF417ScanningDecoder.adjustCodewordCount = function (detectionResult, barcodeMatrix) {\n    var barcodeMatrix01 = barcodeMatrix[0][1];\n    var numberOfCodewords = barcodeMatrix01.getValue();\n    var calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() * detectionResult.getBarcodeRowCount() - PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());\n    if (numberOfCodewords.length === 0) {\n      if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common_1.default.MAX_CODEWORDS_IN_BARCODE) {\n        throw NotFoundException_1.default.getNotFoundInstance();\n      }\n      barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n    } else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {\n      // The calculated one is more reliable as it is derived from the row indicator columns\n      barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n    }\n  };\n  /**\n   *\n   * @param detectionResult\n   *\n   * @throws FormatException\n   * @throws ChecksumException\n   * @throws NotFoundException\n   */\n  PDF417ScanningDecoder.createDecoderResult = function (detectionResult) {\n    var barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);\n    PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);\n    var erasures /*Collection<Integer>*/ = new Array();\n    var codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());\n    var ambiguousIndexValuesList = /*List<int[]>*/[];\n    var ambiguousIndexesList = /*Collection<Integer>*/new Array();\n    for (var row /*int*/ = 0; row < detectionResult.getBarcodeRowCount(); row++) {\n      for (var column /*int*/ = 0; column < detectionResult.getBarcodeColumnCount(); column++) {\n        var values = barcodeMatrix[row][column + 1].getValue();\n        var codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;\n        if (values.length === 0) {\n          erasures.push(codewordIndex);\n        } else if (values.length === 1) {\n          codewords[codewordIndex] = values[0];\n        } else {\n          ambiguousIndexesList.push(codewordIndex);\n          ambiguousIndexValuesList.push(values);\n        }\n      }\n    }\n    var ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);\n    for (var i /*int*/ = 0; i < ambiguousIndexValues.length; i++) {\n      ambiguousIndexValues[i] = ambiguousIndexValuesList[i];\n    }\n    return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common_1.default.toIntArray(erasures), PDF417Common_1.default.toIntArray(ambiguousIndexesList), ambiguousIndexValues);\n  };\n  /**\n   * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The\n   * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value\n   * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of\n   * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the\n   * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,\n   * so decoding the normal barcodes is not affected by this.\n   *\n   * @param erasureArray contains the indexes of erasures\n   * @param ambiguousIndexes array with the indexes that have more than one most likely value\n   * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must\n   * be the same length as the ambiguousIndexes array\n   *\n   * @throws FormatException\n   * @throws ChecksumException\n   */\n  PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues = function (ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {\n    var ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);\n    var tries = 100;\n    while (tries-- > 0) {\n      for (var i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {\n        codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];\n      }\n      try {\n        return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);\n      } catch (err) {\n        var ignored = err instanceof ChecksumException_1.default;\n        if (!ignored) {\n          throw err;\n        }\n      }\n      if (ambiguousIndexCount.length === 0) {\n        throw ChecksumException_1.default.getChecksumInstance();\n      }\n      for (var i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {\n        if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {\n          ambiguousIndexCount[i]++;\n          break;\n        } else {\n          ambiguousIndexCount[i] = 0;\n          if (i === ambiguousIndexCount.length - 1) {\n            throw ChecksumException_1.default.getChecksumInstance();\n          }\n        }\n      }\n    }\n    throw ChecksumException_1.default.getChecksumInstance();\n  };\n  PDF417ScanningDecoder.createBarcodeMatrix = function (detectionResult) {\n    var e_3, _a, e_4, _b;\n    // let barcodeMatrix: BarcodeValue[][] =\n    // new BarcodeValue[detectionResult.getBarcodeRowCount()][detectionResult.getBarcodeColumnCount() + 2];\n    var barcodeMatrix = Array.from({\n      length: detectionResult.getBarcodeRowCount()\n    }, function () {\n      return new Array(detectionResult.getBarcodeColumnCount() + 2);\n    });\n    for (var row /*int*/ = 0; row < barcodeMatrix.length; row++) {\n      for (var column_1 /*int*/ = 0; column_1 < barcodeMatrix[row].length; column_1++) {\n        barcodeMatrix[row][column_1] = new BarcodeValue_1.default();\n      }\n    }\n    var column = 0;\n    try {\n      for (var _c = __values(detectionResult.getDetectionResultColumns()), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var detectionResultColumn = _d.value /*DetectionResultColumn*/;\n        if (detectionResultColumn != null) {\n          try {\n            for (var _e = __values(detectionResultColumn.getCodewords()), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var codeword = _f.value /*Codeword*/;\n              if (codeword != null) {\n                var rowNumber = codeword.getRowNumber();\n                if (rowNumber >= 0) {\n                  if (rowNumber >= barcodeMatrix.length) {\n                    // We have more rows than the barcode metadata allows for, ignore them.\n                    continue;\n                  }\n                  barcodeMatrix[rowNumber][column].setValue(codeword.getValue());\n                }\n              }\n            }\n          } catch (e_4_1) {\n            e_4 = {\n              error: e_4_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_4) throw e_4.error;\n            }\n          }\n        }\n        column++;\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    return barcodeMatrix;\n  };\n  PDF417ScanningDecoder.isValidBarcodeColumn = function (detectionResult, barcodeColumn) {\n    return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;\n  };\n  PDF417ScanningDecoder.getStartColumn = function (detectionResult, barcodeColumn, imageRow, leftToRight) {\n    var e_5, _a;\n    var offset = leftToRight ? 1 : -1;\n    var codeword = null;\n    if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n      codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);\n    }\n    if (codeword != null) {\n      return leftToRight ? codeword.getEndX() : codeword.getStartX();\n    }\n    codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);\n    if (codeword != null) {\n      return leftToRight ? codeword.getStartX() : codeword.getEndX();\n    }\n    if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n      codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);\n    }\n    if (codeword != null) {\n      return leftToRight ? codeword.getEndX() : codeword.getStartX();\n    }\n    var skippedColumns = 0;\n    while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n      barcodeColumn -= offset;\n      try {\n        for (var _b = __values(detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var previousRowCodeword = _c.value /*Codeword*/;\n          if (previousRowCodeword != null) {\n            return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) + offset * skippedColumns * (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());\n          }\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n      skippedColumns++;\n    }\n    return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();\n  };\n  PDF417ScanningDecoder.detectCodeword = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {\n    startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n    // we usually know fairly exact now how long a codeword is. We should provide minimum and maximum expected length\n    // and try to adjust the read pixels, e.g. remove single pixel errors or try to cut off exceeding pixels.\n    // min and maxCodewordWidth should not be used as they are calculated for the whole barcode an can be inaccurate\n    // for the current position\n    var moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n    if (moduleBitCount == null) {\n      return null;\n    }\n    var endColumn;\n    var codewordBitCount = MathUtils_1.default.sum(moduleBitCount);\n    if (leftToRight) {\n      endColumn = startColumn + codewordBitCount;\n    } else {\n      for (var i /*int*/ = 0; i < moduleBitCount.length / 2; i++) {\n        var tmpCount = moduleBitCount[i];\n        moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];\n        moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;\n      }\n      endColumn = startColumn;\n      startColumn = endColumn - codewordBitCount;\n    }\n    // TODO implement check for width and correction of black and white bars\n    // use start (and maybe stop pattern) to determine if black bars are wider than white bars. If so, adjust.\n    // should probably done only for codewords with a lot more than 17 bits.\n    // The following fixes 10-1.png, which has wide black bars and small white bars\n    //    for (let i /*int*/ = 0; i < moduleBitCount.length; i++) {\n    //      if (i % 2 === 0) {\n    //        moduleBitCount[i]--;\n    //      } else {\n    //        moduleBitCount[i]++;\n    //      }\n    //    }\n    // We could also use the width of surrounding codewords for more accurate results, but this seems\n    // sufficient for now\n    if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {\n      // We could try to use the startX and endX position of the codeword in the same column in the previous row,\n      // create the bit count from it and normalize it to 8. This would help with single pixel errors.\n      return null;\n    }\n    var decodedValue = PDF417CodewordDecoder_1.default.getDecodedValue(moduleBitCount);\n    var codeword = PDF417Common_1.default.getCodeword(decodedValue);\n    if (codeword === -1) {\n      return null;\n    }\n    return new Codeword_1.default(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);\n  };\n  PDF417ScanningDecoder.getModuleBitCount = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {\n    var imageColumn = startColumn;\n    var moduleBitCount = new Int32Array(8);\n    var moduleNumber = 0;\n    var increment = leftToRight ? 1 : -1;\n    var previousPixelValue = leftToRight;\n    while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) && moduleNumber < moduleBitCount.length) {\n      if (image.get(imageColumn, imageRow) === previousPixelValue) {\n        moduleBitCount[moduleNumber]++;\n        imageColumn += increment;\n      } else {\n        moduleNumber++;\n        previousPixelValue = !previousPixelValue;\n      }\n    }\n    if (moduleNumber === moduleBitCount.length || imageColumn === (leftToRight ? maxColumn : minColumn) && moduleNumber === moduleBitCount.length - 1) {\n      return moduleBitCount;\n    }\n    return null;\n  };\n  PDF417ScanningDecoder.getNumberOfECCodeWords = function (barcodeECLevel) {\n    return 2 << barcodeECLevel;\n  };\n  PDF417ScanningDecoder.adjustCodewordStartColumn = function (image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {\n    var correctedStartColumn = codewordStartColumn;\n    var increment = leftToRight ? -1 : 1;\n    // there should be no black pixels before the start column. If there are, then we need to start earlier.\n    for (var i /*int*/ = 0; i < 2; i++) {\n      while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) && leftToRight === image.get(correctedStartColumn, imageRow)) {\n        if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {\n          return codewordStartColumn;\n        }\n        correctedStartColumn += increment;\n      }\n      increment = -increment;\n      leftToRight = !leftToRight;\n    }\n    return correctedStartColumn;\n  };\n  PDF417ScanningDecoder.checkCodewordSkew = function (codewordSize, minCodewordWidth, maxCodewordWidth) {\n    return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize && codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;\n  };\n  /**\n   * @throws FormatException,\n   * @throws ChecksumException\n   */\n  PDF417ScanningDecoder.decodeCodewords = function (codewords, ecLevel, erasures) {\n    if (codewords.length === 0) {\n      throw FormatException_1.default.getFormatInstance();\n    }\n    var numECCodewords = 1 << ecLevel + 1;\n    var correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);\n    PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);\n    // Decode the codewords\n    var decoderResult = DecodedBitStreamParser_1.default.decode(codewords, '' + ecLevel);\n    decoderResult.setErrorsCorrected(correctedErrorsCount);\n    decoderResult.setErasures(erasures.length);\n    return decoderResult;\n  };\n  /**\n   * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n   * correct the errors in-place.</p>\n   *\n   * @param codewords   data and error correction codewords\n   * @param erasures positions of any known erasures\n   * @param numECCodewords number of error correction codewords that are available in codewords\n   * @throws ChecksumException if error correction fails\n   */\n  PDF417ScanningDecoder.correctErrors = function (codewords, erasures, numECCodewords) {\n    if (erasures != null && erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS || numECCodewords < 0 || numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {\n      // Too many errors or EC Codewords is corrupted\n      throw ChecksumException_1.default.getChecksumInstance();\n    }\n    return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);\n  };\n  /**\n   * Verify that all is OK with the codeword array.\n   * @throws FormatException\n   */\n  PDF417ScanningDecoder.verifyCodewordCount = function (codewords, numECCodewords) {\n    if (codewords.length < 4) {\n      // Codeword array size should be at least 4 allowing for\n      // Count CW, At least one Data CW, Error Correction CW, Error Correction CW\n      throw FormatException_1.default.getFormatInstance();\n    }\n    // The first codeword, the Symbol Length Descriptor, shall always encode the total number of data\n    // codewords in the symbol, including the Symbol Length Descriptor itself, data codewords and pad\n    // codewords, but excluding the number of error correction codewords.\n    var numberOfCodewords = codewords[0];\n    if (numberOfCodewords > codewords.length) {\n      throw FormatException_1.default.getFormatInstance();\n    }\n    if (numberOfCodewords === 0) {\n      // Reset to the length of the array - 8 (Allow for at least level 3 Error Correction (8 Error Codewords)\n      if (numECCodewords < codewords.length) {\n        codewords[0] = codewords.length - numECCodewords;\n      } else {\n        throw FormatException_1.default.getFormatInstance();\n      }\n    }\n  };\n  PDF417ScanningDecoder.getBitCountForCodeword = function (codeword) {\n    var result = new Int32Array(8);\n    var previousValue = 0;\n    var i = result.length - 1;\n    while (true) {\n      if ((codeword & 0x1) !== previousValue) {\n        previousValue = codeword & 0x1;\n        i--;\n        if (i < 0) {\n          break;\n        }\n      }\n      result[i]++;\n      codeword >>= 1;\n    }\n    return result;\n  };\n  PDF417ScanningDecoder.getCodewordBucketNumber = function (codeword) {\n    if (codeword instanceof Int32Array) {\n      return this.getCodewordBucketNumber_Int32Array(codeword);\n    }\n    return this.getCodewordBucketNumber_number(codeword);\n  };\n  PDF417ScanningDecoder.getCodewordBucketNumber_number = function (codeword) {\n    return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));\n  };\n  PDF417ScanningDecoder.getCodewordBucketNumber_Int32Array = function (moduleBitCount) {\n    return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;\n  };\n  PDF417ScanningDecoder.toString = function (barcodeMatrix) {\n    var formatter = new Formatter_1.default();\n    // try (let formatter = new Formatter()) {\n    for (var row /*int*/ = 0; row < barcodeMatrix.length; row++) {\n      formatter.format('Row %2d: ', row);\n      for (var column /*int*/ = 0; column < barcodeMatrix[row].length; column++) {\n        var barcodeValue = barcodeMatrix[row][column];\n        if (barcodeValue.getValue().length === 0) {\n          formatter.format('        ', null);\n        } else {\n          formatter.format('%4d(%2d)', barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));\n        }\n      }\n      formatter.format('%n');\n    }\n    return formatter.toString();\n    // }\n  };\n  /*final*/\n  PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;\n  /*final*/\n  PDF417ScanningDecoder.MAX_ERRORS = 3;\n  /*final*/\n  PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;\n  /*final*/\n  PDF417ScanningDecoder.errorCorrection = new ErrorCorrection_1.default();\n  return PDF417ScanningDecoder;\n}();\nexports.default = PDF417ScanningDecoder;","map":{"version":3,"names":["ChecksumException_1","require","FormatException_1","NotFoundException_1","MathUtils_1","PDF417Common_1","ErrorCorrection_1","BoundingBox_1","DetectionResultRowIndicatorColumn_1","DetectionResult_1","DetectionResultColumn_1","Codeword_1","BarcodeValue_1","PDF417CodewordDecoder_1","DecodedBitStreamParser_1","Formatter_1","PDF417ScanningDecoder","decode","image","imageTopLeft","imageBottomLeft","imageTopRight","imageBottomRight","minCodewordWidth","maxCodewordWidth","boundingBox","default","leftRowIndicatorColumn","rightRowIndicatorColumn","detectionResult","firstPass","getRowIndicatorColumn","merge","getNotFoundInstance","resultBox","getBoundingBox","getMinY","getMaxY","setBoundingBox","maxBarcodeColumn","getBarcodeColumnCount","setDetectionResultColumn","leftToRight","barcodeColumnCount","barcodeColumn","getDetectionResultColumn","undefined","detectionResultColumn","startColumn","previousStartColumn","imageRow","getStartColumn","getMaxX","codeword","detectCodeword","getMinX","setCodeword","Math","min","getWidth","max","createDecoderResult","barcodeMetadata","getBarcodeMetadata","adjustBoundingBox","rowIndicatorColumn","rowHeights","getRowHeights","maxRowHeight","getMax","missingStartRows","rowHeights_1","__values","rowHeights_1_1","next","done","rowHeight","value","codewords","getCodewords","row","missingEndRows","length","addMissingRows","isLeft","values","maxValue","values_1","values_1_1","leftBarcodeMetadata","rightBarcodeMetadata","getColumnCount","getErrorCorrectionLevel","getRowCount","startPoint","i","increment","trunc","getX","getY","getStartX","getEndX","adjustCodewordCount","barcodeMatrix","barcodeMatrix01","numberOfCodewords","getValue","calculatedNumberOfCodewords","getBarcodeRowCount","getNumberOfECCodeWords","getBarcodeECLevel","MAX_CODEWORDS_IN_BARCODE","setValue","createBarcodeMatrix","erasures","Array","Int32Array","ambiguousIndexValuesList","ambiguousIndexesList","column","codewordIndex","push","ambiguousIndexValues","createDecoderResultFromAmbiguousValues","toIntArray","ecLevel","erasureArray","ambiguousIndexes","ambiguousIndexCount","tries","decodeCodewords","err","ignored","getChecksumInstance","from","column_1","_c","getDetectionResultColumns","_d","_e","_f","rowNumber","getRowNumber","isValidBarcodeColumn","offset","getCodeword","getCodewordNearby","skippedColumns","_b","previousRowCodeword","minColumn","maxColumn","adjustCodewordStartColumn","moduleBitCount","getModuleBitCount","endColumn","codewordBitCount","sum","tmpCount","checkCodewordSkew","decodedValue","getDecodedValue","getCodewordBucketNumber","imageColumn","moduleNumber","previousPixelValue","get","barcodeECLevel","codewordStartColumn","correctedStartColumn","abs","CODEWORD_SKEW_SIZE","codewordSize","getFormatInstance","numECCodewords","correctedErrorsCount","correctErrors","verifyCodewordCount","decoderResult","setErrorsCorrected","setErasures","MAX_ERRORS","MAX_EC_CODEWORDS","errorCorrection","getBitCountForCodeword","result","previousValue","getCodewordBucketNumber_Int32Array","getCodewordBucketNumber_number","toString","formatter","format","barcodeValue","getConfidence"],"sources":["../../../../src/core/pdf417/decoder/PDF417ScanningDecoder.ts"],"sourcesContent":[null],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;AAEA;AACA,IAAAA,mBAAA,GAAAC,OAAA;AACA;AACA,IAAAC,iBAAA,GAAAD,OAAA;AACA;AACA,IAAAE,mBAAA,GAAAF,OAAA;AAOA;AACA,IAAAG,WAAA,GAAAH,OAAA;AACA;AACA,IAAAI,cAAA,GAAAJ,OAAA;AACA;AACA,IAAAK,iBAAA,GAAAL,OAAA;AAEA;AACA,IAAAM,aAAA,GAAAN,OAAA;AACA,IAAAO,mCAAA,GAAAP,OAAA;AACA,IAAAQ,iBAAA,GAAAR,OAAA;AACA,IAAAS,uBAAA,GAAAT,OAAA;AACA,IAAAU,UAAA,GAAAV,OAAA;AAEA,IAAAW,cAAA,GAAAX,OAAA;AACA,IAAAY,uBAAA,GAAAZ,OAAA;AACA,IAAAa,wBAAA,GAAAb,OAAA;AAEA;AACA,IAAAc,WAAA,GAAAd,OAAA;AAGA;AACA;AACA;AACA;AAEA;;;AAGA,IAAAe,qBAAA;EAQE,SAAAA,sBAAA,GAAuB;EAEvB;;;;;;;;;;;;;;;;;;;;;;;;;;EA0BcA,qBAAA,CAAAC,MAAM,GAApB,UAAqBC,KAAgB,EACnCC,YAAyB,EACzBC,eAA4B,EAC5BC,aAA0B,EAC1BC,gBAA6B,EAC7BC,gBAAqB,EACrBC,gBAAqB;IACrB,IAAIC,WAAW,GAAgB,IAAIlB,aAAA,CAAAmB,OAAW,CAACR,KAAK,EAAEC,YAAY,EAAEC,eAAe,EAAEC,aAAa,EAAEC,gBAAgB,CAAC;IACrH,IAAIK,sBAAsB,GAAsC,IAAI;IACpE,IAAIC,uBAAuB,GAAsC,IAAI;IACrE,IAAIC,eAAgC;IACpC,KAAK,IAAIC,SAAS,CAAC,cAAc,IAAI,GAAIA,SAAS,GAAG,KAAK,EAAE;MAC1D,IAAIX,YAAY,IAAI,IAAI,EAAE;QACxBQ,sBAAsB,GAAGX,qBAAqB,CAACe,qBAAqB,CAACb,KAAK,EAAEO,WAAW,EAAEN,YAAY,EAAE,IAAI,EAAEI,gBAAgB,EAC3HC,gBAAgB,CAAC;;MAErB,IAAIH,aAAa,IAAI,IAAI,EAAE;QACzBO,uBAAuB,GAAGZ,qBAAqB,CAACe,qBAAqB,CAACb,KAAK,EAAEO,WAAW,EAAEJ,aAAa,EAAE,KAAK,EAAEE,gBAAgB,EAC9HC,gBAAgB,CAAC;;MAErBK,eAAe,GAAGb,qBAAqB,CAACgB,KAAK,CAACL,sBAAsB,EAAEC,uBAAuB,CAAC;MAC9F,IAAIC,eAAe,IAAI,IAAI,EAAE;QAC3B,MAAM1B,mBAAA,CAAAuB,OAAiB,CAACO,mBAAmB,EAAE;;MAE/C,IAAIC,SAAS,GAAgBL,eAAe,CAACM,cAAc,EAAE;MAC7D,IAAIL,SAAS,IAAII,SAAS,IAAI,IAAI,KAC/BA,SAAS,CAACE,OAAO,EAAE,GAAGX,WAAW,CAACW,OAAO,EAAE,IAAIF,SAAS,CAACG,OAAO,EAAE,GAAGZ,WAAW,CAACY,OAAO,EAAE,CAAC,EAAE;QAC9FZ,WAAW,GAAGS,SAAS;OACxB,MAAM;QACL;;;IAGJL,eAAe,CAACS,cAAc,CAACb,WAAW,CAAC;IAC3C,IAAIc,gBAAgB,GAAQV,eAAe,CAACW,qBAAqB,EAAE,GAAG,CAAC;IACvEX,eAAe,CAACY,wBAAwB,CAAC,CAAC,EAAEd,sBAAsB,CAAC;IACnEE,eAAe,CAACY,wBAAwB,CAACF,gBAAgB,EAAEX,uBAAuB,CAAC;IAEnF,IAAIc,WAAW,GAAYf,sBAAsB,IAAI,IAAI;IACzD,KAAK,IAAIgB,kBAAkB,CAAC,UAAU,CAAC,EAAEA,kBAAkB,IAAIJ,gBAAgB,EAAEI,kBAAkB,EAAE,EAAE;MACrG,IAAIC,aAAa,GAAQF,WAAW,GAAGC,kBAAkB,GAAGJ,gBAAgB,GAAGI,kBAAkB;MACjG,IAAId,eAAe,CAACgB,wBAAwB,CAACD,aAAa,CAAC,KAAK,UAAWE,SAAS,EAAE;QACpF;QACA;;MAEF,IAAIC,qBAAqB,SAAuB;MAChD,IAAIH,aAAa,KAAK,CAAC,IAAIA,aAAa,KAAKL,gBAAgB,EAAE;QAC7DQ,qBAAqB,GAAG,IAAIvC,mCAAA,CAAAkB,OAAiC,CAACD,WAAW,EAAEmB,aAAa,KAAK,CAAC,CAAC;OAChG,MAAM;QACLG,qBAAqB,GAAG,IAAIrC,uBAAA,CAAAgB,OAAqB,CAACD,WAAW,CAAC;;MAEhEI,eAAe,CAACY,wBAAwB,CAACG,aAAa,EAAEG,qBAAqB,CAAC;MAC9E,IAAIC,WAAW,GAAQ,CAAC,CAAC;MACzB,IAAIC,mBAAmB,GAAQD,WAAW;MAC1C;MACA,KAAK,IAAIE,QAAQ,CAAC,UAAUzB,WAAW,CAACW,OAAO,EAAE,EAAEc,QAAQ,IAAIzB,WAAW,CAACY,OAAO,EAAE,EAAEa,QAAQ,EAAE,EAAE;QAChGF,WAAW,GAAGhC,qBAAqB,CAACmC,cAAc,CAACtB,eAAe,EAAEe,aAAa,EAAEM,QAAQ,EAAER,WAAW,CAAC;QACzG,IAAIM,WAAW,GAAG,CAAC,IAAIA,WAAW,GAAGvB,WAAW,CAAC2B,OAAO,EAAE,EAAE;UAC1D,IAAIH,mBAAmB,KAAK,CAAC,CAAC,EAAE;YAC9B;;UAEFD,WAAW,GAAGC,mBAAmB;;QAEnC,IAAII,QAAQ,GAAarC,qBAAqB,CAACsC,cAAc,CAACpC,KAAK,EAAEO,WAAW,CAAC8B,OAAO,EAAE,EAAE9B,WAAW,CAAC2B,OAAO,EAAE,EAAEV,WAAW,EAC5HM,WAAW,EAAEE,QAAQ,EAAE3B,gBAAgB,EAAEC,gBAAgB,CAAC;QAC5D,IAAI6B,QAAQ,IAAI,IAAI,EAAE;UACpBN,qBAAqB,CAACS,WAAW,CAACN,QAAQ,EAAEG,QAAQ,CAAC;UACrDJ,mBAAmB,GAAGD,WAAW;UACjCzB,gBAAgB,GAAGkC,IAAI,CAACC,GAAG,CAACnC,gBAAgB,EAAE8B,QAAQ,CAACM,QAAQ,EAAE,CAAC;UAClEnC,gBAAgB,GAAGiC,IAAI,CAACG,GAAG,CAACpC,gBAAgB,EAAE6B,QAAQ,CAACM,QAAQ,EAAE,CAAC;;;;IAIxE,OAAO3C,qBAAqB,CAAC6C,mBAAmB,CAAChC,eAAe,CAAC;EACnE,CAAC;EAED;;;;;;;EAOeb,qBAAA,CAAAgB,KAAK,GAApB,UAAqBL,sBAAyD,EAC5EC,uBAA0D;IAC1D,IAAID,sBAAsB,IAAI,IAAI,IAAIC,uBAAuB,IAAI,IAAI,EAAE;MACrE,OAAO,IAAI;;IAEb,IAAIkC,eAAe,GAAoB9C,qBAAqB,CAAC+C,kBAAkB,CAACpC,sBAAsB,EAAEC,uBAAuB,CAAC;IAChI,IAAIkC,eAAe,IAAI,IAAI,EAAE;MAC3B,OAAO,IAAI;;IAEb,IAAIrC,WAAW,GAAgBlB,aAAA,CAAAmB,OAAW,CAACM,KAAK,CAAChB,qBAAqB,CAACgD,iBAAiB,CAACrC,sBAAsB,CAAC,EAC9GX,qBAAqB,CAACgD,iBAAiB,CAACpC,uBAAuB,CAAC,CAAC;IACnE,OAAO,IAAInB,iBAAA,CAAAiB,OAAe,CAACoC,eAAe,EAAErC,WAAW,CAAC;EAC1D,CAAC;EAED;;;;;;EAMeT,qBAAA,CAAAgD,iBAAiB,GAAhC,UAAiCC,kBAAqD;;IACpF,IAAIA,kBAAkB,IAAI,IAAI,EAAE;MAC9B,OAAO,IAAI;;IAEb,IAAIC,UAAU,GAAeD,kBAAkB,CAACE,aAAa,EAAE;IAC/D,IAAID,UAAU,IAAI,IAAI,EAAE;MACtB,OAAO,IAAI;;IAEb,IAAIE,YAAY,GAAQpD,qBAAqB,CAACqD,MAAM,CAACH,UAAU,CAAC;IAChE,IAAII,gBAAgB,GAAQ,CAAC;;MAC7B,KAA8B,IAAAC,YAAA,GAAAC,QAAA,CAAAN,UAAU,GAAAO,cAAA,GAAAF,YAAA,CAAAG,IAAA,KAAAD,cAAA,CAAAE,IAAA,EAAAF,cAAA,GAAAF,YAAA,CAAAG,IAAA,IAAE;QAArC,IAAIE,SAAS,GAAAH,cAAA,CAAAI,KAAA,CAAC;QACjBP,gBAAgB,IAAIF,YAAY,GAAGQ,SAAS;QAC5C,IAAIA,SAAS,GAAG,CAAC,EAAE;UACjB;;;;;;;;;;;;;;IAGJ,IAAIE,SAAS,GAAeb,kBAAkB,CAACc,YAAY,EAAE;IAC7D,KAAK,IAAIC,GAAG,CAAC,UAAU,CAAC,EAAEV,gBAAgB,GAAG,CAAC,IAAIQ,SAAS,CAACE,GAAG,CAAC,IAAI,IAAI,EAAEA,GAAG,EAAE,EAAE;MAC/EV,gBAAgB,EAAE;;IAEpB,IAAIW,cAAc,GAAQ,CAAC;IAC3B,KAAK,IAAID,GAAG,CAAC,UAAUd,UAAU,CAACgB,MAAM,GAAG,CAAC,EAAEF,GAAG,IAAI,CAAC,EAAEA,GAAG,EAAE,EAAE;MAC7DC,cAAc,IAAIb,YAAY,GAAGF,UAAU,CAACc,GAAG,CAAC;MAChD,IAAId,UAAU,CAACc,GAAG,CAAC,GAAG,CAAC,EAAE;QACvB;;;IAGJ,KAAK,IAAIA,GAAG,CAAC,UAAUF,SAAS,CAACI,MAAM,GAAG,CAAC,EAAED,cAAc,GAAG,CAAC,IAAIH,SAAS,CAACE,GAAG,CAAC,IAAI,IAAI,EAAEA,GAAG,EAAE,EAAE;MAChGC,cAAc,EAAE;;IAElB,OAAOhB,kBAAkB,CAAC9B,cAAc,EAAE,CAACgD,cAAc,CAACb,gBAAgB,EAAEW,cAAc,EACxFhB,kBAAkB,CAACmB,MAAM,EAAE,CAAC;EAChC,CAAC;EAEcpE,qBAAA,CAAAqD,MAAM,GAArB,UAAsBgB,MAAkB;;IACtC,IAAIC,QAAQ,GAAQ,CAAC,CAAC;;MACtB,KAA0B,IAAAC,QAAA,GAAAf,QAAA,CAAAa,MAAM,GAAAG,UAAA,GAAAD,QAAA,CAAAb,IAAA,KAAAc,UAAA,CAAAb,IAAA,EAAAa,UAAA,GAAAD,QAAA,CAAAb,IAAA,IAAE;QAA7B,IAAIG,KAAK,GAAAW,UAAA,CAAAX,KAAA,CAAC;QACbS,QAAQ,GAAG7B,IAAI,CAACG,GAAG,CAAC0B,QAAQ,EAAET,KAAK,CAAC;;;;;;;;;;;;;IAEtC,OAAOS,QAAQ;EACjB,CAAC;EAEctE,qBAAA,CAAA+C,kBAAkB,GAAjC,UAAkCpC,sBAAyD,EACzFC,uBAA0D;IAC1D,IAAI6D,mBAAoC;IACxC,IAAI9D,sBAAsB,IAAI,IAAI,IAChC,CAAC8D,mBAAmB,GAAG9D,sBAAsB,CAACoC,kBAAkB,EAAE,KAAK,IAAI,EAAE;MAC7E,OAAOnC,uBAAuB,IAAI,IAAI,GAAG,IAAI,GAAGA,uBAAuB,CAACmC,kBAAkB,EAAE;;IAE9F,IAAI2B,oBAAqC;IACzC,IAAI9D,uBAAuB,IAAI,IAAI,IACjC,CAAC8D,oBAAoB,GAAG9D,uBAAuB,CAACmC,kBAAkB,EAAE,KAAK,IAAI,EAAE;MAC/E,OAAO0B,mBAAmB;;IAG5B,IAAIA,mBAAmB,CAACE,cAAc,EAAE,KAAKD,oBAAoB,CAACC,cAAc,EAAE,IAChFF,mBAAmB,CAACG,uBAAuB,EAAE,KAAKF,oBAAoB,CAACE,uBAAuB,EAAE,IAChGH,mBAAmB,CAACI,WAAW,EAAE,KAAKH,oBAAoB,CAACG,WAAW,EAAE,EAAE;MAC1E,OAAO,IAAI;;IAEb,OAAOJ,mBAAmB;EAC5B,CAAC;EAEczE,qBAAA,CAAAe,qBAAqB,GAApC,UAAqCb,KAAgB,EACnDO,WAAwB,EACxBqE,UAAuB,EACvBpD,WAAoB,EACpBnB,gBAAqB,EACrBC,gBAAqB;IACrB,IAAIyC,kBAAkB,GAAsC,IAAIzD,mCAAA,CAAAkB,OAAiC,CAACD,WAAW,EAC3GiB,WAAW,CAAC;IACd,KAAK,IAAIqD,CAAC,CAAC,UAAU,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MAClC,IAAIC,SAAS,GAAQD,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;MACrC,IAAI/C,WAAW,GAAQS,IAAI,CAACwC,KAAK,CAAMxC,IAAI,CAACwC,KAAK,CAACH,UAAU,CAACI,IAAI,EAAE,CAAC,CAAC;MACrE,KAAK,IAAIhD,QAAQ,CAAC,UAAUO,IAAI,CAACwC,KAAK,CAAMxC,IAAI,CAACwC,KAAK,CAACH,UAAU,CAACK,IAAI,EAAE,CAAC,CAAC,EAAEjD,QAAQ,IAAIzB,WAAW,CAACY,OAAO,EAAE,IAC3Ga,QAAQ,IAAIzB,WAAW,CAACW,OAAO,EAAE,EAAEc,QAAQ,IAAI8C,SAAS,EAAE;QAC1D,IAAI3C,QAAQ,GAAarC,qBAAqB,CAACsC,cAAc,CAACpC,KAAK,EAAE,CAAC,EAAEA,KAAK,CAACyC,QAAQ,EAAE,EAAEjB,WAAW,EAAEM,WAAW,EAAEE,QAAQ,EAC1H3B,gBAAgB,EAAEC,gBAAgB,CAAC;QACrC,IAAI6B,QAAQ,IAAI,IAAI,EAAE;UACpBY,kBAAkB,CAACT,WAAW,CAACN,QAAQ,EAAEG,QAAQ,CAAC;UAClD,IAAIX,WAAW,EAAE;YACfM,WAAW,GAAGK,QAAQ,CAAC+C,SAAS,EAAE;WACnC,MAAM;YACLpD,WAAW,GAAGK,QAAQ,CAACgD,OAAO,EAAE;;;;;IAKxC,OAAOpC,kBAAkB;EAC3B,CAAC;EAED;;;;;;;;;;EAUejD,qBAAA,CAAAsF,mBAAmB,GAAlC,UAAmCzE,eAAgC,EAAE0E,aAA+B;IAClG,IAAIC,eAAe,GAAiBD,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACvD,IAAIE,iBAAiB,GAAeD,eAAe,CAACE,QAAQ,EAAE;IAC9D,IAAIC,2BAA2B,GAAQ9E,eAAe,CAACW,qBAAqB,EAAE,GAC5EX,eAAe,CAAC+E,kBAAkB,EAAE,GACpC5F,qBAAqB,CAAC6F,sBAAsB,CAAChF,eAAe,CAACiF,iBAAiB,EAAE,CAAC;IACnF,IAAIL,iBAAiB,CAACvB,MAAM,KAAK,CAAC,EAAE;MAClC,IAAIyB,2BAA2B,GAAG,CAAC,IAAIA,2BAA2B,GAAGtG,cAAA,CAAAqB,OAAY,CAACqF,wBAAwB,EAAE;QAC1G,MAAM5G,mBAAA,CAAAuB,OAAiB,CAACO,mBAAmB,EAAE;;MAE/CuE,eAAe,CAACQ,QAAQ,CAACL,2BAA2B,CAAC;KACtD,MAAM,IAAIF,iBAAiB,CAAC,CAAC,CAAC,KAAKE,2BAA2B,EAAE;MAC/D;MACAH,eAAe,CAACQ,QAAQ,CAACL,2BAA2B,CAAC;;EAEzD,CAAC;EAED;;;;;;;;EAQe3F,qBAAA,CAAA6C,mBAAmB,GAAlC,UAAmChC,eAAgC;IACjE,IAAI0E,aAAa,GAAqBvF,qBAAqB,CAACiG,mBAAmB,CAACpF,eAAe,CAAC;IAChGb,qBAAqB,CAACsF,mBAAmB,CAACzE,eAAe,EAAE0E,aAAa,CAAC;IACzE,IAAIW,QAAQ,CAAC,0BAA0B,IAAIC,KAAK,EAAU;IAC1D,IAAIrC,SAAS,GAAe,IAAIsC,UAAU,CAACvF,eAAe,CAAC+E,kBAAkB,EAAE,GAAG/E,eAAe,CAACW,qBAAqB,EAAE,CAAC;IAC1H,IAAI6E,wBAAwB,GAAE,eAAmC,EAAE;IACnE,IAAIC,oBAAoB,GAAE,uBAA0C,IAAIH,KAAK,EAAO;IACpF,KAAK,IAAInC,GAAG,CAAC,UAAU,CAAC,EAAEA,GAAG,GAAGnD,eAAe,CAAC+E,kBAAkB,EAAE,EAAE5B,GAAG,EAAE,EAAE;MAC3E,KAAK,IAAIuC,MAAM,CAAC,UAAU,CAAC,EAAEA,MAAM,GAAG1F,eAAe,CAACW,qBAAqB,EAAE,EAAE+E,MAAM,EAAE,EAAE;QACvF,IAAIlC,MAAM,GAAekB,aAAa,CAACvB,GAAG,CAAC,CAACuC,MAAM,GAAG,CAAC,CAAC,CAACb,QAAQ,EAAE;QAClE,IAAIc,aAAa,GAAQxC,GAAG,GAAGnD,eAAe,CAACW,qBAAqB,EAAE,GAAG+E,MAAM;QAC/E,IAAIlC,MAAM,CAACH,MAAM,KAAK,CAAC,EAAE;UACvBgC,QAAQ,CAACO,IAAI,CAACD,aAAa,CAAC;SAC7B,MAAM,IAAInC,MAAM,CAACH,MAAM,KAAK,CAAC,EAAE;UAC9BJ,SAAS,CAAC0C,aAAa,CAAC,GAAGnC,MAAM,CAAC,CAAC,CAAC;SACrC,MAAM;UACLiC,oBAAoB,CAACG,IAAI,CAACD,aAAa,CAAC;UACxCH,wBAAwB,CAACI,IAAI,CAACpC,MAAM,CAAC;;;;IAI3C,IAAIqC,oBAAoB,GAAiB,IAAIP,KAAK,CAAaE,wBAAwB,CAACnC,MAAM,CAAC;IAC/F,KAAK,IAAIa,CAAC,CAAC,UAAU,CAAC,EAAEA,CAAC,GAAG2B,oBAAoB,CAACxC,MAAM,EAAEa,CAAC,EAAE,EAAE;MAC5D2B,oBAAoB,CAAC3B,CAAC,CAAC,GAAGsB,wBAAwB,CAACtB,CAAC,CAAC;;IAEvD,OAAO/E,qBAAqB,CAAC2G,sCAAsC,CAAC9F,eAAe,CAACiF,iBAAiB,EAAE,EAAEhC,SAAS,EAChHzE,cAAA,CAAAqB,OAAY,CAACkG,UAAU,CAACV,QAAQ,CAAC,EAAE7G,cAAA,CAAAqB,OAAY,CAACkG,UAAU,CAACN,oBAAoB,CAAC,EAAEI,oBAAoB,CAAC;EAC3G,CAAC;EAED;;;;;;;;;;;;;;;;EAgBe1G,qBAAA,CAAA2G,sCAAsC,GAArD,UAAsDE,OAAY,EAChE/C,SAAqB,EACrBgD,YAAwB,EACxBC,gBAA4B,EAC5BL,oBAAkC;IAClC,IAAIM,mBAAmB,GAAe,IAAIZ,UAAU,CAACW,gBAAgB,CAAC7C,MAAM,CAAC;IAE7E,IAAI+C,KAAK,GAAQ,GAAG;IACpB,OAAOA,KAAK,EAAE,GAAG,CAAC,EAAE;MAClB,KAAK,IAAIlC,CAAC,CAAC,UAAU,CAAC,EAAEA,CAAC,GAAGiC,mBAAmB,CAAC9C,MAAM,EAAEa,CAAC,EAAE,EAAE;QAC3DjB,SAAS,CAACiD,gBAAgB,CAAChC,CAAC,CAAC,CAAC,GAAG2B,oBAAoB,CAAC3B,CAAC,CAAC,CAACiC,mBAAmB,CAACjC,CAAC,CAAC,CAAC;;MAElF,IAAI;QACF,OAAO/E,qBAAqB,CAACkH,eAAe,CAACpD,SAAS,EAAE+C,OAAO,EAAEC,YAAY,CAAC;OAC/E,CAAC,OAAOK,GAAG,EAAE;QACZ,IAAIC,OAAO,GAAGD,GAAG,YAAYnI,mBAAA,CAAA0B,OAAiB;QAC9C,IAAI,CAAC0G,OAAO,EAAE;UACZ,MAAMD,GAAG;;;MAGb,IAAIH,mBAAmB,CAAC9C,MAAM,KAAK,CAAC,EAAE;QACpC,MAAMlF,mBAAA,CAAA0B,OAAiB,CAAC2G,mBAAmB,EAAE;;MAE/C,KAAK,IAAItC,CAAC,CAAC,UAAU,CAAC,EAAEA,CAAC,GAAGiC,mBAAmB,CAAC9C,MAAM,EAAEa,CAAC,EAAE,EAAE;QAC3D,IAAIiC,mBAAmB,CAACjC,CAAC,CAAC,GAAG2B,oBAAoB,CAAC3B,CAAC,CAAC,CAACb,MAAM,GAAG,CAAC,EAAE;UAC/D8C,mBAAmB,CAACjC,CAAC,CAAC,EAAE;UACxB;SACD,MAAM;UACLiC,mBAAmB,CAACjC,CAAC,CAAC,GAAG,CAAC;UAC1B,IAAIA,CAAC,KAAKiC,mBAAmB,CAAC9C,MAAM,GAAG,CAAC,EAAE;YACxC,MAAMlF,mBAAA,CAAA0B,OAAiB,CAAC2G,mBAAmB,EAAE;;;;;IAKrD,MAAMrI,mBAAA,CAAA0B,OAAiB,CAAC2G,mBAAmB,EAAE;EAC/C,CAAC;EAEcrH,qBAAA,CAAAiG,mBAAmB,GAAlC,UAAmCpF,eAAgC;;IACjE;IACE;IACF,IAAI0E,aAAa,GACfY,KAAK,CAACmB,IAAI,CAAC;MAAEpD,MAAM,EAAErD,eAAe,CAAC+E,kBAAkB;IAAE,CAAE,EAAE;MAAM,WAAIO,KAAK,CAACtF,eAAe,CAACW,qBAAqB,EAAE,GAAG,CAAC,CAAC;IAAtD,CAAsD,CAAC;IAC5H,KAAK,IAAIwC,GAAG,CAAC,UAAU,CAAC,EAAEA,GAAG,GAAGuB,aAAa,CAACrB,MAAM,EAAEF,GAAG,EAAE,EAAE;MAC3D,KAAK,IAAIuD,QAAM,CAAC,UAAU,CAAC,EAAEA,QAAM,GAAGhC,aAAa,CAACvB,GAAG,CAAC,CAACE,MAAM,EAAEqD,QAAM,EAAE,EAAE;QACzEhC,aAAa,CAACvB,GAAG,CAAC,CAACuD,QAAM,CAAC,GAAG,IAAI3H,cAAA,CAAAc,OAAY,EAAE;;;IAInD,IAAI6F,MAAM,GAAQ,CAAC;;MACnB,KAA4D,IAAAiB,EAAA,GAAAhE,QAAA,CAAA3C,eAAe,CAAC4G,yBAAyB,EAAE,GAAAC,EAAA,GAAAF,EAAA,CAAA9D,IAAA,KAAAgE,EAAA,CAAA/D,IAAA,EAAA+D,EAAA,GAAAF,EAAA,CAAA9D,IAAA,IAAE;QAApG,IAAI3B,qBAAqB,GAAA2F,EAAA,CAAA7D,KAAA,CAAC;QAC7B,IAAI9B,qBAAqB,IAAI,IAAI,EAAE;;YACjC,KAAkC,IAAA4F,EAAA,GAAAnE,QAAA,CAAAzB,qBAAqB,CAACgC,YAAY,EAAE,GAAA6D,EAAA,GAAAD,EAAA,CAAAjE,IAAA,KAAAkE,EAAA,CAAAjE,IAAA,EAAAiE,EAAA,GAAAD,EAAA,CAAAjE,IAAA,IAAE;cAAnE,IAAIrB,QAAQ,GAAAuF,EAAA,CAAA/D,KAAA,CAAC;cAChB,IAAIxB,QAAQ,IAAI,IAAI,EAAE;gBACpB,IAAIwF,SAAS,GAAQxF,QAAQ,CAACyF,YAAY,EAAE;gBAC5C,IAAID,SAAS,IAAI,CAAC,EAAE;kBAClB,IAAIA,SAAS,IAAItC,aAAa,CAACrB,MAAM,EAAE;oBACrC;oBACA;;kBAEFqB,aAAa,CAACsC,SAAS,CAAC,CAACtB,MAAM,CAAC,CAACP,QAAQ,CAAC3D,QAAQ,CAACqD,QAAQ,EAAE,CAAC;;;;;;;;;;;;;;;;QAKtEa,MAAM,EAAE;;;;;;;;;;;;;IAEV,OAAOhB,aAAa;EACtB,CAAC;EAEcvF,qBAAA,CAAA+H,oBAAoB,GAAnC,UAAoClH,eAAgC,EAAEe,aAAkB;IACtF,OAAOA,aAAa,IAAI,CAAC,IAAIA,aAAa,IAAIf,eAAe,CAACW,qBAAqB,EAAE,GAAG,CAAC;EAC3F,CAAC;EAEcxB,qBAAA,CAAAmC,cAAc,GAA7B,UAA8BtB,eAAgC,EAC5De,aAAkB,EAClBM,QAAa,EACbR,WAAoB;;IACpB,IAAIsG,MAAM,GAAQtG,WAAW,GAAG,CAAC,GAAG,CAAC,CAAC;IACtC,IAAIW,QAAQ,GAAa,IAAI;IAC7B,IAAIrC,qBAAqB,CAAC+H,oBAAoB,CAAClH,eAAe,EAAEe,aAAa,GAAGoG,MAAM,CAAC,EAAE;MACvF3F,QAAQ,GAAGxB,eAAe,CAACgB,wBAAwB,CAACD,aAAa,GAAGoG,MAAM,CAAC,CAACC,WAAW,CAAC/F,QAAQ,CAAC;;IAEnG,IAAIG,QAAQ,IAAI,IAAI,EAAE;MACpB,OAAOX,WAAW,GAAGW,QAAQ,CAACgD,OAAO,EAAE,GAAGhD,QAAQ,CAAC+C,SAAS,EAAE;;IAEhE/C,QAAQ,GAAGxB,eAAe,CAACgB,wBAAwB,CAACD,aAAa,CAAC,CAACsG,iBAAiB,CAAChG,QAAQ,CAAC;IAC9F,IAAIG,QAAQ,IAAI,IAAI,EAAE;MACpB,OAAOX,WAAW,GAAGW,QAAQ,CAAC+C,SAAS,EAAE,GAAG/C,QAAQ,CAACgD,OAAO,EAAE;;IAEhE,IAAIrF,qBAAqB,CAAC+H,oBAAoB,CAAClH,eAAe,EAAEe,aAAa,GAAGoG,MAAM,CAAC,EAAE;MACvF3F,QAAQ,GAAGxB,eAAe,CAACgB,wBAAwB,CAACD,aAAa,GAAGoG,MAAM,CAAC,CAACE,iBAAiB,CAAChG,QAAQ,CAAC;;IAEzG,IAAIG,QAAQ,IAAI,IAAI,EAAE;MACpB,OAAOX,WAAW,GAAGW,QAAQ,CAACgD,OAAO,EAAE,GAAGhD,QAAQ,CAAC+C,SAAS,EAAE;;IAEhE,IAAI+C,cAAc,GAAQ,CAAC;IAE3B,OAAOnI,qBAAqB,CAAC+H,oBAAoB,CAAClH,eAAe,EAAEe,aAAa,GAAGoG,MAAM,CAAC,EAAE;MAC1FpG,aAAa,IAAIoG,MAAM;;QACvB,KAA6C,IAAAI,EAAA,GAAA5E,QAAA,CAAA3C,eAAe,CAACgB,wBAAwB,CAACD,aAAa,CAAC,CAACmC,YAAY,EAAE,GAAAyD,EAAA,GAAAY,EAAA,CAAA1E,IAAA,KAAA8D,EAAA,CAAA7D,IAAA,EAAA6D,EAAA,GAAAY,EAAA,CAAA1E,IAAA,IAAE;UAAhH,IAAI2E,mBAAmB,GAAAb,EAAA,CAAA3D,KAAA,CAAC;UAC3B,IAAIwE,mBAAmB,IAAI,IAAI,EAAE;YAC/B,OAAO,CAAC3G,WAAW,GAAG2G,mBAAmB,CAAChD,OAAO,EAAE,GAAGgD,mBAAmB,CAACjD,SAAS,EAAE,IACnF4C,MAAM,GACNG,cAAc,IACbE,mBAAmB,CAAChD,OAAO,EAAE,GAAGgD,mBAAmB,CAACjD,SAAS,EAAE,CAAC;;;;;;;;;;;;;;MAGvE+C,cAAc,EAAE;;IAElB,OAAOzG,WAAW,GAAGb,eAAe,CAACM,cAAc,EAAE,CAACoB,OAAO,EAAE,GAAG1B,eAAe,CAACM,cAAc,EAAE,CAACiB,OAAO,EAAE;EAC9G,CAAC;EAEcpC,qBAAA,CAAAsC,cAAc,GAA7B,UAA8BpC,KAAgB,EAC5CoI,SAAc,EACdC,SAAc,EACd7G,WAAoB,EACpBM,WAAgB,EAChBE,QAAa,EACb3B,gBAAqB,EACrBC,gBAAqB;IACrBwB,WAAW,GAAGhC,qBAAqB,CAACwI,yBAAyB,CAACtI,KAAK,EAAEoI,SAAS,EAAEC,SAAS,EAAE7G,WAAW,EAAEM,WAAW,EAAEE,QAAQ,CAAC;IAC9H;IACA;IACA;IACA;IACA,IAAIuG,cAAc,GAAezI,qBAAqB,CAAC0I,iBAAiB,CAACxI,KAAK,EAAEoI,SAAS,EAAEC,SAAS,EAAE7G,WAAW,EAAEM,WAAW,EAAEE,QAAQ,CAAC;IACzI,IAAIuG,cAAc,IAAI,IAAI,EAAE;MAC1B,OAAO,IAAI;;IAEb,IAAIE,SAAc;IAClB,IAAIC,gBAAgB,GAAQxJ,WAAA,CAAAsB,OAAS,CAACmI,GAAG,CAACJ,cAAc,CAAC;IACzD,IAAI/G,WAAW,EAAE;MACfiH,SAAS,GAAG3G,WAAW,GAAG4G,gBAAgB;KAC3C,MAAM;MACL,KAAK,IAAI7D,CAAC,CAAC,UAAU,CAAC,EAAEA,CAAC,GAAG0D,cAAc,CAACvE,MAAM,GAAG,CAAC,EAAEa,CAAC,EAAE,EAAE;QAC1D,IAAI+D,QAAQ,GAAQL,cAAc,CAAC1D,CAAC,CAAC;QACrC0D,cAAc,CAAC1D,CAAC,CAAC,GAAG0D,cAAc,CAACA,cAAc,CAACvE,MAAM,GAAG,CAAC,GAAGa,CAAC,CAAC;QACjE0D,cAAc,CAACA,cAAc,CAACvE,MAAM,GAAG,CAAC,GAAGa,CAAC,CAAC,GAAG+D,QAAQ;;MAE1DH,SAAS,GAAG3G,WAAW;MACvBA,WAAW,GAAG2G,SAAS,GAAGC,gBAAgB;;IAE5C;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA,IAAI,CAAC5I,qBAAqB,CAAC+I,iBAAiB,CAACH,gBAAgB,EAAErI,gBAAgB,EAAEC,gBAAgB,CAAC,EAAE;MAClG;MACA;MACA,OAAO,IAAI;;IAGb,IAAIwI,YAAY,GAAQnJ,uBAAA,CAAAa,OAAqB,CAACuI,eAAe,CAACR,cAAc,CAAC;IAC7E,IAAIpG,QAAQ,GAAQhD,cAAA,CAAAqB,OAAY,CAACuH,WAAW,CAACe,YAAY,CAAC;IAC1D,IAAI3G,QAAQ,KAAK,CAAC,CAAC,EAAE;MACnB,OAAO,IAAI;;IAEb,OAAO,IAAI1C,UAAA,CAAAe,OAAQ,CAACsB,WAAW,EAAE2G,SAAS,EAAE3I,qBAAqB,CAACkJ,uBAAuB,CAACF,YAAY,CAAC,EAAE3G,QAAQ,CAAC;EACpH,CAAC;EAEcrC,qBAAA,CAAA0I,iBAAiB,GAAhC,UAAiCxI,KAAgB,EAC/CoI,SAAc,EACdC,SAAc,EACd7G,WAAoB,EACpBM,WAAgB,EAChBE,QAAa;IACb,IAAIiH,WAAW,GAAQnH,WAAW;IAClC,IAAIyG,cAAc,GAAe,IAAIrC,UAAU,CAAC,CAAC,CAAC;IAClD,IAAIgD,YAAY,GAAQ,CAAC;IACzB,IAAIpE,SAAS,GAAQtD,WAAW,GAAG,CAAC,GAAG,CAAC,CAAC;IACzC,IAAI2H,kBAAkB,GAAY3H,WAAW;IAC7C,OAAO,CAACA,WAAW,GAAGyH,WAAW,GAAGZ,SAAS,GAAGY,WAAW,IAAIb,SAAS,KACtEc,YAAY,GAAGX,cAAc,CAACvE,MAAM,EAAE;MACtC,IAAIhE,KAAK,CAACoJ,GAAG,CAACH,WAAW,EAAEjH,QAAQ,CAAC,KAAKmH,kBAAkB,EAAE;QAC3DZ,cAAc,CAACW,YAAY,CAAC,EAAE;QAC9BD,WAAW,IAAInE,SAAS;OACzB,MAAM;QACLoE,YAAY,EAAE;QACdC,kBAAkB,GAAG,CAACA,kBAAkB;;;IAG5C,IAAID,YAAY,KAAKX,cAAc,CAACvE,MAAM,IACtCiF,WAAW,MAAMzH,WAAW,GAAG6G,SAAS,GAAGD,SAAS,CAAC,IACrDc,YAAY,KAAKX,cAAc,CAACvE,MAAM,GAAG,CAAE,EAAE;MAC/C,OAAOuE,cAAc;;IAEvB,OAAO,IAAI;EACb,CAAC;EAEczI,qBAAA,CAAA6F,sBAAsB,GAArC,UAAsC0D,cAAmB;IACvD,OAAO,CAAC,IAAIA,cAAc;EAC5B,CAAC;EAEcvJ,qBAAA,CAAAwI,yBAAyB,GAAxC,UAAyCtI,KAAgB,EACvDoI,SAAc,EACdC,SAAc,EACd7G,WAAoB,EACpB8H,mBAAwB,EACxBtH,QAAa;IACb,IAAIuH,oBAAoB,GAAQD,mBAAmB;IACnD,IAAIxE,SAAS,GAAQtD,WAAW,GAAG,CAAC,CAAC,GAAG,CAAC;IACzC;IACA,KAAK,IAAIqD,CAAC,CAAC,UAAU,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MAClC,OAAO,CAACrD,WAAW,GAAG+H,oBAAoB,IAAInB,SAAS,GAAGmB,oBAAoB,GAAGlB,SAAS,KACxF7G,WAAW,KAAKxB,KAAK,CAACoJ,GAAG,CAACG,oBAAoB,EAAEvH,QAAQ,CAAC,EAAE;QAC3D,IAAIO,IAAI,CAACiH,GAAG,CAACF,mBAAmB,GAAGC,oBAAoB,CAAC,GAAGzJ,qBAAqB,CAAC2J,kBAAkB,EAAE;UACnG,OAAOH,mBAAmB;;QAE5BC,oBAAoB,IAAIzE,SAAS;;MAEnCA,SAAS,GAAG,CAACA,SAAS;MACtBtD,WAAW,GAAG,CAACA,WAAW;;IAE5B,OAAO+H,oBAAoB;EAC7B,CAAC;EAEczJ,qBAAA,CAAA+I,iBAAiB,GAAhC,UAAiCa,YAAiB,EAAErJ,gBAAqB,EAAEC,gBAAqB;IAC9F,OAAOD,gBAAgB,GAAGP,qBAAqB,CAAC2J,kBAAkB,IAAIC,YAAY,IAChFA,YAAY,IAAIpJ,gBAAgB,GAAGR,qBAAqB,CAAC2J,kBAAkB;EAC/E,CAAC;EAED;;;;EAIe3J,qBAAA,CAAAkH,eAAe,GAA9B,UAA+BpD,SAAqB,EAAE+C,OAAY,EAAEX,QAAoB;IACtF,IAAIpC,SAAS,CAACI,MAAM,KAAK,CAAC,EAAE;MAC1B,MAAMhF,iBAAA,CAAAwB,OAAe,CAACmJ,iBAAiB,EAAE;;IAG3C,IAAIC,cAAc,GAAQ,CAAC,IAAKjD,OAAO,GAAG,CAAE;IAC5C,IAAIkD,oBAAoB,GAAQ/J,qBAAqB,CAACgK,aAAa,CAAClG,SAAS,EAAEoC,QAAQ,EAAE4D,cAAc,CAAC;IACxG9J,qBAAqB,CAACiK,mBAAmB,CAACnG,SAAS,EAAEgG,cAAc,CAAC;IAEpE;IACA,IAAII,aAAa,GAAkBpK,wBAAA,CAAAY,OAAsB,CAACT,MAAM,CAAC6D,SAAS,EAAE,EAAE,GAAG+C,OAAO,CAAC;IACzFqD,aAAa,CAACC,kBAAkB,CAACJ,oBAAoB,CAAC;IACtDG,aAAa,CAACE,WAAW,CAAClE,QAAQ,CAAChC,MAAM,CAAC;IAC1C,OAAOgG,aAAa;EACtB,CAAC;EAED;;;;;;;;;EASelK,qBAAA,CAAAgK,aAAa,GAA5B,UAA6BlG,SAAqB,EAAEoC,QAAoB,EAAE4D,cAAmB;IAC3F,IAAI5D,QAAQ,IAAI,IAAI,IAClBA,QAAQ,CAAChC,MAAM,GAAG4F,cAAc,GAAG,CAAC,GAAG9J,qBAAqB,CAACqK,UAAU,IACvEP,cAAc,GAAG,CAAC,IAClBA,cAAc,GAAG9J,qBAAqB,CAACsK,gBAAgB,EAAE;MACzD;MACA,MAAMtL,mBAAA,CAAA0B,OAAiB,CAAC2G,mBAAmB,EAAE;;IAE/C,OAAOrH,qBAAqB,CAACuK,eAAe,CAACtK,MAAM,CAAC6D,SAAS,EAAEgG,cAAc,EAAE5D,QAAQ,CAAC;EAC1F,CAAC;EAED;;;;EAIelG,qBAAA,CAAAiK,mBAAmB,GAAlC,UAAmCnG,SAAqB,EAAEgG,cAAmB;IAC3E,IAAIhG,SAAS,CAACI,MAAM,GAAG,CAAC,EAAE;MACxB;MACA;MACA,MAAMhF,iBAAA,CAAAwB,OAAe,CAACmJ,iBAAiB,EAAE;;IAE3C;IACA;IACA;IACA,IAAIpE,iBAAiB,GAAQ3B,SAAS,CAAC,CAAC,CAAC;IACzC,IAAI2B,iBAAiB,GAAG3B,SAAS,CAACI,MAAM,EAAE;MACxC,MAAMhF,iBAAA,CAAAwB,OAAe,CAACmJ,iBAAiB,EAAE;;IAE3C,IAAIpE,iBAAiB,KAAK,CAAC,EAAE;MAC3B;MACA,IAAIqE,cAAc,GAAGhG,SAAS,CAACI,MAAM,EAAE;QACrCJ,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAACI,MAAM,GAAG4F,cAAc;OACjD,MAAM;QACL,MAAM5K,iBAAA,CAAAwB,OAAe,CAACmJ,iBAAiB,EAAE;;;EAG/C,CAAC;EAEc7J,qBAAA,CAAAwK,sBAAsB,GAArC,UAAsCnI,QAAa;IACjD,IAAIoI,MAAM,GAAe,IAAIrE,UAAU,CAAC,CAAC,CAAC;IAC1C,IAAIsE,aAAa,GAAQ,CAAC;IAC1B,IAAI3F,CAAC,GAAQ0F,MAAM,CAACvG,MAAM,GAAG,CAAC;IAC9B,OAAO,IAAI,EAAE;MACX,IAAI,CAAC7B,QAAQ,GAAG,GAAG,MAAMqI,aAAa,EAAE;QACtCA,aAAa,GAAGrI,QAAQ,GAAG,GAAG;QAC9B0C,CAAC,EAAE;QACH,IAAIA,CAAC,GAAG,CAAC,EAAE;UACT;;;MAGJ0F,MAAM,CAAC1F,CAAC,CAAC,EAAE;MACX1C,QAAQ,KAAK,CAAC;;IAEhB,OAAOoI,MAAM;EACf,CAAC;EAEczK,qBAAA,CAAAkJ,uBAAuB,GAAtC,UAAuC7G,QAA0B;IAC/D,IAAIA,QAAQ,YAAY+D,UAAU,EAAE;MAClC,OAAO,IAAI,CAACuE,kCAAkC,CAACtI,QAAQ,CAAC;;IAE1D,OAAO,IAAI,CAACuI,8BAA8B,CAACvI,QAAQ,CAAC;EACtD,CAAC;EAEcrC,qBAAA,CAAA4K,8BAA8B,GAA7C,UAA8CvI,QAAa;IACzD,OAAOrC,qBAAqB,CAACkJ,uBAAuB,CAAClJ,qBAAqB,CAACwK,sBAAsB,CAACnI,QAAQ,CAAC,CAAC;EAC9G,CAAC;EAEcrC,qBAAA,CAAA2K,kCAAkC,GAAjD,UAAkDlC,cAA0B;IAC1E,OAAO,CAACA,cAAc,CAAC,CAAC,CAAC,GAAGA,cAAc,CAAC,CAAC,CAAC,GAAGA,cAAc,CAAC,CAAC,CAAC,GAAGA,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC;EAChG,CAAC;EAEazI,qBAAA,CAAA6K,QAAQ,GAAtB,UAAuBtF,aAA+B;IACpD,IAAIuF,SAAS,GAAG,IAAI/K,WAAA,CAAAW,OAAS,EAAE;IAC/B;IACA,KAAK,IAAIsD,GAAG,CAAC,UAAU,CAAC,EAAEA,GAAG,GAAGuB,aAAa,CAACrB,MAAM,EAAEF,GAAG,EAAE,EAAE;MAC3D8G,SAAS,CAACC,MAAM,CAAC,WAAW,EAAE/G,GAAG,CAAC;MAClC,KAAK,IAAIuC,MAAM,CAAC,UAAU,CAAC,EAAEA,MAAM,GAAGhB,aAAa,CAACvB,GAAG,CAAC,CAACE,MAAM,EAAEqC,MAAM,EAAE,EAAE;QACzE,IAAIyE,YAAY,GAAiBzF,aAAa,CAACvB,GAAG,CAAC,CAACuC,MAAM,CAAC;QAC3D,IAAIyE,YAAY,CAACtF,QAAQ,EAAE,CAACxB,MAAM,KAAK,CAAC,EAAE;UACxC4G,SAAS,CAACC,MAAM,CAAC,UAAU,EAAY,IAAI,CAAC;SAC7C,MAAM;UACLD,SAAS,CAACC,MAAM,CAAC,UAAU,EAAEC,YAAY,CAACtF,QAAQ,EAAE,CAAC,CAAC,CAAC,EACrDsF,YAAY,CAACC,aAAa,CAACD,YAAY,CAACtF,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;;;MAG7DoF,SAAS,CAACC,MAAM,CAAC,IAAI,CAAC;;IAExB,OAAOD,SAAS,CAACD,QAAQ,EAAE;IAC3B;EACF,CAAC;EAjpBD;EAAiB7K,qBAAA,CAAA2J,kBAAkB,GAAQ,CAAC;EAE5C;EAAiB3J,qBAAA,CAAAqK,UAAU,GAAQ,CAAC;EACpC;EAAiBrK,qBAAA,CAAAsK,gBAAgB,GAAQ,GAAG;EAC5C;EAAiBtK,qBAAA,CAAAuK,eAAe,GAAoB,IAAIjL,iBAAA,CAAAoB,OAAe,EAAE;EA+oB3E,OAAAV,qBAAC;CAAA,EArpBD;kBAAsCA,qBAAqB"},"metadata":{},"sourceType":"script"}