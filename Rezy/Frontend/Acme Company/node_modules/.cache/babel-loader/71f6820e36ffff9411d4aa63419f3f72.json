{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Version_1 = require(\"./Version\");\nvar FormatInformation_1 = require(\"./FormatInformation\");\nvar DataMask_1 = require(\"./DataMask\");\nvar FormatException_1 = require(\"../../FormatException\");\n/**\n * @author Sean Owen\n */\nvar BitMatrixParser = /** @class */function () {\n  /**\n   * @param bitMatrix {@link BitMatrix} to parse\n   * @throws FormatException if dimension is not >= 21 and 1 mod 4\n   */\n  function BitMatrixParser(bitMatrix) {\n    var dimension = bitMatrix.getHeight();\n    if (dimension < 21 || (dimension & 0x03) !== 1) {\n      throw new FormatException_1.default();\n    }\n    this.bitMatrix = bitMatrix;\n  }\n  /**\n   * <p>Reads format information from one of its two locations within the QR Code.</p>\n   *\n   * @return {@link FormatInformation} encapsulating the QR Code's format info\n   * @throws FormatException if both format information locations cannot be parsed as\n   * the valid encoding of format information\n   */\n  BitMatrixParser.prototype.readFormatInformation = function () {\n    if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {\n      return this.parsedFormatInfo;\n    }\n    // Read top-left format info bits\n    var formatInfoBits1 = 0;\n    for (var i = 0; i < 6; i++) {\n      formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);\n    }\n    // .. and skip a bit in the timing pattern ...\n    formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);\n    formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);\n    formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);\n    // .. and skip a bit in the timing pattern ...\n    for (var j = 5; j >= 0; j--) {\n      formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);\n    }\n    // Read the top-right/bottom-left pattern too\n    var dimension = this.bitMatrix.getHeight();\n    var formatInfoBits2 = 0;\n    var jMin = dimension - 7;\n    for (var j = dimension - 1; j >= jMin; j--) {\n      formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);\n    }\n    for (var i = dimension - 8; i < dimension; i++) {\n      formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);\n    }\n    this.parsedFormatInfo = FormatInformation_1.default.decodeFormatInformation(formatInfoBits1, formatInfoBits2);\n    if (this.parsedFormatInfo !== null) {\n      return this.parsedFormatInfo;\n    }\n    throw new FormatException_1.default();\n  };\n  /**\n   * <p>Reads version information from one of its two locations within the QR Code.</p>\n   *\n   * @return {@link Version} encapsulating the QR Code's version\n   * @throws FormatException if both version information locations cannot be parsed as\n   * the valid encoding of version information\n   */\n  BitMatrixParser.prototype.readVersion = function () {\n    if (this.parsedVersion !== null && this.parsedVersion !== undefined) {\n      return this.parsedVersion;\n    }\n    var dimension = this.bitMatrix.getHeight();\n    var provisionalVersion = Math.floor((dimension - 17) / 4);\n    if (provisionalVersion <= 6) {\n      return Version_1.default.getVersionForNumber(provisionalVersion);\n    }\n    // Read top-right version info: 3 wide by 6 tall\n    var versionBits = 0;\n    var ijMin = dimension - 11;\n    for (var j = 5; j >= 0; j--) {\n      for (var i = dimension - 9; i >= ijMin; i--) {\n        versionBits = this.copyBit(i, j, versionBits);\n      }\n    }\n    var theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n    if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n      this.parsedVersion = theParsedVersion;\n      return theParsedVersion;\n    }\n    // Hmm, failed. Try bottom left: 6 wide by 3 tall\n    versionBits = 0;\n    for (var i = 5; i >= 0; i--) {\n      for (var j = dimension - 9; j >= ijMin; j--) {\n        versionBits = this.copyBit(i, j, versionBits);\n      }\n    }\n    theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n    if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n      this.parsedVersion = theParsedVersion;\n      return theParsedVersion;\n    }\n    throw new FormatException_1.default();\n  };\n  BitMatrixParser.prototype.copyBit = function (i /*int*/, j /*int*/, versionBits /*int*/) {\n    var bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);\n    return bit ? versionBits << 1 | 0x1 : versionBits << 1;\n  };\n  /**\n   * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the\n   * correct order in order to reconstruct the codewords bytes contained within the\n   * QR Code.</p>\n   *\n   * @return bytes encoded within the QR Code\n   * @throws FormatException if the exact number of bytes expected is not read\n   */\n  BitMatrixParser.prototype.readCodewords = function () {\n    var formatInfo = this.readFormatInformation();\n    var version = this.readVersion();\n    // Get the data mask for the format used in this QR Code. This will exclude\n    // some bits from reading as we wind through the bit matrix.\n    var dataMask = DataMask_1.default.values.get(formatInfo.getDataMask());\n    var dimension = this.bitMatrix.getHeight();\n    dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n    var functionPattern = version.buildFunctionPattern();\n    var readingUp = true;\n    var result = new Uint8Array(version.getTotalCodewords());\n    var resultOffset = 0;\n    var currentByte = 0;\n    var bitsRead = 0;\n    // Read columns in pairs, from right to left\n    for (var j = dimension - 1; j > 0; j -= 2) {\n      if (j === 6) {\n        // Skip whole column with vertical alignment pattern\n        // saves time and makes the other code proceed more cleanly\n        j--;\n      }\n      // Read alternatingly from bottom to top then top to bottom\n      for (var count = 0; count < dimension; count++) {\n        var i = readingUp ? dimension - 1 - count : count;\n        for (var col = 0; col < 2; col++) {\n          // Ignore bits covered by the function pattern\n          if (!functionPattern.get(j - col, i)) {\n            // Read a bit\n            bitsRead++;\n            currentByte <<= 1;\n            if (this.bitMatrix.get(j - col, i)) {\n              currentByte |= 1;\n            }\n            // If we've made a whole byte, save it off\n            if (bitsRead === 8) {\n              result[resultOffset++] = /*(byte) */currentByte;\n              bitsRead = 0;\n              currentByte = 0;\n            }\n          }\n        }\n      }\n      readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions\n    }\n\n    if (resultOffset !== version.getTotalCodewords()) {\n      throw new FormatException_1.default();\n    }\n    return result;\n  };\n  /**\n   * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.\n   */\n  BitMatrixParser.prototype.remask = function () {\n    if (this.parsedFormatInfo === null) {\n      return; // We have no format information, and have no data mask\n    }\n\n    var dataMask = DataMask_1.default.values[this.parsedFormatInfo.getDataMask()];\n    var dimension = this.bitMatrix.getHeight();\n    dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n  };\n  /**\n   * Prepare the parser for a mirrored operation.\n   * This flag has effect only on the {@link #readFormatInformation()} and the\n   * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the\n   * {@link #mirror()} method should be called.\n   *\n   * @param mirror Whether to read version and format information mirrored.\n   */\n  BitMatrixParser.prototype.setMirror = function (isMirror) {\n    this.parsedVersion = null;\n    this.parsedFormatInfo = null;\n    this.isMirror = isMirror;\n  };\n  /** Mirror the bit matrix in order to attempt a second reading. */\n  BitMatrixParser.prototype.mirror = function () {\n    var bitMatrix = this.bitMatrix;\n    for (var x = 0, width = bitMatrix.getWidth(); x < width; x++) {\n      for (var y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {\n        if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {\n          bitMatrix.flip(y, x);\n          bitMatrix.flip(x, y);\n        }\n      }\n    }\n  };\n  return BitMatrixParser;\n}();\nexports.default = BitMatrixParser;","map":{"version":3,"names":["Version_1","require","FormatInformation_1","DataMask_1","FormatException_1","BitMatrixParser","bitMatrix","dimension","getHeight","default","prototype","readFormatInformation","parsedFormatInfo","undefined","formatInfoBits1","i","copyBit","j","formatInfoBits2","jMin","decodeFormatInformation","readVersion","parsedVersion","provisionalVersion","Math","floor","getVersionForNumber","versionBits","ijMin","theParsedVersion","decodeVersionInformation","getDimensionForVersion","bit","isMirror","get","readCodewords","formatInfo","version","dataMask","values","getDataMask","unmaskBitMatrix","functionPattern","buildFunctionPattern","readingUp","result","Uint8Array","getTotalCodewords","resultOffset","currentByte","bitsRead","count","col","remask","setMirror","mirror","x","width","getWidth","y","height","flip"],"sources":["../../../../src/core/qrcode/decoder/BitMatrixParser.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script"}