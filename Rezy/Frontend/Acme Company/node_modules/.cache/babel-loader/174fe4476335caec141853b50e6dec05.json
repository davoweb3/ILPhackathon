{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar System_1 = require(\"./util/System\");\n/**\n * <p>Encapsulates the result of decoding a barcode within an image.</p>\n *\n * @author Sean Owen\n */\nvar Result = /** @class */function () {\n  // public constructor(private text: string,\n  //               Uint8Array rawBytes,\n  //               ResultPoconst resultPoints: Int32Array,\n  //               BarcodeFormat format) {\n  //   this(text, rawBytes, resultPoints, format, System.currentTimeMillis())\n  // }\n  // public constructor(text: string,\n  //               Uint8Array rawBytes,\n  //               ResultPoconst resultPoints: Int32Array,\n  //               BarcodeFormat format,\n  //               long timestamp) {\n  //   this(text, rawBytes, rawBytes == null ? 0 : 8 * rawBytes.length,\n  //        resultPoints, format, timestamp)\n  // }\n  function Result(text, rawBytes, numBits, resultPoints, format, timestamp) {\n    if (numBits === void 0) {\n      numBits = rawBytes == null ? 0 : 8 * rawBytes.length;\n    }\n    if (timestamp === void 0) {\n      timestamp = System_1.default.currentTimeMillis();\n    }\n    this.text = text;\n    this.rawBytes = rawBytes;\n    this.numBits = numBits;\n    this.resultPoints = resultPoints;\n    this.format = format;\n    this.timestamp = timestamp;\n    this.text = text;\n    this.rawBytes = rawBytes;\n    if (undefined === numBits || null === numBits) {\n      this.numBits = rawBytes === null || rawBytes === undefined ? 0 : 8 * rawBytes.length;\n    } else {\n      this.numBits = numBits;\n    }\n    this.resultPoints = resultPoints;\n    this.format = format;\n    this.resultMetadata = null;\n    if (undefined === timestamp || null === timestamp) {\n      this.timestamp = System_1.default.currentTimeMillis();\n    } else {\n      this.timestamp = timestamp;\n    }\n  }\n  /**\n   * @return raw text encoded by the barcode\n   */\n  Result.prototype.getText = function () {\n    return this.text;\n  };\n  /**\n   * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}\n   */\n  Result.prototype.getRawBytes = function () {\n    return this.rawBytes;\n  };\n  /**\n   * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length\n   * @since 3.3.0\n   */\n  Result.prototype.getNumBits = function () {\n    return this.numBits;\n  };\n  /**\n   * @return points related to the barcode in the image. These are typically points\n   *         identifying finder patterns or the corners of the barcode. The exact meaning is\n   *         specific to the type of barcode that was decoded.\n   */\n  Result.prototype.getResultPoints = function () {\n    return this.resultPoints;\n  };\n  /**\n   * @return {@link BarcodeFormat} representing the format of the barcode that was decoded\n   */\n  Result.prototype.getBarcodeFormat = function () {\n    return this.format;\n  };\n  /**\n   * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be\n   *   {@code null}. This contains optional metadata about what was detected about the barcode,\n   *   like orientation.\n   */\n  Result.prototype.getResultMetadata = function () {\n    return this.resultMetadata;\n  };\n  Result.prototype.putMetadata = function (type, value) {\n    if (this.resultMetadata === null) {\n      this.resultMetadata = new Map();\n    }\n    this.resultMetadata.set(type, value);\n  };\n  Result.prototype.putAllMetadata = function (metadata) {\n    if (metadata !== null) {\n      if (this.resultMetadata === null) {\n        this.resultMetadata = metadata;\n      } else {\n        this.resultMetadata = new Map(metadata);\n      }\n    }\n  };\n  Result.prototype.addResultPoints = function (newPoints) {\n    var oldPoints = this.resultPoints;\n    if (oldPoints === null) {\n      this.resultPoints = newPoints;\n    } else if (newPoints !== null && newPoints.length > 0) {\n      var allPoints = new Array(oldPoints.length + newPoints.length);\n      System_1.default.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);\n      System_1.default.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);\n      this.resultPoints = allPoints;\n    }\n  };\n  Result.prototype.getTimestamp = function () {\n    return this.timestamp;\n  };\n  /*@Override*/\n  Result.prototype.toString = function () {\n    return this.text;\n  };\n  return Result;\n}();\nexports.default = Result;","map":{"version":3,"sources":["../../src/core/Result.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar System_1 = require(\"./util/System\");\n/**\n * <p>Encapsulates the result of decoding a barcode within an image.</p>\n *\n * @author Sean Owen\n */\nvar Result = /** @class */ (function () {\n    // public constructor(private text: string,\n    //               Uint8Array rawBytes,\n    //               ResultPoconst resultPoints: Int32Array,\n    //               BarcodeFormat format) {\n    //   this(text, rawBytes, resultPoints, format, System.currentTimeMillis())\n    // }\n    // public constructor(text: string,\n    //               Uint8Array rawBytes,\n    //               ResultPoconst resultPoints: Int32Array,\n    //               BarcodeFormat format,\n    //               long timestamp) {\n    //   this(text, rawBytes, rawBytes == null ? 0 : 8 * rawBytes.length,\n    //        resultPoints, format, timestamp)\n    // }\n    function Result(text, rawBytes, numBits, resultPoints, format, timestamp) {\n        if (numBits === void 0) { numBits = rawBytes == null ? 0 : 8 * rawBytes.length; }\n        if (timestamp === void 0) { timestamp = System_1.default.currentTimeMillis(); }\n        this.text = text;\n        this.rawBytes = rawBytes;\n        this.numBits = numBits;\n        this.resultPoints = resultPoints;\n        this.format = format;\n        this.timestamp = timestamp;\n        this.text = text;\n        this.rawBytes = rawBytes;\n        if (undefined === numBits || null === numBits) {\n            this.numBits = (rawBytes === null || rawBytes === undefined) ? 0 : 8 * rawBytes.length;\n        }\n        else {\n            this.numBits = numBits;\n        }\n        this.resultPoints = resultPoints;\n        this.format = format;\n        this.resultMetadata = null;\n        if (undefined === timestamp || null === timestamp) {\n            this.timestamp = System_1.default.currentTimeMillis();\n        }\n        else {\n            this.timestamp = timestamp;\n        }\n    }\n    /**\n     * @return raw text encoded by the barcode\n     */\n    Result.prototype.getText = function () {\n        return this.text;\n    };\n    /**\n     * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}\n     */\n    Result.prototype.getRawBytes = function () {\n        return this.rawBytes;\n    };\n    /**\n     * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length\n     * @since 3.3.0\n     */\n    Result.prototype.getNumBits = function () {\n        return this.numBits;\n    };\n    /**\n     * @return points related to the barcode in the image. These are typically points\n     *         identifying finder patterns or the corners of the barcode. The exact meaning is\n     *         specific to the type of barcode that was decoded.\n     */\n    Result.prototype.getResultPoints = function () {\n        return this.resultPoints;\n    };\n    /**\n     * @return {@link BarcodeFormat} representing the format of the barcode that was decoded\n     */\n    Result.prototype.getBarcodeFormat = function () {\n        return this.format;\n    };\n    /**\n     * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be\n     *   {@code null}. This contains optional metadata about what was detected about the barcode,\n     *   like orientation.\n     */\n    Result.prototype.getResultMetadata = function () {\n        return this.resultMetadata;\n    };\n    Result.prototype.putMetadata = function (type, value) {\n        if (this.resultMetadata === null) {\n            this.resultMetadata = new Map();\n        }\n        this.resultMetadata.set(type, value);\n    };\n    Result.prototype.putAllMetadata = function (metadata) {\n        if (metadata !== null) {\n            if (this.resultMetadata === null) {\n                this.resultMetadata = metadata;\n            }\n            else {\n                this.resultMetadata = new Map(metadata);\n            }\n        }\n    };\n    Result.prototype.addResultPoints = function (newPoints) {\n        var oldPoints = this.resultPoints;\n        if (oldPoints === null) {\n            this.resultPoints = newPoints;\n        }\n        else if (newPoints !== null && newPoints.length > 0) {\n            var allPoints = new Array(oldPoints.length + newPoints.length);\n            System_1.default.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);\n            System_1.default.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);\n            this.resultPoints = allPoints;\n        }\n    };\n    Result.prototype.getTimestamp = function () {\n        return this.timestamp;\n    };\n    /*@Override*/\n    Result.prototype.toString = function () {\n        return this.text;\n    };\n    return Result;\n}());\nexports.default = Result;\n//# sourceMappingURL=Result.js.map"]},"metadata":{},"sourceType":"script"}