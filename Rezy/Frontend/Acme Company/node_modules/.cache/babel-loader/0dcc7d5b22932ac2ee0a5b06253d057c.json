{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n    i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\nvar BitMatrixParser_1 = require(\"./BitMatrixParser\");\nvar DataBlock_1 = require(\"./DataBlock\");\nvar DecodedBitStreamParser_1 = require(\"./DecodedBitStreamParser\");\nvar ChecksumException_1 = require(\"../../ChecksumException\");\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * <p>The main class which implements Data Matrix Code decoding -- as opposed to locating and extracting\n * the Data Matrix Code from an image.</p>\n *\n * @author bbrown@google.com (Brian Brown)\n */\nvar Decoder = /** @class */function () {\n  function Decoder() {\n    this.rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.DATA_MATRIX_FIELD_256);\n  }\n  /**\n   * <p>Decodes a Data Matrix Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken\n   * to mean a black module.</p>\n   *\n   * @param bits booleans representing white/black Data Matrix Code modules\n   * @return text and bytes encoded within the Data Matrix Code\n   * @throws FormatException if the Data Matrix Code cannot be decoded\n   * @throws ChecksumException if error correction fails\n   */\n  Decoder.prototype.decode = function (bits) {\n    var e_1, _a;\n    // Construct a parser and read version, error-correction level\n    var parser = new BitMatrixParser_1.default(bits);\n    var version = parser.getVersion();\n    // Read codewords\n    var codewords = parser.readCodewords();\n    // Separate into data blocks\n    var dataBlocks = DataBlock_1.default.getDataBlocks(codewords, version);\n    // Count total number of data bytes\n    var totalBytes = 0;\n    try {\n      for (var dataBlocks_1 = __values(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {\n        var db = dataBlocks_1_1.value;\n        totalBytes += db.getNumDataCodewords();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    var resultBytes = new Uint8Array(totalBytes);\n    var dataBlocksCount = dataBlocks.length;\n    // Error-correct and copy data blocks together into a stream of bytes\n    for (var j = 0; j < dataBlocksCount; j++) {\n      var dataBlock = dataBlocks[j];\n      var codewordBytes = dataBlock.getCodewords();\n      var numDataCodewords = dataBlock.getNumDataCodewords();\n      this.correctErrors(codewordBytes, numDataCodewords);\n      for (var i = 0; i < numDataCodewords; i++) {\n        // De-interlace data blocks.\n        resultBytes[i * dataBlocksCount + j] = codewordBytes[i];\n      }\n    }\n    // Decode the contents of that stream of bytes\n    return DecodedBitStreamParser_1.default.decode(resultBytes);\n  };\n  /**\n   * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n   * correct the errors in-place using Reed-Solomon error correction.</p>\n   *\n   * @param codewordBytes data and error correction codewords\n   * @param numDataCodewords number of codewords that are data bytes\n   * @throws ChecksumException if error correction fails\n   */\n  Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords) {\n    var numCodewords = codewordBytes.length;\n    // First read into an array of ints\n    var codewordsInts = new Int32Array(codewordBytes);\n    // for (let i = 0; i < numCodewords; i++) {\n    //   codewordsInts[i] = codewordBytes[i] & 0xFF;\n    // }\n    try {\n      this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n    } catch (ignored /* ReedSolomonException */) {\n      throw new ChecksumException_1.default();\n    }\n    // Copy back into array of bytes -- only need to worry about the bytes that were data\n    // We don't care about errors in the error-correction codewords\n    for (var i = 0; i < numDataCodewords; i++) {\n      codewordBytes[i] = codewordsInts[i];\n    }\n  };\n  return Decoder;\n}();\nexports.default = Decoder;","map":{"version":3,"names":["ReedSolomonDecoder_1","require","GenericGF_1","BitMatrixParser_1","DataBlock_1","DecodedBitStreamParser_1","ChecksumException_1","Decoder","rsDecoder","default","DATA_MATRIX_FIELD_256","prototype","decode","bits","parser","version","getVersion","codewords","readCodewords","dataBlocks","getDataBlocks","totalBytes","dataBlocks_1","__values","dataBlocks_1_1","next","done","db","value","getNumDataCodewords","resultBytes","Uint8Array","dataBlocksCount","length","j","dataBlock","codewordBytes","getCodewords","numDataCodewords","correctErrors","i","numCodewords","codewordsInts","Int32Array","ignored"],"sources":["../../../../src/core/datamatrix/decoder/Decoder.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script"}