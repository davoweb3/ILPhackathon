{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\n/**\n * @author Satoru Takabayashi\n * @author Daniel Switkin\n * @author Sean Owen\n */\nvar MaskUtil = /** @class */function () {\n  function MaskUtil() {\n    // do nothing\n  }\n  /**\n   * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and\n   * give penalty to them. Example: 00000 or 11111.\n   */\n  MaskUtil.applyMaskPenaltyRule1 = function (matrix) {\n    return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);\n  };\n  /**\n   * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give\n   * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a\n   * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.\n   */\n  MaskUtil.applyMaskPenaltyRule2 = function (matrix) {\n    var penalty = 0;\n    var array = matrix.getArray();\n    var width = matrix.getWidth();\n    var height = matrix.getHeight();\n    for (var y = 0; y < height - 1; y++) {\n      var arrayY = array[y];\n      for (var x = 0; x < width - 1; x++) {\n        var value = arrayY[x];\n        if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {\n          penalty++;\n        }\n      }\n    }\n    return MaskUtil.N2 * penalty;\n  };\n  /**\n   * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4\n   * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we\n   * find patterns like 000010111010000, we give penalty once.\n   */\n  MaskUtil.applyMaskPenaltyRule3 = function (matrix) {\n    var numPenalties = 0;\n    var array = matrix.getArray();\n    var width = matrix.getWidth();\n    var height = matrix.getHeight();\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var arrayY = array[y]; // We can at least optimize this access\n        if (x + 6 < width && arrayY[x] === 1 && arrayY[x + 1] === 0 && arrayY[x + 2] === 1 && arrayY[x + 3] === 1 && arrayY[x + 4] === 1 && arrayY[x + 5] === 0 && arrayY[x + 6] === 1 && (MaskUtil.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil.isWhiteHorizontal(arrayY, x + 7, x + 11))) {\n          numPenalties++;\n        }\n        if (y + 6 < height && array[y][x] === 1 && array[y + 1][x] === 0 && array[y + 2][x] === 1 && array[y + 3][x] === 1 && array[y + 4][x] === 1 && array[y + 5][x] === 0 && array[y + 6][x] === 1 && (MaskUtil.isWhiteVertical(array, x, y - 4, y) || MaskUtil.isWhiteVertical(array, x, y + 7, y + 11))) {\n          numPenalties++;\n        }\n      }\n    }\n    return numPenalties * MaskUtil.N3;\n  };\n  MaskUtil.isWhiteHorizontal = function (rowArray, from /*int*/, to /*int*/) {\n    from = Math.max(from, 0);\n    to = Math.min(to, rowArray.length);\n    for (var i = from; i < to; i++) {\n      if (rowArray[i] === 1) {\n        return false;\n      }\n    }\n    return true;\n  };\n  MaskUtil.isWhiteVertical = function (array, col /*int*/, from /*int*/, to /*int*/) {\n    from = Math.max(from, 0);\n    to = Math.min(to, array.length);\n    for (var i = from; i < to; i++) {\n      if (array[i][col] === 1) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give\n   * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.\n   */\n  MaskUtil.applyMaskPenaltyRule4 = function (matrix) {\n    var numDarkCells = 0;\n    var array = matrix.getArray();\n    var width = matrix.getWidth();\n    var height = matrix.getHeight();\n    for (var y = 0; y < height; y++) {\n      var arrayY = array[y];\n      for (var x = 0; x < width; x++) {\n        if (arrayY[x] === 1) {\n          numDarkCells++;\n        }\n      }\n    }\n    var numTotalCells = matrix.getHeight() * matrix.getWidth();\n    var fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);\n    return fivePercentVariances * MaskUtil.N4;\n  };\n  /**\n   * Return the mask bit for \"getMaskPattern\" at \"x\" and \"y\". See 8.8 of JISX0510:2004 for mask\n   * pattern conditions.\n   */\n  MaskUtil.getDataMaskBit = function (maskPattern /*int*/, x /*int*/, y /*int*/) {\n    var intermediate; /*int*/\n    var temp; /*int*/\n    switch (maskPattern) {\n      case 0:\n        intermediate = y + x & 0x1;\n        break;\n      case 1:\n        intermediate = y & 0x1;\n        break;\n      case 2:\n        intermediate = x % 3;\n        break;\n      case 3:\n        intermediate = (y + x) % 3;\n        break;\n      case 4:\n        intermediate = Math.floor(y / 2) + Math.floor(x / 3) & 0x1;\n        break;\n      case 5:\n        temp = y * x;\n        intermediate = (temp & 0x1) + temp % 3;\n        break;\n      case 6:\n        temp = y * x;\n        intermediate = (temp & 0x1) + temp % 3 & 0x1;\n        break;\n      case 7:\n        temp = y * x;\n        intermediate = temp % 3 + (y + x & 0x1) & 0x1;\n        break;\n      default:\n        throw new IllegalArgumentException_1.default('Invalid mask pattern: ' + maskPattern);\n    }\n    return intermediate === 0;\n  };\n  /**\n   * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both\n   * vertical and horizontal orders respectively.\n   */\n  MaskUtil.applyMaskPenaltyRule1Internal = function (matrix, isHorizontal) {\n    var penalty = 0;\n    var iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();\n    var jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();\n    var array = matrix.getArray();\n    for (var i = 0; i < iLimit; i++) {\n      var numSameBitCells = 0;\n      var prevBit = -1;\n      for (var j = 0; j < jLimit; j++) {\n        var bit = isHorizontal ? array[i][j] : array[j][i];\n        if (bit === prevBit) {\n          numSameBitCells++;\n        } else {\n          if (numSameBitCells >= 5) {\n            penalty += MaskUtil.N1 + (numSameBitCells - 5);\n          }\n          numSameBitCells = 1; // Include the cell itself.\n          prevBit = bit;\n        }\n      }\n      if (numSameBitCells >= 5) {\n        penalty += MaskUtil.N1 + (numSameBitCells - 5);\n      }\n    }\n    return penalty;\n  };\n  // Penalty weights from section 6.8.2.1\n  MaskUtil.N1 = 3;\n  MaskUtil.N2 = 3;\n  MaskUtil.N3 = 40;\n  MaskUtil.N4 = 10;\n  return MaskUtil;\n}();\nexports.default = MaskUtil;","map":{"version":3,"sources":["../../../../src/core/qrcode/encoder/MaskUtil.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\n/**\n * @author Satoru Takabayashi\n * @author Daniel Switkin\n * @author Sean Owen\n */\nvar MaskUtil = /** @class */ (function () {\n    function MaskUtil() {\n        // do nothing\n    }\n    /**\n     * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and\n     * give penalty to them. Example: 00000 or 11111.\n     */\n    MaskUtil.applyMaskPenaltyRule1 = function (matrix) {\n        return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);\n    };\n    /**\n     * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give\n     * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a\n     * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.\n     */\n    MaskUtil.applyMaskPenaltyRule2 = function (matrix) {\n        var penalty = 0;\n        var array = matrix.getArray();\n        var width = matrix.getWidth();\n        var height = matrix.getHeight();\n        for (var y = 0; y < height - 1; y++) {\n            var arrayY = array[y];\n            for (var x = 0; x < width - 1; x++) {\n                var value = arrayY[x];\n                if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {\n                    penalty++;\n                }\n            }\n        }\n        return MaskUtil.N2 * penalty;\n    };\n    /**\n     * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4\n     * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we\n     * find patterns like 000010111010000, we give penalty once.\n     */\n    MaskUtil.applyMaskPenaltyRule3 = function (matrix) {\n        var numPenalties = 0;\n        var array = matrix.getArray();\n        var width = matrix.getWidth();\n        var height = matrix.getHeight();\n        for (var y = 0; y < height; y++) {\n            for (var x = 0; x < width; x++) {\n                var arrayY = array[y]; // We can at least optimize this access\n                if (x + 6 < width &&\n                    arrayY[x] === 1 &&\n                    arrayY[x + 1] === 0 &&\n                    arrayY[x + 2] === 1 &&\n                    arrayY[x + 3] === 1 &&\n                    arrayY[x + 4] === 1 &&\n                    arrayY[x + 5] === 0 &&\n                    arrayY[x + 6] === 1 &&\n                    (MaskUtil.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil.isWhiteHorizontal(arrayY, x + 7, x + 11))) {\n                    numPenalties++;\n                }\n                if (y + 6 < height &&\n                    array[y][x] === 1 &&\n                    array[y + 1][x] === 0 &&\n                    array[y + 2][x] === 1 &&\n                    array[y + 3][x] === 1 &&\n                    array[y + 4][x] === 1 &&\n                    array[y + 5][x] === 0 &&\n                    array[y + 6][x] === 1 &&\n                    (MaskUtil.isWhiteVertical(array, x, y - 4, y) || MaskUtil.isWhiteVertical(array, x, y + 7, y + 11))) {\n                    numPenalties++;\n                }\n            }\n        }\n        return numPenalties * MaskUtil.N3;\n    };\n    MaskUtil.isWhiteHorizontal = function (rowArray, from /*int*/, to /*int*/) {\n        from = Math.max(from, 0);\n        to = Math.min(to, rowArray.length);\n        for (var i = from; i < to; i++) {\n            if (rowArray[i] === 1) {\n                return false;\n            }\n        }\n        return true;\n    };\n    MaskUtil.isWhiteVertical = function (array, col /*int*/, from /*int*/, to /*int*/) {\n        from = Math.max(from, 0);\n        to = Math.min(to, array.length);\n        for (var i = from; i < to; i++) {\n            if (array[i][col] === 1) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give\n     * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.\n     */\n    MaskUtil.applyMaskPenaltyRule4 = function (matrix) {\n        var numDarkCells = 0;\n        var array = matrix.getArray();\n        var width = matrix.getWidth();\n        var height = matrix.getHeight();\n        for (var y = 0; y < height; y++) {\n            var arrayY = array[y];\n            for (var x = 0; x < width; x++) {\n                if (arrayY[x] === 1) {\n                    numDarkCells++;\n                }\n            }\n        }\n        var numTotalCells = matrix.getHeight() * matrix.getWidth();\n        var fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);\n        return fivePercentVariances * MaskUtil.N4;\n    };\n    /**\n     * Return the mask bit for \"getMaskPattern\" at \"x\" and \"y\". See 8.8 of JISX0510:2004 for mask\n     * pattern conditions.\n     */\n    MaskUtil.getDataMaskBit = function (maskPattern /*int*/, x /*int*/, y /*int*/) {\n        var intermediate; /*int*/\n        var temp; /*int*/\n        switch (maskPattern) {\n            case 0:\n                intermediate = (y + x) & 0x1;\n                break;\n            case 1:\n                intermediate = y & 0x1;\n                break;\n            case 2:\n                intermediate = x % 3;\n                break;\n            case 3:\n                intermediate = (y + x) % 3;\n                break;\n            case 4:\n                intermediate = (Math.floor(y / 2) + Math.floor(x / 3)) & 0x1;\n                break;\n            case 5:\n                temp = y * x;\n                intermediate = (temp & 0x1) + (temp % 3);\n                break;\n            case 6:\n                temp = y * x;\n                intermediate = ((temp & 0x1) + (temp % 3)) & 0x1;\n                break;\n            case 7:\n                temp = y * x;\n                intermediate = ((temp % 3) + ((y + x) & 0x1)) & 0x1;\n                break;\n            default:\n                throw new IllegalArgumentException_1.default('Invalid mask pattern: ' + maskPattern);\n        }\n        return intermediate === 0;\n    };\n    /**\n     * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both\n     * vertical and horizontal orders respectively.\n     */\n    MaskUtil.applyMaskPenaltyRule1Internal = function (matrix, isHorizontal) {\n        var penalty = 0;\n        var iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();\n        var jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();\n        var array = matrix.getArray();\n        for (var i = 0; i < iLimit; i++) {\n            var numSameBitCells = 0;\n            var prevBit = -1;\n            for (var j = 0; j < jLimit; j++) {\n                var bit = isHorizontal ? array[i][j] : array[j][i];\n                if (bit === prevBit) {\n                    numSameBitCells++;\n                }\n                else {\n                    if (numSameBitCells >= 5) {\n                        penalty += MaskUtil.N1 + (numSameBitCells - 5);\n                    }\n                    numSameBitCells = 1; // Include the cell itself.\n                    prevBit = bit;\n                }\n            }\n            if (numSameBitCells >= 5) {\n                penalty += MaskUtil.N1 + (numSameBitCells - 5);\n            }\n        }\n        return penalty;\n    };\n    // Penalty weights from section 6.8.2.1\n    MaskUtil.N1 = 3;\n    MaskUtil.N2 = 3;\n    MaskUtil.N3 = 40;\n    MaskUtil.N4 = 10;\n    return MaskUtil;\n}());\nexports.default = MaskUtil;\n//# sourceMappingURL=MaskUtil.js.map"]},"metadata":{},"sourceType":"script"}