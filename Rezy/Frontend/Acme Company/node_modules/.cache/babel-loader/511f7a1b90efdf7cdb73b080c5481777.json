{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.qrcode {*/\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar Result_1 = require(\"../Result\");\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\nvar BitMatrix_1 = require(\"../common/BitMatrix\");\nvar Decoder_1 = require(\"./decoder/Decoder\");\nvar QRCodeDecoderMetaData_1 = require(\"./decoder/QRCodeDecoderMetaData\");\nvar Detector_1 = require(\"./detector/Detector\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/*import java.util.List;*/\n/*import java.util.Map;*/\n/**\n * This implementation can detect and decode QR Codes in an image.\n *\n * @author Sean Owen\n */\nvar QRCodeReader = /** @class */function () {\n  function QRCodeReader() {\n    this.decoder = new Decoder_1.default();\n  }\n  QRCodeReader.prototype.getDecoder = function () {\n    return this.decoder;\n  };\n  /**\n   * Locates and decodes a QR code in an image.\n   *\n   * @return a representing: string the content encoded by the QR code\n   * @throws NotFoundException if a QR code cannot be found\n   * @throws FormatException if a QR code cannot be decoded\n   * @throws ChecksumException if error correction fails\n   */\n  /*@Override*/\n  // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {\n  //   return this.decode(image, null)\n  // }\n  /*@Override*/\n  QRCodeReader.prototype.decode = function (image, hints) {\n    var decoderResult;\n    var points;\n    if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType_1.default.PURE_BARCODE)) {\n      var bits = QRCodeReader.extractPureBits(image.getBlackMatrix());\n      decoderResult = this.decoder.decodeBitMatrix(bits, hints);\n      points = QRCodeReader.NO_POINTS;\n    } else {\n      var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect(hints);\n      decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);\n      points = detectorResult.getPoints();\n    }\n    // If the code was mirrored: swap the bottom-left and the top-right points.\n    if (decoderResult.getOther() instanceof QRCodeDecoderMetaData_1.default) {\n      decoderResult.getOther().applyMirroredCorrection(points);\n    }\n    var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat_1.default.QR_CODE, undefined);\n    var byteSegments = decoderResult.getByteSegments();\n    if (byteSegments !== null) {\n      result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);\n    }\n    var ecLevel = decoderResult.getECLevel();\n    if (ecLevel !== null) {\n      result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);\n    }\n    if (decoderResult.hasStructuredAppend()) {\n      result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());\n      result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());\n    }\n    return result;\n  };\n  /*@Override*/\n  QRCodeReader.prototype.reset = function () {\n    // do nothing\n  };\n  /**\n   * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n   * which contains only an unrotated, unskewed, image of a code, with some white border\n   * around it. This is a specialized method that works exceptionally fast in this special\n   * case.\n   *\n   * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)\n   */\n  QRCodeReader.extractPureBits = function (image) {\n    var leftTopBlack = image.getTopLeftOnBit();\n    var rightBottomBlack = image.getBottomRightOnBit();\n    if (leftTopBlack === null || rightBottomBlack === null) {\n      throw new NotFoundException_1.default();\n    }\n    var moduleSize = this.moduleSize(leftTopBlack, image);\n    var top = leftTopBlack[1];\n    var bottom = rightBottomBlack[1];\n    var left = leftTopBlack[0];\n    var right = rightBottomBlack[0];\n    // Sanity check!\n    if (left >= right || top >= bottom) {\n      throw new NotFoundException_1.default();\n    }\n    if (bottom - top !== right - left) {\n      // Special case, where bottom-right module wasn't black so we found something else in the last row\n      // Assume it's a square, so use height as the width\n      right = left + (bottom - top);\n      if (right >= image.getWidth()) {\n        // Abort if that would not make sense -- off image\n        throw new NotFoundException_1.default();\n      }\n    }\n    var matrixWidth = Math.round((right - left + 1) / moduleSize);\n    var matrixHeight = Math.round((bottom - top + 1) / moduleSize);\n    if (matrixWidth <= 0 || matrixHeight <= 0) {\n      throw new NotFoundException_1.default();\n    }\n    if (matrixHeight !== matrixWidth) {\n      // Only possibly decode square regions\n      throw new NotFoundException_1.default();\n    }\n    // Push in the \"border\" by half the module width so that we start\n    // sampling in the middle of the module. Just in case the image is a\n    // little off, this will help recover.\n    var nudge = /*(int) */Math.floor(moduleSize / 2.0);\n    top += nudge;\n    left += nudge;\n    // But careful that this does not sample off the edge\n    // \"right\" is the farthest-right valid pixel location -- right+1 is not necessarily\n    // This is positive by how much the inner x loop below would be too large\n    var nudgedTooFarRight = left + /*(int) */Math.floor((matrixWidth - 1) * moduleSize) - right;\n    if (nudgedTooFarRight > 0) {\n      if (nudgedTooFarRight > nudge) {\n        // Neither way fits; abort\n        throw new NotFoundException_1.default();\n      }\n      left -= nudgedTooFarRight;\n    }\n    // See logic above\n    var nudgedTooFarDown = top + /*(int) */Math.floor((matrixHeight - 1) * moduleSize) - bottom;\n    if (nudgedTooFarDown > 0) {\n      if (nudgedTooFarDown > nudge) {\n        // Neither way fits; abort\n        throw new NotFoundException_1.default();\n      }\n      top -= nudgedTooFarDown;\n    }\n    // Now just read off the bits\n    var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);\n    for (var y = 0; y < matrixHeight; y++) {\n      var iOffset = top + /*(int) */Math.floor(y * moduleSize);\n      for (var x = 0; x < matrixWidth; x++) {\n        if (image.get(left + /*(int) */Math.floor(x * moduleSize), iOffset)) {\n          bits.set(x, y);\n        }\n      }\n    }\n    return bits;\n  };\n  QRCodeReader.moduleSize = function (leftTopBlack, image) {\n    var height = image.getHeight();\n    var width = image.getWidth();\n    var x = leftTopBlack[0];\n    var y = leftTopBlack[1];\n    var inBlack = true;\n    var transitions = 0;\n    while (x < width && y < height) {\n      if (inBlack !== image.get(x, y)) {\n        if (++transitions === 5) {\n          break;\n        }\n        inBlack = !inBlack;\n      }\n      x++;\n      y++;\n    }\n    if (x === width || y === height) {\n      throw new NotFoundException_1.default();\n    }\n    return (x - leftTopBlack[0]) / 7.0;\n  };\n  QRCodeReader.NO_POINTS = new Array();\n  return QRCodeReader;\n}();\nexports.default = QRCodeReader;","map":{"version":3,"sources":["../../../src/core/qrcode/QRCodeReader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.qrcode {*/\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar Result_1 = require(\"../Result\");\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\nvar BitMatrix_1 = require(\"../common/BitMatrix\");\nvar Decoder_1 = require(\"./decoder/Decoder\");\nvar QRCodeDecoderMetaData_1 = require(\"./decoder/QRCodeDecoderMetaData\");\nvar Detector_1 = require(\"./detector/Detector\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/*import java.util.List;*/\n/*import java.util.Map;*/\n/**\n * This implementation can detect and decode QR Codes in an image.\n *\n * @author Sean Owen\n */\nvar QRCodeReader = /** @class */ (function () {\n    function QRCodeReader() {\n        this.decoder = new Decoder_1.default();\n    }\n    QRCodeReader.prototype.getDecoder = function () {\n        return this.decoder;\n    };\n    /**\n     * Locates and decodes a QR code in an image.\n     *\n     * @return a representing: string the content encoded by the QR code\n     * @throws NotFoundException if a QR code cannot be found\n     * @throws FormatException if a QR code cannot be decoded\n     * @throws ChecksumException if error correction fails\n     */\n    /*@Override*/\n    // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {\n    //   return this.decode(image, null)\n    // }\n    /*@Override*/\n    QRCodeReader.prototype.decode = function (image, hints) {\n        var decoderResult;\n        var points;\n        if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType_1.default.PURE_BARCODE)) {\n            var bits = QRCodeReader.extractPureBits(image.getBlackMatrix());\n            decoderResult = this.decoder.decodeBitMatrix(bits, hints);\n            points = QRCodeReader.NO_POINTS;\n        }\n        else {\n            var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect(hints);\n            decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);\n            points = detectorResult.getPoints();\n        }\n        // If the code was mirrored: swap the bottom-left and the top-right points.\n        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData_1.default) {\n            decoderResult.getOther().applyMirroredCorrection(points);\n        }\n        var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat_1.default.QR_CODE, undefined);\n        var byteSegments = decoderResult.getByteSegments();\n        if (byteSegments !== null) {\n            result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);\n        }\n        var ecLevel = decoderResult.getECLevel();\n        if (ecLevel !== null) {\n            result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);\n        }\n        if (decoderResult.hasStructuredAppend()) {\n            result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());\n            result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());\n        }\n        return result;\n    };\n    /*@Override*/\n    QRCodeReader.prototype.reset = function () {\n        // do nothing\n    };\n    /**\n     * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n     * which contains only an unrotated, unskewed, image of a code, with some white border\n     * around it. This is a specialized method that works exceptionally fast in this special\n     * case.\n     *\n     * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)\n     */\n    QRCodeReader.extractPureBits = function (image) {\n        var leftTopBlack = image.getTopLeftOnBit();\n        var rightBottomBlack = image.getBottomRightOnBit();\n        if (leftTopBlack === null || rightBottomBlack === null) {\n            throw new NotFoundException_1.default();\n        }\n        var moduleSize = this.moduleSize(leftTopBlack, image);\n        var top = leftTopBlack[1];\n        var bottom = rightBottomBlack[1];\n        var left = leftTopBlack[0];\n        var right = rightBottomBlack[0];\n        // Sanity check!\n        if (left >= right || top >= bottom) {\n            throw new NotFoundException_1.default();\n        }\n        if (bottom - top !== right - left) {\n            // Special case, where bottom-right module wasn't black so we found something else in the last row\n            // Assume it's a square, so use height as the width\n            right = left + (bottom - top);\n            if (right >= image.getWidth()) {\n                // Abort if that would not make sense -- off image\n                throw new NotFoundException_1.default();\n            }\n        }\n        var matrixWidth = Math.round((right - left + 1) / moduleSize);\n        var matrixHeight = Math.round((bottom - top + 1) / moduleSize);\n        if (matrixWidth <= 0 || matrixHeight <= 0) {\n            throw new NotFoundException_1.default();\n        }\n        if (matrixHeight !== matrixWidth) {\n            // Only possibly decode square regions\n            throw new NotFoundException_1.default();\n        }\n        // Push in the \"border\" by half the module width so that we start\n        // sampling in the middle of the module. Just in case the image is a\n        // little off, this will help recover.\n        var nudge = /*(int) */ Math.floor(moduleSize / 2.0);\n        top += nudge;\n        left += nudge;\n        // But careful that this does not sample off the edge\n        // \"right\" is the farthest-right valid pixel location -- right+1 is not necessarily\n        // This is positive by how much the inner x loop below would be too large\n        var nudgedTooFarRight = left + /*(int) */ Math.floor((matrixWidth - 1) * moduleSize) - right;\n        if (nudgedTooFarRight > 0) {\n            if (nudgedTooFarRight > nudge) {\n                // Neither way fits; abort\n                throw new NotFoundException_1.default();\n            }\n            left -= nudgedTooFarRight;\n        }\n        // See logic above\n        var nudgedTooFarDown = top + /*(int) */ Math.floor((matrixHeight - 1) * moduleSize) - bottom;\n        if (nudgedTooFarDown > 0) {\n            if (nudgedTooFarDown > nudge) {\n                // Neither way fits; abort\n                throw new NotFoundException_1.default();\n            }\n            top -= nudgedTooFarDown;\n        }\n        // Now just read off the bits\n        var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);\n        for (var y = 0; y < matrixHeight; y++) {\n            var iOffset = top + /*(int) */ Math.floor(y * moduleSize);\n            for (var x = 0; x < matrixWidth; x++) {\n                if (image.get(left + /*(int) */ Math.floor(x * moduleSize), iOffset)) {\n                    bits.set(x, y);\n                }\n            }\n        }\n        return bits;\n    };\n    QRCodeReader.moduleSize = function (leftTopBlack, image) {\n        var height = image.getHeight();\n        var width = image.getWidth();\n        var x = leftTopBlack[0];\n        var y = leftTopBlack[1];\n        var inBlack = true;\n        var transitions = 0;\n        while (x < width && y < height) {\n            if (inBlack !== image.get(x, y)) {\n                if (++transitions === 5) {\n                    break;\n                }\n                inBlack = !inBlack;\n            }\n            x++;\n            y++;\n        }\n        if (x === width || y === height) {\n            throw new NotFoundException_1.default();\n        }\n        return (x - leftTopBlack[0]) / 7.0;\n    };\n    QRCodeReader.NO_POINTS = new Array();\n    return QRCodeReader;\n}());\nexports.default = QRCodeReader;\n//# sourceMappingURL=QRCodeReader.js.map"]},"metadata":{},"sourceType":"script"}