{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common {*/\nvar Binarizer_1 = require(\"../Binarizer\");\nvar BitArray_1 = require(\"./BitArray\");\nvar BitMatrix_1 = require(\"./BitMatrix\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\n * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable\n * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding\n * algorithm. However, because it picks a global black point, it cannot handle difficult shadows\n * and gradients.\n *\n * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\nvar GlobalHistogramBinarizer = /** @class */function (_super) {\n  __extends(GlobalHistogramBinarizer, _super);\n  function GlobalHistogramBinarizer(source) {\n    var _this = _super.call(this, source) || this;\n    _this.luminances = GlobalHistogramBinarizer.EMPTY;\n    _this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);\n    return _this;\n  }\n  // Applies simple sharpening to the row data to improve performance of the 1D Readers.\n  /*@Override*/\n  GlobalHistogramBinarizer.prototype.getBlackRow = function (y /*int*/, row) {\n    var source = this.getLuminanceSource();\n    var width = source.getWidth();\n    if (row === undefined || row === null || row.getSize() < width) {\n      row = new BitArray_1.default(width);\n    } else {\n      row.clear();\n    }\n    this.initArrays(width);\n    var localLuminances = source.getRow(y, this.luminances);\n    var localBuckets = this.buckets;\n    for (var x = 0; x < width; x++) {\n      localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n    }\n    var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n    if (width < 3) {\n      // Special case for very small images\n      for (var x = 0; x < width; x++) {\n        if ((localLuminances[x] & 0xff) < blackPoint) {\n          row.set(x);\n        }\n      }\n    } else {\n      var left = localLuminances[0] & 0xff;\n      var center = localLuminances[1] & 0xff;\n      for (var x = 1; x < width - 1; x++) {\n        var right = localLuminances[x + 1] & 0xff;\n        // A simple -1 4 -1 box filter with a weight of 2.\n        if ((center * 4 - left - right) / 2 < blackPoint) {\n          row.set(x);\n        }\n        left = center;\n        center = right;\n      }\n    }\n    return row;\n  };\n  // Does not sharpen the data, as this call is intended to only be used by 2D Readers.\n  /*@Override*/\n  GlobalHistogramBinarizer.prototype.getBlackMatrix = function () {\n    var source = this.getLuminanceSource();\n    var width = source.getWidth();\n    var height = source.getHeight();\n    var matrix = new BitMatrix_1.default(width, height);\n    // Quickly calculates the histogram by sampling four rows from the image. This proved to be\n    // more robust on the blackbox tests than sampling a diagonal as we used to do.\n    this.initArrays(width);\n    var localBuckets = this.buckets;\n    for (var y = 1; y < 5; y++) {\n      var row = Math.floor(height * y / 5);\n      var localLuminances_1 = source.getRow(row, this.luminances);\n      var right = Math.floor(width * 4 / 5);\n      for (var x = Math.floor(width / 5); x < right; x++) {\n        var pixel = localLuminances_1[x] & 0xff;\n        localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n      }\n    }\n    var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n    // We delay reading the entire image luminance until the black point estimation succeeds.\n    // Although we end up reading four rows twice, it is consistent with our motto of\n    // \"fail quickly\" which is necessary for continuous scanning.\n    var localLuminances = source.getMatrix();\n    for (var y = 0; y < height; y++) {\n      var offset = y * width;\n      for (var x = 0; x < width; x++) {\n        var pixel = localLuminances[offset + x] & 0xff;\n        if (pixel < blackPoint) {\n          matrix.set(x, y);\n        }\n      }\n    }\n    return matrix;\n  };\n  /*@Override*/\n  GlobalHistogramBinarizer.prototype.createBinarizer = function (source) {\n    return new GlobalHistogramBinarizer(source);\n  };\n  GlobalHistogramBinarizer.prototype.initArrays = function (luminanceSize /*int*/) {\n    if (this.luminances.length < luminanceSize) {\n      this.luminances = new Uint8ClampedArray(luminanceSize);\n    }\n    var buckets = this.buckets;\n    for (var x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {\n      buckets[x] = 0;\n    }\n  };\n  GlobalHistogramBinarizer.estimateBlackPoint = function (buckets) {\n    // Find the tallest peak in the histogram.\n    var numBuckets = buckets.length;\n    var maxBucketCount = 0;\n    var firstPeak = 0;\n    var firstPeakSize = 0;\n    for (var x = 0; x < numBuckets; x++) {\n      if (buckets[x] > firstPeakSize) {\n        firstPeak = x;\n        firstPeakSize = buckets[x];\n      }\n      if (buckets[x] > maxBucketCount) {\n        maxBucketCount = buckets[x];\n      }\n    }\n    // Find the second-tallest peak which is somewhat far from the tallest peak.\n    var secondPeak = 0;\n    var secondPeakScore = 0;\n    for (var x = 0; x < numBuckets; x++) {\n      var distanceToBiggest = x - firstPeak;\n      // Encourage more distant second peaks by multiplying by square of distance.\n      var score = buckets[x] * distanceToBiggest * distanceToBiggest;\n      if (score > secondPeakScore) {\n        secondPeak = x;\n        secondPeakScore = score;\n      }\n    }\n    // Make sure firstPeak corresponds to the black peak.\n    if (firstPeak > secondPeak) {\n      var temp = firstPeak;\n      firstPeak = secondPeak;\n      secondPeak = temp;\n    }\n    // If there is too little contrast in the image to pick a meaningful black point, throw rather\n    // than waste time trying to decode the image, and risk false positives.\n    if (secondPeak - firstPeak <= numBuckets / 16) {\n      throw new NotFoundException_1.default();\n    }\n    // Find a valley between them that is low and closer to the white peak.\n    var bestValley = secondPeak - 1;\n    var bestValleyScore = -1;\n    for (var x = secondPeak - 1; x > firstPeak; x--) {\n      var fromFirst = x - firstPeak;\n      var score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);\n      if (score > bestValleyScore) {\n        bestValley = x;\n        bestValleyScore = score;\n      }\n    }\n    return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;\n  };\n  GlobalHistogramBinarizer.LUMINANCE_BITS = 5;\n  GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;\n  GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;\n  GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);\n  return GlobalHistogramBinarizer;\n}(Binarizer_1.default);\nexports.default = GlobalHistogramBinarizer;","map":{"version":3,"sources":["../../../src/core/common/GlobalHistogramBinarizer.ts"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;AAcG;;;;;;;;;;;;;;;;;;;;;;;AAEH;AAEA,IAAA,WAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AAEA,IAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAEA,IAAA,mBAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;AAEA;;;;;;;;;;AAUG;AACH,IAAA,wBAAA,GAAA,aAAA,UAAA,MAAA,EAAA;EAAsD,SAAA,CAAA,wBAAA,EAAA,MAAA,CAAA;EAUlD,SAAA,wBAAA,CAAmB,MAAuB,EAAA;IAA1C,IAAA,KAAA,GACI,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,MAAM,CAAC,IAAA,IAAA;IACb,KAAI,CAAC,UAAU,GAAG,wBAAwB,CAAC,KAAK;IAChD,KAAI,CAAC,OAAO,GAAG,IAAI,UAAU,CAAC,wBAAwB,CAAC,iBAAiB,CAAC;;EAC7E;EAEA;EACA;EACO,wBAAA,CAAA,SAAA,CAAA,WAAW,GAAlB,UAAmB,CAAS,CAAC,SAAS,GAAa,EAAA;IAC/C,IAAM,MAAM,GAAG,IAAI,CAAC,kBAAkB,EAAE;IACxC,IAAM,KAAK,GAAG,MAAM,CAAC,QAAQ,EAAE;IAC/B,IAAI,GAAG,KAAK,SAAS,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,CAAC,OAAO,EAAE,GAAG,KAAK,EAAE;MAC5D,GAAG,GAAG,IAAI,UAAA,CAAA,OAAQ,CAAC,KAAK,CAAC;KAC5B,MAAM;MACH,GAAG,CAAC,KAAK,EAAE;IACd;IAED,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC;IACtB,IAAM,eAAe,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,UAAU,CAAC;IACzD,IAAM,YAAY,GAAG,IAAI,CAAC,OAAO;IACjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;MAC5B,YAAY,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,GAAG,IAAI,KAAK,wBAAwB,CAAC,eAAe,CAAC,EAAE;IAC1F;IACD,IAAM,UAAU,GAAG,wBAAwB,CAAC,kBAAkB,CAAC,YAAY,CAAC;IAE5E,IAAI,KAAK,GAAG,CAAC,EAAE;MACX;MACA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;QAC5B,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,UAAU,EAAE;UAC1C,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;QACb;MACJ;KACJ,MAAM;MACH,IAAI,IAAI,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,IAAI;MACpC,IAAI,MAAM,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,IAAI;MACtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;QAChC,IAAM,KAAK,GAAG,eAAe,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI;QAC3C;QACA,IAAI,CAAE,MAAM,GAAG,CAAC,GAAI,IAAI,GAAG,KAAK,IAAI,CAAC,GAAG,UAAU,EAAE;UAChD,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;QACb;QACD,IAAI,GAAG,MAAM;QACb,MAAM,GAAG,KAAK;MACjB;IACJ;IACD,OAAO,GAAG;EACd,CAAC;EAED;EACA;EACO,wBAAA,CAAA,SAAA,CAAA,cAAc,GAArB,YAAA;IACI,IAAM,MAAM,GAAG,IAAI,CAAC,kBAAkB,EAAE;IACxC,IAAM,KAAK,GAAG,MAAM,CAAC,QAAQ,EAAE;IAC/B,IAAM,MAAM,GAAG,MAAM,CAAC,SAAS,EAAE;IACjC,IAAM,MAAM,GAAG,IAAI,WAAA,CAAA,OAAS,CAAC,KAAK,EAAE,MAAM,CAAC;IAE3C;IACA;IACA,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC;IACtB,IAAM,YAAY,GAAG,IAAI,CAAC,OAAO;IACjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;MACxB,IAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAE,MAAM,GAAG,CAAC,GAAI,CAAC,CAAC;MACxC,IAAM,iBAAe,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,UAAU,CAAC;MAC3D,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAE,KAAK,GAAG,CAAC,GAAI,CAAC,CAAC;MACzC,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;QAChD,IAAM,KAAK,GAAG,iBAAe,CAAC,CAAC,CAAC,GAAG,IAAI;QACvC,YAAY,CAAC,KAAK,IAAI,wBAAwB,CAAC,eAAe,CAAC,EAAE;MACpE;IACJ;IACD,IAAM,UAAU,GAAG,wBAAwB,CAAC,kBAAkB,CAAC,YAAY,CAAC;IAE5E;IACA;IACA;IACA,IAAM,eAAe,GAAG,MAAM,CAAC,SAAS,EAAE;IAC1C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;MAC7B,IAAM,MAAM,GAAG,CAAC,GAAG,KAAK;MACxB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;QAC5B,IAAM,KAAK,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI;QAChD,IAAI,KAAK,GAAG,UAAU,EAAE;UACpB,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;QACnB;MACJ;IACJ;IAED,OAAO,MAAM;EACjB,CAAC;EAED;EACO,wBAAA,CAAA,SAAA,CAAA,eAAe,GAAtB,UAAuB,MAAuB,EAAA;IAC1C,OAAO,IAAI,wBAAwB,CAAC,MAAM,CAAC;EAC/C,CAAC;EAEO,wBAAA,CAAA,SAAA,CAAA,UAAU,GAAlB,UAAmB,aAAqB,CAAC,SAAO;IAC5C,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,aAAa,EAAE;MACxC,IAAI,CAAC,UAAU,GAAG,IAAI,iBAAiB,CAAC,aAAa,CAAC;IACzD;IACD,IAAM,OAAO,GAAG,IAAI,CAAC,OAAO;IAC5B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,wBAAwB,CAAC,iBAAiB,EAAE,CAAC,EAAE,EAAE;MACjE,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC;IACjB;EACL,CAAC;EAEc,wBAAA,CAAA,kBAAkB,GAAjC,UAAkC,OAAmB,EAAA;IACjD;IACA,IAAM,UAAU,GAAG,OAAO,CAAC,MAAM;IACjC,IAAI,cAAc,GAAG,CAAC;IACtB,IAAI,SAAS,GAAG,CAAC;IACjB,IAAI,aAAa,GAAG,CAAC;IACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;MACjC,IAAI,OAAO,CAAC,CAAC,CAAC,GAAG,aAAa,EAAE;QAC5B,SAAS,GAAG,CAAC;QACb,aAAa,GAAG,OAAO,CAAC,CAAC,CAAC;MAC7B;MACD,IAAI,OAAO,CAAC,CAAC,CAAC,GAAG,cAAc,EAAE;QAC7B,cAAc,GAAG,OAAO,CAAC,CAAC,CAAC;MAC9B;IACJ;IAED;IACA,IAAI,UAAU,GAAG,CAAC;IAClB,IAAI,eAAe,GAAG,CAAC;IAEvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;MACjC,IAAM,iBAAiB,GAAG,CAAC,GAAG,SAAS;MACvC;MACA,IAAM,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,GAAG,iBAAiB,GAAG,iBAAiB;MAChE,IAAI,KAAK,GAAG,eAAe,EAAE;QACzB,UAAU,GAAG,CAAC;QACd,eAAe,GAAG,KAAK;MAC1B;IACJ;IAED;IACA,IAAI,SAAS,GAAG,UAAU,EAAE;MACxB,IAAM,IAAI,GAAG,SAAS;MACtB,SAAS,GAAG,UAAU;MACtB,UAAU,GAAG,IAAI;IACpB;IAED;IACA;IACA,IAAI,UAAU,GAAG,SAAS,IAAI,UAAU,GAAG,EAAE,EAAE;MAC3C,MAAM,IAAI,mBAAA,CAAA,OAAiB,EAAE;IAChC;IAED;IACA,IAAI,UAAU,GAAG,UAAU,GAAG,CAAC;IAC/B,IAAI,eAAe,GAAG,CAAC,CAAC;IACxB,KAAK,IAAI,CAAC,GAAG,UAAU,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;MAC7C,IAAM,SAAS,GAAG,CAAC,GAAG,SAAS;MAC/B,IAAM,KAAK,GAAG,SAAS,GAAG,SAAS,IAAI,UAAU,GAAG,CAAC,CAAC,IAAI,cAAc,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;MACtF,IAAI,KAAK,GAAG,eAAe,EAAE;QACzB,UAAU,GAAG,CAAC;QACd,eAAe,GAAG,KAAK;MAC1B;IACJ;IAED,OAAO,UAAU,IAAI,wBAAwB,CAAC,eAAe;EACjE,CAAC;EAvKc,wBAAA,CAAA,cAAc,GAAG,CAAC;EAClB,wBAAA,CAAA,eAAe,GAAG,CAAC,GAAG,wBAAwB,CAAC,cAAc;EAC7D,wBAAA,CAAA,iBAAiB,GAAG,CAAC,IAAI,wBAAwB,CAAC,cAAc;EAChE,wBAAA,CAAA,KAAK,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;EAsKtD,OAAA,wBAAC;CAAA,CA3KqD,WAAA,CAAA,OAAS,CAAA;kBAA1C,wBAAwB","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.common {*/\nvar Binarizer_1 = require(\"../Binarizer\");\nvar BitArray_1 = require(\"./BitArray\");\nvar BitMatrix_1 = require(\"./BitMatrix\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\n * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable\n * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding\n * algorithm. However, because it picks a global black point, it cannot handle difficult shadows\n * and gradients.\n *\n * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\nvar GlobalHistogramBinarizer = /** @class */ (function (_super) {\n    __extends(GlobalHistogramBinarizer, _super);\n    function GlobalHistogramBinarizer(source) {\n        var _this = _super.call(this, source) || this;\n        _this.luminances = GlobalHistogramBinarizer.EMPTY;\n        _this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);\n        return _this;\n    }\n    // Applies simple sharpening to the row data to improve performance of the 1D Readers.\n    /*@Override*/\n    GlobalHistogramBinarizer.prototype.getBlackRow = function (y /*int*/, row) {\n        var source = this.getLuminanceSource();\n        var width = source.getWidth();\n        if (row === undefined || row === null || row.getSize() < width) {\n            row = new BitArray_1.default(width);\n        }\n        else {\n            row.clear();\n        }\n        this.initArrays(width);\n        var localLuminances = source.getRow(y, this.luminances);\n        var localBuckets = this.buckets;\n        for (var x = 0; x < width; x++) {\n            localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n        }\n        var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n        if (width < 3) {\n            // Special case for very small images\n            for (var x = 0; x < width; x++) {\n                if ((localLuminances[x] & 0xff) < blackPoint) {\n                    row.set(x);\n                }\n            }\n        }\n        else {\n            var left = localLuminances[0] & 0xff;\n            var center = localLuminances[1] & 0xff;\n            for (var x = 1; x < width - 1; x++) {\n                var right = localLuminances[x + 1] & 0xff;\n                // A simple -1 4 -1 box filter with a weight of 2.\n                if (((center * 4) - left - right) / 2 < blackPoint) {\n                    row.set(x);\n                }\n                left = center;\n                center = right;\n            }\n        }\n        return row;\n    };\n    // Does not sharpen the data, as this call is intended to only be used by 2D Readers.\n    /*@Override*/\n    GlobalHistogramBinarizer.prototype.getBlackMatrix = function () {\n        var source = this.getLuminanceSource();\n        var width = source.getWidth();\n        var height = source.getHeight();\n        var matrix = new BitMatrix_1.default(width, height);\n        // Quickly calculates the histogram by sampling four rows from the image. This proved to be\n        // more robust on the blackbox tests than sampling a diagonal as we used to do.\n        this.initArrays(width);\n        var localBuckets = this.buckets;\n        for (var y = 1; y < 5; y++) {\n            var row = Math.floor((height * y) / 5);\n            var localLuminances_1 = source.getRow(row, this.luminances);\n            var right = Math.floor((width * 4) / 5);\n            for (var x = Math.floor(width / 5); x < right; x++) {\n                var pixel = localLuminances_1[x] & 0xff;\n                localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n            }\n        }\n        var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n        // We delay reading the entire image luminance until the black point estimation succeeds.\n        // Although we end up reading four rows twice, it is consistent with our motto of\n        // \"fail quickly\" which is necessary for continuous scanning.\n        var localLuminances = source.getMatrix();\n        for (var y = 0; y < height; y++) {\n            var offset = y * width;\n            for (var x = 0; x < width; x++) {\n                var pixel = localLuminances[offset + x] & 0xff;\n                if (pixel < blackPoint) {\n                    matrix.set(x, y);\n                }\n            }\n        }\n        return matrix;\n    };\n    /*@Override*/\n    GlobalHistogramBinarizer.prototype.createBinarizer = function (source) {\n        return new GlobalHistogramBinarizer(source);\n    };\n    GlobalHistogramBinarizer.prototype.initArrays = function (luminanceSize /*int*/) {\n        if (this.luminances.length < luminanceSize) {\n            this.luminances = new Uint8ClampedArray(luminanceSize);\n        }\n        var buckets = this.buckets;\n        for (var x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {\n            buckets[x] = 0;\n        }\n    };\n    GlobalHistogramBinarizer.estimateBlackPoint = function (buckets) {\n        // Find the tallest peak in the histogram.\n        var numBuckets = buckets.length;\n        var maxBucketCount = 0;\n        var firstPeak = 0;\n        var firstPeakSize = 0;\n        for (var x = 0; x < numBuckets; x++) {\n            if (buckets[x] > firstPeakSize) {\n                firstPeak = x;\n                firstPeakSize = buckets[x];\n            }\n            if (buckets[x] > maxBucketCount) {\n                maxBucketCount = buckets[x];\n            }\n        }\n        // Find the second-tallest peak which is somewhat far from the tallest peak.\n        var secondPeak = 0;\n        var secondPeakScore = 0;\n        for (var x = 0; x < numBuckets; x++) {\n            var distanceToBiggest = x - firstPeak;\n            // Encourage more distant second peaks by multiplying by square of distance.\n            var score = buckets[x] * distanceToBiggest * distanceToBiggest;\n            if (score > secondPeakScore) {\n                secondPeak = x;\n                secondPeakScore = score;\n            }\n        }\n        // Make sure firstPeak corresponds to the black peak.\n        if (firstPeak > secondPeak) {\n            var temp = firstPeak;\n            firstPeak = secondPeak;\n            secondPeak = temp;\n        }\n        // If there is too little contrast in the image to pick a meaningful black point, throw rather\n        // than waste time trying to decode the image, and risk false positives.\n        if (secondPeak - firstPeak <= numBuckets / 16) {\n            throw new NotFoundException_1.default();\n        }\n        // Find a valley between them that is low and closer to the white peak.\n        var bestValley = secondPeak - 1;\n        var bestValleyScore = -1;\n        for (var x = secondPeak - 1; x > firstPeak; x--) {\n            var fromFirst = x - firstPeak;\n            var score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);\n            if (score > bestValleyScore) {\n                bestValley = x;\n                bestValleyScore = score;\n            }\n        }\n        return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;\n    };\n    GlobalHistogramBinarizer.LUMINANCE_BITS = 5;\n    GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;\n    GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;\n    GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);\n    return GlobalHistogramBinarizer;\n}(Binarizer_1.default));\nexports.default = GlobalHistogramBinarizer;\n//# sourceMappingURL=GlobalHistogramBinarizer.js.map"]},"metadata":{},"sourceType":"script"}