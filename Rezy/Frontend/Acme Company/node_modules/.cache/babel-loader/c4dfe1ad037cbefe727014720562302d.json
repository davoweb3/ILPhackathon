{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Version_1 = require(\"./Version\");\nvar FormatInformation_1 = require(\"./FormatInformation\");\nvar DataMask_1 = require(\"./DataMask\");\nvar FormatException_1 = require(\"../../FormatException\");\n/**\n * @author Sean Owen\n */\nvar BitMatrixParser = /** @class */function () {\n  /**\n   * @param bitMatrix {@link BitMatrix} to parse\n   * @throws FormatException if dimension is not >= 21 and 1 mod 4\n   */\n  function BitMatrixParser(bitMatrix) {\n    var dimension = bitMatrix.getHeight();\n    if (dimension < 21 || (dimension & 0x03) !== 1) {\n      throw new FormatException_1.default();\n    }\n    this.bitMatrix = bitMatrix;\n  }\n  /**\n   * <p>Reads format information from one of its two locations within the QR Code.</p>\n   *\n   * @return {@link FormatInformation} encapsulating the QR Code's format info\n   * @throws FormatException if both format information locations cannot be parsed as\n   * the valid encoding of format information\n   */\n  BitMatrixParser.prototype.readFormatInformation = function () {\n    if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {\n      return this.parsedFormatInfo;\n    }\n    // Read top-left format info bits\n    var formatInfoBits1 = 0;\n    for (var i = 0; i < 6; i++) {\n      formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);\n    }\n    // .. and skip a bit in the timing pattern ...\n    formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);\n    formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);\n    formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);\n    // .. and skip a bit in the timing pattern ...\n    for (var j = 5; j >= 0; j--) {\n      formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);\n    }\n    // Read the top-right/bottom-left pattern too\n    var dimension = this.bitMatrix.getHeight();\n    var formatInfoBits2 = 0;\n    var jMin = dimension - 7;\n    for (var j = dimension - 1; j >= jMin; j--) {\n      formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);\n    }\n    for (var i = dimension - 8; i < dimension; i++) {\n      formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);\n    }\n    this.parsedFormatInfo = FormatInformation_1.default.decodeFormatInformation(formatInfoBits1, formatInfoBits2);\n    if (this.parsedFormatInfo !== null) {\n      return this.parsedFormatInfo;\n    }\n    throw new FormatException_1.default();\n  };\n  /**\n   * <p>Reads version information from one of its two locations within the QR Code.</p>\n   *\n   * @return {@link Version} encapsulating the QR Code's version\n   * @throws FormatException if both version information locations cannot be parsed as\n   * the valid encoding of version information\n   */\n  BitMatrixParser.prototype.readVersion = function () {\n    if (this.parsedVersion !== null && this.parsedVersion !== undefined) {\n      return this.parsedVersion;\n    }\n    var dimension = this.bitMatrix.getHeight();\n    var provisionalVersion = Math.floor((dimension - 17) / 4);\n    if (provisionalVersion <= 6) {\n      return Version_1.default.getVersionForNumber(provisionalVersion);\n    }\n    // Read top-right version info: 3 wide by 6 tall\n    var versionBits = 0;\n    var ijMin = dimension - 11;\n    for (var j = 5; j >= 0; j--) {\n      for (var i = dimension - 9; i >= ijMin; i--) {\n        versionBits = this.copyBit(i, j, versionBits);\n      }\n    }\n    var theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n    if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n      this.parsedVersion = theParsedVersion;\n      return theParsedVersion;\n    }\n    // Hmm, failed. Try bottom left: 6 wide by 3 tall\n    versionBits = 0;\n    for (var i = 5; i >= 0; i--) {\n      for (var j = dimension - 9; j >= ijMin; j--) {\n        versionBits = this.copyBit(i, j, versionBits);\n      }\n    }\n    theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n    if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n      this.parsedVersion = theParsedVersion;\n      return theParsedVersion;\n    }\n    throw new FormatException_1.default();\n  };\n  BitMatrixParser.prototype.copyBit = function (i /*int*/, j /*int*/, versionBits /*int*/) {\n    var bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);\n    return bit ? versionBits << 1 | 0x1 : versionBits << 1;\n  };\n  /**\n   * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the\n   * correct order in order to reconstruct the codewords bytes contained within the\n   * QR Code.</p>\n   *\n   * @return bytes encoded within the QR Code\n   * @throws FormatException if the exact number of bytes expected is not read\n   */\n  BitMatrixParser.prototype.readCodewords = function () {\n    var formatInfo = this.readFormatInformation();\n    var version = this.readVersion();\n    // Get the data mask for the format used in this QR Code. This will exclude\n    // some bits from reading as we wind through the bit matrix.\n    var dataMask = DataMask_1.default.values.get(formatInfo.getDataMask());\n    var dimension = this.bitMatrix.getHeight();\n    dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n    var functionPattern = version.buildFunctionPattern();\n    var readingUp = true;\n    var result = new Uint8Array(version.getTotalCodewords());\n    var resultOffset = 0;\n    var currentByte = 0;\n    var bitsRead = 0;\n    // Read columns in pairs, from right to left\n    for (var j = dimension - 1; j > 0; j -= 2) {\n      if (j === 6) {\n        // Skip whole column with vertical alignment pattern\n        // saves time and makes the other code proceed more cleanly\n        j--;\n      }\n      // Read alternatingly from bottom to top then top to bottom\n      for (var count = 0; count < dimension; count++) {\n        var i = readingUp ? dimension - 1 - count : count;\n        for (var col = 0; col < 2; col++) {\n          // Ignore bits covered by the function pattern\n          if (!functionPattern.get(j - col, i)) {\n            // Read a bit\n            bitsRead++;\n            currentByte <<= 1;\n            if (this.bitMatrix.get(j - col, i)) {\n              currentByte |= 1;\n            }\n            // If we've made a whole byte, save it off\n            if (bitsRead === 8) {\n              result[resultOffset++] = /*(byte) */currentByte;\n              bitsRead = 0;\n              currentByte = 0;\n            }\n          }\n        }\n      }\n      readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions\n    }\n\n    if (resultOffset !== version.getTotalCodewords()) {\n      throw new FormatException_1.default();\n    }\n    return result;\n  };\n  /**\n   * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.\n   */\n  BitMatrixParser.prototype.remask = function () {\n    if (this.parsedFormatInfo === null) {\n      return; // We have no format information, and have no data mask\n    }\n\n    var dataMask = DataMask_1.default.values[this.parsedFormatInfo.getDataMask()];\n    var dimension = this.bitMatrix.getHeight();\n    dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n  };\n  /**\n   * Prepare the parser for a mirrored operation.\n   * This flag has effect only on the {@link #readFormatInformation()} and the\n   * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the\n   * {@link #mirror()} method should be called.\n   *\n   * @param mirror Whether to read version and format information mirrored.\n   */\n  BitMatrixParser.prototype.setMirror = function (isMirror) {\n    this.parsedVersion = null;\n    this.parsedFormatInfo = null;\n    this.isMirror = isMirror;\n  };\n  /** Mirror the bit matrix in order to attempt a second reading. */\n  BitMatrixParser.prototype.mirror = function () {\n    var bitMatrix = this.bitMatrix;\n    for (var x = 0, width = bitMatrix.getWidth(); x < width; x++) {\n      for (var y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {\n        if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {\n          bitMatrix.flip(y, x);\n          bitMatrix.flip(x, y);\n        }\n      }\n    }\n  };\n  return BitMatrixParser;\n}();\nexports.default = BitMatrixParser;","map":{"version":3,"sources":["../../../../src/core/qrcode/decoder/BitMatrixParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Version_1 = require(\"./Version\");\nvar FormatInformation_1 = require(\"./FormatInformation\");\nvar DataMask_1 = require(\"./DataMask\");\nvar FormatException_1 = require(\"../../FormatException\");\n/**\n * @author Sean Owen\n */\nvar BitMatrixParser = /** @class */ (function () {\n    /**\n     * @param bitMatrix {@link BitMatrix} to parse\n     * @throws FormatException if dimension is not >= 21 and 1 mod 4\n     */\n    function BitMatrixParser(bitMatrix) {\n        var dimension = bitMatrix.getHeight();\n        if (dimension < 21 || (dimension & 0x03) !== 1) {\n            throw new FormatException_1.default();\n        }\n        this.bitMatrix = bitMatrix;\n    }\n    /**\n     * <p>Reads format information from one of its two locations within the QR Code.</p>\n     *\n     * @return {@link FormatInformation} encapsulating the QR Code's format info\n     * @throws FormatException if both format information locations cannot be parsed as\n     * the valid encoding of format information\n     */\n    BitMatrixParser.prototype.readFormatInformation = function () {\n        if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {\n            return this.parsedFormatInfo;\n        }\n        // Read top-left format info bits\n        var formatInfoBits1 = 0;\n        for (var i = 0; i < 6; i++) {\n            formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);\n        }\n        // .. and skip a bit in the timing pattern ...\n        formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);\n        formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);\n        formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);\n        // .. and skip a bit in the timing pattern ...\n        for (var j = 5; j >= 0; j--) {\n            formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);\n        }\n        // Read the top-right/bottom-left pattern too\n        var dimension = this.bitMatrix.getHeight();\n        var formatInfoBits2 = 0;\n        var jMin = dimension - 7;\n        for (var j = dimension - 1; j >= jMin; j--) {\n            formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);\n        }\n        for (var i = dimension - 8; i < dimension; i++) {\n            formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);\n        }\n        this.parsedFormatInfo = FormatInformation_1.default.decodeFormatInformation(formatInfoBits1, formatInfoBits2);\n        if (this.parsedFormatInfo !== null) {\n            return this.parsedFormatInfo;\n        }\n        throw new FormatException_1.default();\n    };\n    /**\n     * <p>Reads version information from one of its two locations within the QR Code.</p>\n     *\n     * @return {@link Version} encapsulating the QR Code's version\n     * @throws FormatException if both version information locations cannot be parsed as\n     * the valid encoding of version information\n     */\n    BitMatrixParser.prototype.readVersion = function () {\n        if (this.parsedVersion !== null && this.parsedVersion !== undefined) {\n            return this.parsedVersion;\n        }\n        var dimension = this.bitMatrix.getHeight();\n        var provisionalVersion = Math.floor((dimension - 17) / 4);\n        if (provisionalVersion <= 6) {\n            return Version_1.default.getVersionForNumber(provisionalVersion);\n        }\n        // Read top-right version info: 3 wide by 6 tall\n        var versionBits = 0;\n        var ijMin = dimension - 11;\n        for (var j = 5; j >= 0; j--) {\n            for (var i = dimension - 9; i >= ijMin; i--) {\n                versionBits = this.copyBit(i, j, versionBits);\n            }\n        }\n        var theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n            this.parsedVersion = theParsedVersion;\n            return theParsedVersion;\n        }\n        // Hmm, failed. Try bottom left: 6 wide by 3 tall\n        versionBits = 0;\n        for (var i = 5; i >= 0; i--) {\n            for (var j = dimension - 9; j >= ijMin; j--) {\n                versionBits = this.copyBit(i, j, versionBits);\n            }\n        }\n        theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n            this.parsedVersion = theParsedVersion;\n            return theParsedVersion;\n        }\n        throw new FormatException_1.default();\n    };\n    BitMatrixParser.prototype.copyBit = function (i /*int*/, j /*int*/, versionBits /*int*/) {\n        var bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);\n        return bit ? (versionBits << 1) | 0x1 : versionBits << 1;\n    };\n    /**\n     * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the\n     * correct order in order to reconstruct the codewords bytes contained within the\n     * QR Code.</p>\n     *\n     * @return bytes encoded within the QR Code\n     * @throws FormatException if the exact number of bytes expected is not read\n     */\n    BitMatrixParser.prototype.readCodewords = function () {\n        var formatInfo = this.readFormatInformation();\n        var version = this.readVersion();\n        // Get the data mask for the format used in this QR Code. This will exclude\n        // some bits from reading as we wind through the bit matrix.\n        var dataMask = DataMask_1.default.values.get(formatInfo.getDataMask());\n        var dimension = this.bitMatrix.getHeight();\n        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n        var functionPattern = version.buildFunctionPattern();\n        var readingUp = true;\n        var result = new Uint8Array(version.getTotalCodewords());\n        var resultOffset = 0;\n        var currentByte = 0;\n        var bitsRead = 0;\n        // Read columns in pairs, from right to left\n        for (var j = dimension - 1; j > 0; j -= 2) {\n            if (j === 6) {\n                // Skip whole column with vertical alignment pattern\n                // saves time and makes the other code proceed more cleanly\n                j--;\n            }\n            // Read alternatingly from bottom to top then top to bottom\n            for (var count = 0; count < dimension; count++) {\n                var i = readingUp ? dimension - 1 - count : count;\n                for (var col = 0; col < 2; col++) {\n                    // Ignore bits covered by the function pattern\n                    if (!functionPattern.get(j - col, i)) {\n                        // Read a bit\n                        bitsRead++;\n                        currentByte <<= 1;\n                        if (this.bitMatrix.get(j - col, i)) {\n                            currentByte |= 1;\n                        }\n                        // If we've made a whole byte, save it off\n                        if (bitsRead === 8) {\n                            result[resultOffset++] = /*(byte) */ currentByte;\n                            bitsRead = 0;\n                            currentByte = 0;\n                        }\n                    }\n                }\n            }\n            readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions\n        }\n        if (resultOffset !== version.getTotalCodewords()) {\n            throw new FormatException_1.default();\n        }\n        return result;\n    };\n    /**\n     * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.\n     */\n    BitMatrixParser.prototype.remask = function () {\n        if (this.parsedFormatInfo === null) {\n            return; // We have no format information, and have no data mask\n        }\n        var dataMask = DataMask_1.default.values[this.parsedFormatInfo.getDataMask()];\n        var dimension = this.bitMatrix.getHeight();\n        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n    };\n    /**\n     * Prepare the parser for a mirrored operation.\n     * This flag has effect only on the {@link #readFormatInformation()} and the\n     * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the\n     * {@link #mirror()} method should be called.\n     *\n     * @param mirror Whether to read version and format information mirrored.\n     */\n    BitMatrixParser.prototype.setMirror = function (isMirror) {\n        this.parsedVersion = null;\n        this.parsedFormatInfo = null;\n        this.isMirror = isMirror;\n    };\n    /** Mirror the bit matrix in order to attempt a second reading. */\n    BitMatrixParser.prototype.mirror = function () {\n        var bitMatrix = this.bitMatrix;\n        for (var x = 0, width = bitMatrix.getWidth(); x < width; x++) {\n            for (var y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {\n                if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {\n                    bitMatrix.flip(y, x);\n                    bitMatrix.flip(x, y);\n                }\n            }\n        }\n    };\n    return BitMatrixParser;\n}());\nexports.default = BitMatrixParser;\n//# sourceMappingURL=BitMatrixParser.js.map"]},"metadata":{},"sourceType":"script"}