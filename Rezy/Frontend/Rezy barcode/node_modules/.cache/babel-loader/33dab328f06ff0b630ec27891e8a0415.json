{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n    i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will\n * use blocks of differing sizes within one version, so, this encapsulates the parameters for\n * each set of blocks. It also holds the number of error-correction codewords per block since it\n * will be the same across all blocks within one version.</p>\n */\nvar ECBlocks = /** @class */function () {\n  function ECBlocks(ecCodewordsPerBlock /*int*/) {\n    var ecBlocks = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      ecBlocks[_i - 1] = arguments[_i];\n    }\n    this.ecCodewordsPerBlock = ecCodewordsPerBlock;\n    this.ecBlocks = ecBlocks;\n  }\n  ECBlocks.prototype.getECCodewordsPerBlock = function () {\n    return this.ecCodewordsPerBlock;\n  };\n  ECBlocks.prototype.getNumBlocks = function () {\n    var e_1, _a;\n    var total = 0;\n    var ecBlocks = this.ecBlocks;\n    try {\n      for (var ecBlocks_1 = __values(ecBlocks), ecBlocks_1_1 = ecBlocks_1.next(); !ecBlocks_1_1.done; ecBlocks_1_1 = ecBlocks_1.next()) {\n        var ecBlock = ecBlocks_1_1.value;\n        total += ecBlock.getCount();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (ecBlocks_1_1 && !ecBlocks_1_1.done && (_a = ecBlocks_1.return)) _a.call(ecBlocks_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return total;\n  };\n  ECBlocks.prototype.getTotalECCodewords = function () {\n    return this.ecCodewordsPerBlock * this.getNumBlocks();\n  };\n  ECBlocks.prototype.getECBlocks = function () {\n    return this.ecBlocks;\n  };\n  return ECBlocks;\n}();\nexports.default = ECBlocks;","map":{"version":3,"names":["ECBlocks","ecCodewordsPerBlock","ecBlocks","_i","arguments","length","prototype","getECCodewordsPerBlock","getNumBlocks","total","ecBlocks_1","__values","ecBlocks_1_1","next","done","ecBlock","value","getCount","getTotalECCodewords","getECBlocks"],"sources":["../../../../src/core/qrcode/decoder/ECBlocks.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;AAEA;;;;;;AAMA,IAAAA,QAAA;EAGI,SAAAA,SAA2BC,mBAA2B,CAAC,SAAO;IAAE,IAAAC,QAAA;SAAA,IAAAC,EAAA,IAAkB,EAAlBA,EAAA,GAAAC,SAAA,CAAAC,MAAkB,EAAlBF,EAAA,EAAkB;MAAlBD,QAAA,CAAAC,EAAA,QAAAC,SAAA,CAAAD,EAAA;;IAArC,KAAAF,mBAAmB,GAAnBA,mBAAmB;IAC1C,IAAI,CAACC,QAAQ,GAAGA,QAAQ;EAC5B;EAEOF,QAAA,CAAAM,SAAA,CAAAC,sBAAsB,GAA7B;IACI,OAAO,IAAI,CAACN,mBAAmB;EACnC,CAAC;EAEMD,QAAA,CAAAM,SAAA,CAAAE,YAAY,GAAnB;;IACI,IAAIC,KAAK,GAAG,CAAC;IACb,IAAMP,QAAQ,GAAG,IAAI,CAACA,QAAQ;;MAC9B,KAAsB,IAAAQ,UAAA,GAAAC,QAAA,CAAAT,QAAQ,GAAAU,YAAA,GAAAF,UAAA,CAAAG,IAAA,KAAAD,YAAA,CAAAE,IAAA,EAAAF,YAAA,GAAAF,UAAA,CAAAG,IAAA,IAAE;QAA3B,IAAME,OAAO,GAAAH,YAAA,CAAAI,KAAA;QACdP,KAAK,IAAIM,OAAO,CAACE,QAAQ,EAAE;;;;;;;;;;;;;IAE/B,OAAOR,KAAK;EAChB,CAAC;EAEMT,QAAA,CAAAM,SAAA,CAAAY,mBAAmB,GAA1B;IACI,OAAO,IAAI,CAACjB,mBAAmB,GAAG,IAAI,CAACO,YAAY,EAAE;EACzD,CAAC;EAEMR,QAAA,CAAAM,SAAA,CAAAa,WAAW,GAAlB;IACI,OAAO,IAAI,CAACjB,QAAQ;EACxB,CAAC;EACL,OAAAF,QAAC;AAAD,CAAC,EA3BD"},"metadata":{},"sourceType":"script"}