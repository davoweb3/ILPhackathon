{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\nvar ModeValues;\n(function (ModeValues) {\n  ModeValues[ModeValues[\"TERMINATOR\"] = 0] = \"TERMINATOR\";\n  ModeValues[ModeValues[\"NUMERIC\"] = 1] = \"NUMERIC\";\n  ModeValues[ModeValues[\"ALPHANUMERIC\"] = 2] = \"ALPHANUMERIC\";\n  ModeValues[ModeValues[\"STRUCTURED_APPEND\"] = 3] = \"STRUCTURED_APPEND\";\n  ModeValues[ModeValues[\"BYTE\"] = 4] = \"BYTE\";\n  ModeValues[ModeValues[\"ECI\"] = 5] = \"ECI\";\n  ModeValues[ModeValues[\"KANJI\"] = 6] = \"KANJI\";\n  ModeValues[ModeValues[\"FNC1_FIRST_POSITION\"] = 7] = \"FNC1_FIRST_POSITION\";\n  ModeValues[ModeValues[\"FNC1_SECOND_POSITION\"] = 8] = \"FNC1_SECOND_POSITION\";\n  /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\n  ModeValues[ModeValues[\"HANZI\"] = 9] = \"HANZI\";\n})(ModeValues = exports.ModeValues || (exports.ModeValues = {}));\n/**\n * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which\n * data can be encoded to bits in the QR code standard.</p>\n *\n * @author Sean Owen\n */\nvar Mode = /** @class */function () {\n  function Mode(value, stringValue, characterCountBitsForVersions, bits /*int*/) {\n    this.value = value;\n    this.stringValue = stringValue;\n    this.characterCountBitsForVersions = characterCountBitsForVersions;\n    this.bits = bits;\n    Mode.FOR_BITS.set(bits, this);\n    Mode.FOR_VALUE.set(value, this);\n  }\n  /**\n   * @param bits four bits encoding a QR Code data mode\n   * @return Mode encoded by these bits\n   * @throws IllegalArgumentException if bits do not correspond to a known mode\n   */\n  Mode.forBits = function (bits /*int*/) {\n    var mode = Mode.FOR_BITS.get(bits);\n    if (undefined === mode) {\n      throw new IllegalArgumentException_1.default();\n    }\n    return mode;\n  };\n  /**\n   * @param version version in question\n   * @return number of bits used, in this QR Code symbol {@link Version}, to encode the\n   *         count of characters that will follow encoded in this Mode\n   */\n  Mode.prototype.getCharacterCountBits = function (version) {\n    var versionNumber = version.getVersionNumber();\n    var offset;\n    if (versionNumber <= 9) {\n      offset = 0;\n    } else if (versionNumber <= 26) {\n      offset = 1;\n    } else {\n      offset = 2;\n    }\n    return this.characterCountBitsForVersions[offset];\n  };\n  Mode.prototype.getValue = function () {\n    return this.value;\n  };\n  Mode.prototype.getBits = function () {\n    return this.bits;\n  };\n  Mode.prototype.equals = function (o) {\n    if (!(o instanceof Mode)) {\n      return false;\n    }\n    var other = o;\n    return this.value === other.value;\n  };\n  Mode.prototype.toString = function () {\n    return this.stringValue;\n  };\n  Mode.FOR_BITS = new Map();\n  Mode.FOR_VALUE = new Map();\n  Mode.TERMINATOR = new Mode(ModeValues.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0x00); // Not really a mode...\n  Mode.NUMERIC = new Mode(ModeValues.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 0x01);\n  Mode.ALPHANUMERIC = new Mode(ModeValues.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 0x02);\n  Mode.STRUCTURED_APPEND = new Mode(ModeValues.STRUCTURED_APPEND, 'STRUCTURED_APPEND', Int32Array.from([0, 0, 0]), 0x03); // Not supported\n  Mode.BYTE = new Mode(ModeValues.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 0x04);\n  Mode.ECI = new Mode(ModeValues.ECI, 'ECI', Int32Array.from([0, 0, 0]), 0x07); // character counts don't apply\n  Mode.KANJI = new Mode(ModeValues.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 0x08);\n  Mode.FNC1_FIRST_POSITION = new Mode(ModeValues.FNC1_FIRST_POSITION, 'FNC1_FIRST_POSITION', Int32Array.from([0, 0, 0]), 0x05);\n  Mode.FNC1_SECOND_POSITION = new Mode(ModeValues.FNC1_SECOND_POSITION, 'FNC1_SECOND_POSITION', Int32Array.from([0, 0, 0]), 0x09);\n  /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\n  Mode.HANZI = new Mode(ModeValues.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 0x0D);\n  return Mode;\n}();\nexports.default = Mode;","map":{"version":3,"sources":["../../../../src/core/qrcode/decoder/Mode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\nvar ModeValues;\n(function (ModeValues) {\n    ModeValues[ModeValues[\"TERMINATOR\"] = 0] = \"TERMINATOR\";\n    ModeValues[ModeValues[\"NUMERIC\"] = 1] = \"NUMERIC\";\n    ModeValues[ModeValues[\"ALPHANUMERIC\"] = 2] = \"ALPHANUMERIC\";\n    ModeValues[ModeValues[\"STRUCTURED_APPEND\"] = 3] = \"STRUCTURED_APPEND\";\n    ModeValues[ModeValues[\"BYTE\"] = 4] = \"BYTE\";\n    ModeValues[ModeValues[\"ECI\"] = 5] = \"ECI\";\n    ModeValues[ModeValues[\"KANJI\"] = 6] = \"KANJI\";\n    ModeValues[ModeValues[\"FNC1_FIRST_POSITION\"] = 7] = \"FNC1_FIRST_POSITION\";\n    ModeValues[ModeValues[\"FNC1_SECOND_POSITION\"] = 8] = \"FNC1_SECOND_POSITION\";\n    /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\n    ModeValues[ModeValues[\"HANZI\"] = 9] = \"HANZI\";\n})(ModeValues = exports.ModeValues || (exports.ModeValues = {}));\n/**\n * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which\n * data can be encoded to bits in the QR code standard.</p>\n *\n * @author Sean Owen\n */\nvar Mode = /** @class */ (function () {\n    function Mode(value, stringValue, characterCountBitsForVersions, bits /*int*/) {\n        this.value = value;\n        this.stringValue = stringValue;\n        this.characterCountBitsForVersions = characterCountBitsForVersions;\n        this.bits = bits;\n        Mode.FOR_BITS.set(bits, this);\n        Mode.FOR_VALUE.set(value, this);\n    }\n    /**\n     * @param bits four bits encoding a QR Code data mode\n     * @return Mode encoded by these bits\n     * @throws IllegalArgumentException if bits do not correspond to a known mode\n     */\n    Mode.forBits = function (bits /*int*/) {\n        var mode = Mode.FOR_BITS.get(bits);\n        if (undefined === mode) {\n            throw new IllegalArgumentException_1.default();\n        }\n        return mode;\n    };\n    /**\n     * @param version version in question\n     * @return number of bits used, in this QR Code symbol {@link Version}, to encode the\n     *         count of characters that will follow encoded in this Mode\n     */\n    Mode.prototype.getCharacterCountBits = function (version) {\n        var versionNumber = version.getVersionNumber();\n        var offset;\n        if (versionNumber <= 9) {\n            offset = 0;\n        }\n        else if (versionNumber <= 26) {\n            offset = 1;\n        }\n        else {\n            offset = 2;\n        }\n        return this.characterCountBitsForVersions[offset];\n    };\n    Mode.prototype.getValue = function () {\n        return this.value;\n    };\n    Mode.prototype.getBits = function () {\n        return this.bits;\n    };\n    Mode.prototype.equals = function (o) {\n        if (!(o instanceof Mode)) {\n            return false;\n        }\n        var other = o;\n        return this.value === other.value;\n    };\n    Mode.prototype.toString = function () {\n        return this.stringValue;\n    };\n    Mode.FOR_BITS = new Map();\n    Mode.FOR_VALUE = new Map();\n    Mode.TERMINATOR = new Mode(ModeValues.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0x00); // Not really a mode...\n    Mode.NUMERIC = new Mode(ModeValues.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 0x01);\n    Mode.ALPHANUMERIC = new Mode(ModeValues.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 0x02);\n    Mode.STRUCTURED_APPEND = new Mode(ModeValues.STRUCTURED_APPEND, 'STRUCTURED_APPEND', Int32Array.from([0, 0, 0]), 0x03); // Not supported\n    Mode.BYTE = new Mode(ModeValues.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 0x04);\n    Mode.ECI = new Mode(ModeValues.ECI, 'ECI', Int32Array.from([0, 0, 0]), 0x07); // character counts don't apply\n    Mode.KANJI = new Mode(ModeValues.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 0x08);\n    Mode.FNC1_FIRST_POSITION = new Mode(ModeValues.FNC1_FIRST_POSITION, 'FNC1_FIRST_POSITION', Int32Array.from([0, 0, 0]), 0x05);\n    Mode.FNC1_SECOND_POSITION = new Mode(ModeValues.FNC1_SECOND_POSITION, 'FNC1_SECOND_POSITION', Int32Array.from([0, 0, 0]), 0x09);\n    /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\n    Mode.HANZI = new Mode(ModeValues.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 0x0D);\n    return Mode;\n}());\nexports.default = Mode;\n//# sourceMappingURL=Mode.js.map"]},"metadata":{},"sourceType":"script"}