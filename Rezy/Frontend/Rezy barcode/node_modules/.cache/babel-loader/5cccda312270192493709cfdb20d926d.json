{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BitArray_1 = require(\"../common/BitArray\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\nvar ResultPoint_1 = require(\"../ResultPoint\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\n * Encapsulates functionality and implementation that is common to all families\n * of one-dimensional barcodes.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\nvar OneDReader = /** @class */function () {\n  function OneDReader() {}\n  /*\n  @Override\n  public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {\n    return decode(image, null);\n  }\n  */\n  // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n  // @Override\n  OneDReader.prototype.decode = function (image, hints) {\n    try {\n      return this.doDecode(image, hints);\n    } catch (nfe) {\n      var tryHarder = hints && hints.get(DecodeHintType_1.default.TRY_HARDER) === true;\n      if (tryHarder && image.isRotateSupported()) {\n        var rotatedImage = image.rotateCounterClockwise();\n        var result = this.doDecode(rotatedImage, hints);\n        // Record that we found it rotated 90 degrees CCW / 270 degrees CW\n        var metadata = result.getResultMetadata();\n        var orientation_1 = 270;\n        if (metadata !== null && metadata.get(ResultMetadataType_1.default.ORIENTATION) === true) {\n          // But if we found it reversed in doDecode(), add in that result here:\n          orientation_1 = orientation_1 + metadata.get(ResultMetadataType_1.default.ORIENTATION) % 360;\n        }\n        result.putMetadata(ResultMetadataType_1.default.ORIENTATION, orientation_1);\n        // Update result points\n        var points = result.getResultPoints();\n        if (points !== null) {\n          var height = rotatedImage.getHeight();\n          for (var i = 0; i < points.length; i++) {\n            points[i] = new ResultPoint_1.default(height - points[i].getY() - 1, points[i].getX());\n          }\n        }\n        return result;\n      } else {\n        throw new NotFoundException_1.default();\n      }\n    }\n  };\n  // @Override\n  OneDReader.prototype.reset = function () {\n    // do nothing\n  };\n  /**\n   * We're going to examine rows from the middle outward, searching alternately above and below the\n   * middle, and farther out each time. rowStep is the number of rows between each successive\n   * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then\n   * middle + rowStep, then middle - (2 * rowStep), etc.\n   * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily\n   * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the\n   * image if \"trying harder\".\n   *\n   * @param image The image to decode\n   * @param hints Any hints that were requested\n   * @return The contents of the decoded barcode\n   * @throws NotFoundException Any spontaneous errors which occur\n   */\n  OneDReader.prototype.doDecode = function (image, hints) {\n    var width = image.getWidth();\n    var height = image.getHeight();\n    var row = new BitArray_1.default(width);\n    var tryHarder = hints && hints.get(DecodeHintType_1.default.TRY_HARDER) === true;\n    var rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));\n    var maxLines;\n    if (tryHarder) {\n      maxLines = height; // Look at the whole image, not just the center\n    } else {\n      maxLines = 15; // 15 rows spaced 1/32 apart is roughly the middle half of the image\n    }\n\n    var middle = Math.trunc(height / 2);\n    for (var x = 0; x < maxLines; x++) {\n      // Scanning from the middle out. Determine which row we're looking at next:\n      var rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);\n      var isAbove = (x & 0x01) === 0; // i.e. is x even?\n      var rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);\n      if (rowNumber < 0 || rowNumber >= height) {\n        // Oops, if we run off the top or bottom, stop\n        break;\n      }\n      // Estimate black point for this row and load it:\n      try {\n        row = image.getBlackRow(rowNumber, row);\n      } catch (ignored) {\n        continue;\n      }\n      var _loop_1 = function (attempt) {\n        if (attempt === 1) {\n          // trying again?\n          row.reverse(); // reverse the row and continue\n          // This means we will only ever draw result points *once* in the life of this method\n          // since we want to avoid drawing the wrong points after flipping the row, and,\n          // don't want to clutter with noise from every single row scan -- just the scans\n          // that start on the center line.\n          if (hints && hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK) === true) {\n            var newHints_1 = new Map();\n            hints.forEach(function (hint, key) {\n              return newHints_1.set(key, hint);\n            });\n            newHints_1.delete(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n            hints = newHints_1;\n          }\n        }\n        try {\n          // Look for a barcode\n          var result = this_1.decodeRow(rowNumber, row, hints);\n          // We found our barcode\n          if (attempt === 1) {\n            // But it was upside down, so note that\n            result.putMetadata(ResultMetadataType_1.default.ORIENTATION, 180);\n            // And remember to flip the result points horizontally.\n            var points = result.getResultPoints();\n            if (points !== null) {\n              points[0] = new ResultPoint_1.default(width - points[0].getX() - 1, points[0].getY());\n              points[1] = new ResultPoint_1.default(width - points[1].getX() - 1, points[1].getY());\n            }\n          }\n          return {\n            value: result\n          };\n        } catch (re) {\n          // continue -- just couldn't decode this row\n        }\n      };\n      var this_1 = this;\n      // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to\n      // handle decoding upside down barcodes.\n      for (var attempt = 0; attempt < 2; attempt++) {\n        var state_1 = _loop_1(attempt);\n        if (typeof state_1 === \"object\") return state_1.value;\n      }\n    }\n    throw new NotFoundException_1.default();\n  };\n  /**\n   * Records the size of successive runs of white and black pixels in a row, starting at a given point.\n   * The values are recorded in the given array, and the number of runs recorded is equal to the size\n   * of the array. If the row starts on a white pixel at the given start point, then the first count\n   * recorded is the run of white pixels starting from that point; likewise it is the count of a run\n   * of black pixels if the row begin on a black pixels at that point.\n   *\n   * @param row row to count from\n   * @param start offset into row to start at\n   * @param counters array into which to record counts\n   * @throws NotFoundException if counters cannot be filled entirely from row before running out\n   *  of pixels\n   */\n  OneDReader.recordPattern = function (row, start, counters) {\n    var numCounters = counters.length;\n    for (var index = 0; index < numCounters; index++) counters[index] = 0;\n    var end = row.getSize();\n    if (start >= end) {\n      throw new NotFoundException_1.default();\n    }\n    var isWhite = !row.get(start);\n    var counterPosition = 0;\n    var i = start;\n    while (i < end) {\n      if (row.get(i) !== isWhite) {\n        counters[counterPosition]++;\n      } else {\n        if (++counterPosition === numCounters) {\n          break;\n        } else {\n          counters[counterPosition] = 1;\n          isWhite = !isWhite;\n        }\n      }\n      i++;\n    }\n    // If we read fully the last section of pixels and filled up our counters -- or filled\n    // the last counter but ran off the side of the image, OK. Otherwise, a problem.\n    if (!(counterPosition === numCounters || counterPosition === numCounters - 1 && i === end)) {\n      throw new NotFoundException_1.default();\n    }\n  };\n  OneDReader.recordPatternInReverse = function (row, start, counters) {\n    // This could be more efficient I guess\n    var numTransitionsLeft = counters.length;\n    var last = row.get(start);\n    while (start > 0 && numTransitionsLeft >= 0) {\n      if (row.get(--start) !== last) {\n        numTransitionsLeft--;\n        last = !last;\n      }\n    }\n    if (numTransitionsLeft >= 0) {\n      throw new NotFoundException_1.default();\n    }\n    OneDReader.recordPattern(row, start + 1, counters);\n  };\n  /**\n   * Determines how closely a set of observed counts of runs of black/white values matches a given\n   * target pattern. This is reported as the ratio of the total variance from the expected pattern\n   * proportions across all pattern elements, to the length of the pattern.\n   *\n   * @param counters observed counters\n   * @param pattern expected pattern\n   * @param maxIndividualVariance The most any counter can differ before we give up\n   * @return ratio of total variance between counters and pattern compared to total pattern size\n   */\n  OneDReader.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {\n    var numCounters = counters.length;\n    var total = 0;\n    var patternLength = 0;\n    for (var i = 0; i < numCounters; i++) {\n      total += counters[i];\n      patternLength += pattern[i];\n    }\n    if (total < patternLength) {\n      // If we don't even have one pixel per unit of bar width, assume this is too small\n      // to reliably match, so fail:\n      return Number.POSITIVE_INFINITY;\n    }\n    var unitBarWidth = total / patternLength;\n    maxIndividualVariance *= unitBarWidth;\n    var totalVariance = 0.0;\n    for (var x = 0; x < numCounters; x++) {\n      var counter = counters[x];\n      var scaledPattern = pattern[x] * unitBarWidth;\n      var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n      if (variance > maxIndividualVariance) {\n        return Number.POSITIVE_INFINITY;\n      }\n      totalVariance += variance;\n    }\n    return totalVariance / total;\n  };\n  return OneDReader;\n}();\nexports.default = OneDReader;","map":{"version":3,"sources":["../../../src/core/oned/OneDReader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BitArray_1 = require(\"../common/BitArray\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\nvar ResultPoint_1 = require(\"../ResultPoint\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\n * Encapsulates functionality and implementation that is common to all families\n * of one-dimensional barcodes.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\nvar OneDReader = /** @class */ (function () {\n    function OneDReader() {\n    }\n    /*\n    @Override\n    public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {\n      return decode(image, null);\n    }\n    */\n    // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n    // @Override\n    OneDReader.prototype.decode = function (image, hints) {\n        try {\n            return this.doDecode(image, hints);\n        }\n        catch (nfe) {\n            var tryHarder = hints && (hints.get(DecodeHintType_1.default.TRY_HARDER) === true);\n            if (tryHarder && image.isRotateSupported()) {\n                var rotatedImage = image.rotateCounterClockwise();\n                var result = this.doDecode(rotatedImage, hints);\n                // Record that we found it rotated 90 degrees CCW / 270 degrees CW\n                var metadata = result.getResultMetadata();\n                var orientation_1 = 270;\n                if (metadata !== null && (metadata.get(ResultMetadataType_1.default.ORIENTATION) === true)) {\n                    // But if we found it reversed in doDecode(), add in that result here:\n                    orientation_1 = (orientation_1 + metadata.get(ResultMetadataType_1.default.ORIENTATION) % 360);\n                }\n                result.putMetadata(ResultMetadataType_1.default.ORIENTATION, orientation_1);\n                // Update result points\n                var points = result.getResultPoints();\n                if (points !== null) {\n                    var height = rotatedImage.getHeight();\n                    for (var i = 0; i < points.length; i++) {\n                        points[i] = new ResultPoint_1.default(height - points[i].getY() - 1, points[i].getX());\n                    }\n                }\n                return result;\n            }\n            else {\n                throw new NotFoundException_1.default();\n            }\n        }\n    };\n    // @Override\n    OneDReader.prototype.reset = function () {\n        // do nothing\n    };\n    /**\n     * We're going to examine rows from the middle outward, searching alternately above and below the\n     * middle, and farther out each time. rowStep is the number of rows between each successive\n     * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then\n     * middle + rowStep, then middle - (2 * rowStep), etc.\n     * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily\n     * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the\n     * image if \"trying harder\".\n     *\n     * @param image The image to decode\n     * @param hints Any hints that were requested\n     * @return The contents of the decoded barcode\n     * @throws NotFoundException Any spontaneous errors which occur\n     */\n    OneDReader.prototype.doDecode = function (image, hints) {\n        var width = image.getWidth();\n        var height = image.getHeight();\n        var row = new BitArray_1.default(width);\n        var tryHarder = hints && (hints.get(DecodeHintType_1.default.TRY_HARDER) === true);\n        var rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));\n        var maxLines;\n        if (tryHarder) {\n            maxLines = height; // Look at the whole image, not just the center\n        }\n        else {\n            maxLines = 15; // 15 rows spaced 1/32 apart is roughly the middle half of the image\n        }\n        var middle = Math.trunc(height / 2);\n        for (var x = 0; x < maxLines; x++) {\n            // Scanning from the middle out. Determine which row we're looking at next:\n            var rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);\n            var isAbove = (x & 0x01) === 0; // i.e. is x even?\n            var rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);\n            if (rowNumber < 0 || rowNumber >= height) {\n                // Oops, if we run off the top or bottom, stop\n                break;\n            }\n            // Estimate black point for this row and load it:\n            try {\n                row = image.getBlackRow(rowNumber, row);\n            }\n            catch (ignored) {\n                continue;\n            }\n            var _loop_1 = function (attempt) {\n                if (attempt === 1) { // trying again?\n                    row.reverse(); // reverse the row and continue\n                    // This means we will only ever draw result points *once* in the life of this method\n                    // since we want to avoid drawing the wrong points after flipping the row, and,\n                    // don't want to clutter with noise from every single row scan -- just the scans\n                    // that start on the center line.\n                    if (hints && (hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK) === true)) {\n                        var newHints_1 = new Map();\n                        hints.forEach(function (hint, key) { return newHints_1.set(key, hint); });\n                        newHints_1.delete(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n                        hints = newHints_1;\n                    }\n                }\n                try {\n                    // Look for a barcode\n                    var result = this_1.decodeRow(rowNumber, row, hints);\n                    // We found our barcode\n                    if (attempt === 1) {\n                        // But it was upside down, so note that\n                        result.putMetadata(ResultMetadataType_1.default.ORIENTATION, 180);\n                        // And remember to flip the result points horizontally.\n                        var points = result.getResultPoints();\n                        if (points !== null) {\n                            points[0] = new ResultPoint_1.default(width - points[0].getX() - 1, points[0].getY());\n                            points[1] = new ResultPoint_1.default(width - points[1].getX() - 1, points[1].getY());\n                        }\n                    }\n                    return { value: result };\n                }\n                catch (re) {\n                    // continue -- just couldn't decode this row\n                }\n            };\n            var this_1 = this;\n            // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to\n            // handle decoding upside down barcodes.\n            for (var attempt = 0; attempt < 2; attempt++) {\n                var state_1 = _loop_1(attempt);\n                if (typeof state_1 === \"object\")\n                    return state_1.value;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    /**\n     * Records the size of successive runs of white and black pixels in a row, starting at a given point.\n     * The values are recorded in the given array, and the number of runs recorded is equal to the size\n     * of the array. If the row starts on a white pixel at the given start point, then the first count\n     * recorded is the run of white pixels starting from that point; likewise it is the count of a run\n     * of black pixels if the row begin on a black pixels at that point.\n     *\n     * @param row row to count from\n     * @param start offset into row to start at\n     * @param counters array into which to record counts\n     * @throws NotFoundException if counters cannot be filled entirely from row before running out\n     *  of pixels\n     */\n    OneDReader.recordPattern = function (row, start, counters) {\n        var numCounters = counters.length;\n        for (var index = 0; index < numCounters; index++)\n            counters[index] = 0;\n        var end = row.getSize();\n        if (start >= end) {\n            throw new NotFoundException_1.default();\n        }\n        var isWhite = !row.get(start);\n        var counterPosition = 0;\n        var i = start;\n        while (i < end) {\n            if (row.get(i) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (++counterPosition === numCounters) {\n                    break;\n                }\n                else {\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            i++;\n        }\n        // If we read fully the last section of pixels and filled up our counters -- or filled\n        // the last counter but ran off the side of the image, OK. Otherwise, a problem.\n        if (!(counterPosition === numCounters || (counterPosition === numCounters - 1 && i === end))) {\n            throw new NotFoundException_1.default();\n        }\n    };\n    OneDReader.recordPatternInReverse = function (row, start, counters) {\n        // This could be more efficient I guess\n        var numTransitionsLeft = counters.length;\n        var last = row.get(start);\n        while (start > 0 && numTransitionsLeft >= 0) {\n            if (row.get(--start) !== last) {\n                numTransitionsLeft--;\n                last = !last;\n            }\n        }\n        if (numTransitionsLeft >= 0) {\n            throw new NotFoundException_1.default();\n        }\n        OneDReader.recordPattern(row, start + 1, counters);\n    };\n    /**\n     * Determines how closely a set of observed counts of runs of black/white values matches a given\n     * target pattern. This is reported as the ratio of the total variance from the expected pattern\n     * proportions across all pattern elements, to the length of the pattern.\n     *\n     * @param counters observed counters\n     * @param pattern expected pattern\n     * @param maxIndividualVariance The most any counter can differ before we give up\n     * @return ratio of total variance between counters and pattern compared to total pattern size\n     */\n    OneDReader.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {\n        var numCounters = counters.length;\n        var total = 0;\n        var patternLength = 0;\n        for (var i = 0; i < numCounters; i++) {\n            total += counters[i];\n            patternLength += pattern[i];\n        }\n        if (total < patternLength) {\n            // If we don't even have one pixel per unit of bar width, assume this is too small\n            // to reliably match, so fail:\n            return Number.POSITIVE_INFINITY;\n        }\n        var unitBarWidth = total / patternLength;\n        maxIndividualVariance *= unitBarWidth;\n        var totalVariance = 0.0;\n        for (var x = 0; x < numCounters; x++) {\n            var counter = counters[x];\n            var scaledPattern = pattern[x] * unitBarWidth;\n            var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n            if (variance > maxIndividualVariance) {\n                return Number.POSITIVE_INFINITY;\n            }\n            totalVariance += variance;\n        }\n        return totalVariance / total;\n    };\n    return OneDReader;\n}());\nexports.default = OneDReader;\n//# sourceMappingURL=OneDReader.js.map"]},"metadata":{},"sourceType":"script"}