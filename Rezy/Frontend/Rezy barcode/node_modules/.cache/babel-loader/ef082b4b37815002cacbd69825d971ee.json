{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ResultPoint_1 = require(\"../../ResultPoint\");\nvar AztecDetectorResult_1 = require(\"../AztecDetectorResult\");\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\");\nvar WhiteRectangleDetector_1 = require(\"../../common/detector/WhiteRectangleDetector\");\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\nvar NotFoundException_1 = require(\"../../NotFoundException\");\nvar GridSamplerInstance_1 = require(\"../../common/GridSamplerInstance\");\nvar Integer_1 = require(\"../../util/Integer\");\nvar Point = /** @class */function () {\n  function Point(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  Point.prototype.toResultPoint = function () {\n    return new ResultPoint_1.default(this.getX(), this.getY());\n  };\n  Point.prototype.getX = function () {\n    return this.x;\n  };\n  Point.prototype.getY = function () {\n    return this.y;\n  };\n  return Point;\n}();\nexports.Point = Point;\n/**\n * Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code\n * is rotated or skewed, or partially obscured.\n *\n * @author David Olivier\n * @author Frank Yellin\n */\nvar Detector = /** @class */function () {\n  function Detector(image) {\n    this.EXPECTED_CORNER_BITS = new Int32Array([0xee0, 0x1dc, 0x83b, 0x707]);\n    this.image = image;\n  }\n  Detector.prototype.detect = function () {\n    return this.detectMirror(false);\n  };\n  /**\n   * Detects an Aztec Code in an image.\n   *\n   * @param isMirror if true, image is a mirror-image of original\n   * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code\n   * @throws NotFoundException if no Aztec Code can be found\n   */\n  Detector.prototype.detectMirror = function (isMirror) {\n    // 1. Get the center of the aztec matrix\n    var pCenter = this.getMatrixCenter();\n    // 2. Get the center points of the four diagonal points just outside the bull's eye\n    //  [topRight, bottomRight, bottomLeft, topLeft]\n    var bullsEyeCorners = this.getBullsEyeCorners(pCenter);\n    if (isMirror) {\n      var temp = bullsEyeCorners[0];\n      bullsEyeCorners[0] = bullsEyeCorners[2];\n      bullsEyeCorners[2] = temp;\n    }\n    // 3. Get the size of the matrix and other parameters from the bull's eye\n    this.extractParameters(bullsEyeCorners);\n    // 4. Sample the grid\n    var bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);\n    // 5. Get the corners of the matrix.\n    var corners = this.getMatrixCornerPoints(bullsEyeCorners);\n    return new AztecDetectorResult_1.default(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);\n  };\n  /**\n   * Extracts the number of data layers and data blocks from the layer around the bull's eye.\n   *\n   * @param bullsEyeCorners the array of bull's eye corners\n   * @throws NotFoundException in case of too many errors or invalid parameters\n   */\n  Detector.prototype.extractParameters = function (bullsEyeCorners) {\n    if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) || !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {\n      throw new NotFoundException_1.default();\n    }\n    var length = 2 * this.nbCenterLayers;\n    // Get the bits around the bull's eye\n    var sides = new Int32Array([this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length), this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length), this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length), this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) // Top\n    ]);\n    // bullsEyeCorners[shift] is the corner of the bulls'eye that has three\n    // orientation marks.\n    // sides[shift] is the row/column that goes from the corner with three\n    // orientation marks to the corner with two.\n    this.shift = this.getRotation(sides, length);\n    // Flatten the parameter bits into a single 28- or 40-bit long\n    var parameterData = 0;\n    for (var i = 0; i < 4; i++) {\n      var side = sides[(this.shift + i) % 4];\n      if (this.compact) {\n        // Each side of the form ..XXXXXXX. where Xs are parameter data\n        parameterData <<= 7;\n        parameterData += side >> 1 & 0x7F;\n      } else {\n        // Each side of the form ..XXXXX.XXXXX. where Xs are parameter data\n        parameterData <<= 10;\n        parameterData += (side >> 2 & 0x1f << 5) + (side >> 1 & 0x1F);\n      }\n    }\n    // Corrects parameter data using RS.  Returns just the data portion\n    // without the error correction.\n    var correctedData = this.getCorrectedParameterData(parameterData, this.compact);\n    if (this.compact) {\n      // 8 bits:  2 bits layers and 6 bits data blocks\n      this.nbLayers = (correctedData >> 6) + 1;\n      this.nbDataBlocks = (correctedData & 0x3F) + 1;\n    } else {\n      // 16 bits:  5 bits layers and 11 bits data blocks\n      this.nbLayers = (correctedData >> 11) + 1;\n      this.nbDataBlocks = (correctedData & 0x7FF) + 1;\n    }\n  };\n  Detector.prototype.getRotation = function (sides, length) {\n    // In a normal pattern, we expect to See\n    //   **    .*             D       A\n    //   *      *\n    //\n    //   .      *\n    //   ..    ..             C       B\n    //\n    // Grab the 3 bits from each of the sides the form the locator pattern and concatenate\n    // into a 12-bit integer.  Start with the bit at A\n    var cornerBits = 0;\n    sides.forEach(function (side, idx, arr) {\n      // XX......X where X's are orientation marks\n      var t = (side >> length - 2 << 1) + (side & 1);\n      cornerBits = (cornerBits << 3) + t;\n    });\n    // for (var side in sides) {\n    //     // XX......X where X's are orientation marks\n    //     var t = ((side >> (length - 2)) << 1) + (side & 1);\n    //     cornerBits = (cornerBits << 3) + t;\n    // }\n    // Mov the bottom bit to the top, so that the three bits of the locator pattern at A are\n    // together.  cornerBits is now:\n    //  3 orientation bits at A || 3 orientation bits at B || ... || 3 orientation bits at D\n    cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);\n    // The result shift indicates which element of BullsEyeCorners[] goes into the top-left\n    // corner. Since the four rotation values have a Hamming distance of 8, we\n    // can easily tolerate two errors.\n    for (var shift = 0; shift < 4; shift++) {\n      if (Integer_1.default.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {\n        return shift;\n      }\n    }\n    throw new NotFoundException_1.default();\n  };\n  /**\n   * Corrects the parameter bits using Reed-Solomon algorithm.\n   *\n   * @param parameterData parameter bits\n   * @param compact true if this is a compact Aztec code\n   * @throws NotFoundException if the array contains too many errors\n   */\n  Detector.prototype.getCorrectedParameterData = function (parameterData, compact) {\n    var numCodewords;\n    var numDataCodewords;\n    if (compact) {\n      numCodewords = 7;\n      numDataCodewords = 2;\n    } else {\n      numCodewords = 10;\n      numDataCodewords = 4;\n    }\n    var numECCodewords = numCodewords - numDataCodewords;\n    var parameterWords = new Int32Array(numCodewords);\n    for (var i = numCodewords - 1; i >= 0; --i) {\n      parameterWords[i] = parameterData & 0xF;\n      parameterData >>= 4;\n    }\n    try {\n      var rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.AZTEC_PARAM);\n      rsDecoder.decode(parameterWords, numECCodewords);\n    } catch (ignored) {\n      throw new NotFoundException_1.default();\n    }\n    // Toss the error correction.  Just return the data as an integer\n    var result = 0;\n    for (var i = 0; i < numDataCodewords; i++) {\n      result = (result << 4) + parameterWords[i];\n    }\n    return result;\n  };\n  /**\n   * Finds the corners of a bull-eye centered on the passed point.\n   * This returns the centers of the diagonal points just outside the bull's eye\n   * Returns [topRight, bottomRight, bottomLeft, topLeft]\n   *\n   * @param pCenter Center point\n   * @return The corners of the bull-eye\n   * @throws NotFoundException If no valid bull-eye can be found\n   */\n  Detector.prototype.getBullsEyeCorners = function (pCenter) {\n    var pina = pCenter;\n    var pinb = pCenter;\n    var pinc = pCenter;\n    var pind = pCenter;\n    var color = true;\n    for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {\n      var pouta = this.getFirstDifferent(pina, color, 1, -1);\n      var poutb = this.getFirstDifferent(pinb, color, 1, 1);\n      var poutc = this.getFirstDifferent(pinc, color, -1, 1);\n      var poutd = this.getFirstDifferent(pind, color, -1, -1);\n      // d      a\n      //\n      // c      b\n      if (this.nbCenterLayers > 2) {\n        var q = this.distancePoint(poutd, pouta) * this.nbCenterLayers / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));\n        if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {\n          break;\n        }\n      }\n      pina = pouta;\n      pinb = poutb;\n      pinc = poutc;\n      pind = poutd;\n      color = !color;\n    }\n    if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {\n      throw new NotFoundException_1.default();\n    }\n    this.compact = this.nbCenterLayers === 5;\n    // Expand the square by .5 pixel in each direction so that we're on the border\n    // between the white square and the black square\n    var pinax = new ResultPoint_1.default(pina.getX() + 0.5, pina.getY() - 0.5);\n    var pinbx = new ResultPoint_1.default(pinb.getX() + 0.5, pinb.getY() + 0.5);\n    var pincx = new ResultPoint_1.default(pinc.getX() - 0.5, pinc.getY() + 0.5);\n    var pindx = new ResultPoint_1.default(pind.getX() - 0.5, pind.getY() - 0.5);\n    // Expand the square so that its corners are the centers of the points\n    // just outside the bull's eye.\n    return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);\n  };\n  /**\n   * Finds a candidate center point of an Aztec code from an image\n   *\n   * @return the center point\n   */\n  Detector.prototype.getMatrixCenter = function () {\n    var pointA;\n    var pointB;\n    var pointC;\n    var pointD;\n    // Get a white rectangle that can be the border of the matrix in center bull's eye or\n    try {\n      var cornerPoints = new WhiteRectangleDetector_1.default(this.image).detect();\n      pointA = cornerPoints[0];\n      pointB = cornerPoints[1];\n      pointC = cornerPoints[2];\n      pointD = cornerPoints[3];\n    } catch (e) {\n      // This exception can be in case the initial rectangle is white\n      // In that case, surely in the bull's eye, we try to expand the rectangle.\n      var cx_1 = this.image.getWidth() / 2;\n      var cy_1 = this.image.getHeight() / 2;\n      pointA = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 - 7), false, 1, -1).toResultPoint();\n      pointB = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 + 7), false, 1, 1).toResultPoint();\n      pointC = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 + 7), false, -1, 1).toResultPoint();\n      pointD = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 - 7), false, -1, -1).toResultPoint();\n    }\n    // Compute the center of the rectangle\n    var cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n    var cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n    // Redetermine the white rectangle starting from previously computed center.\n    // This will ensure that we end up with a white rectangle in center bull's eye\n    // in order to compute a more accurate center.\n    try {\n      var cornerPoints = new WhiteRectangleDetector_1.default(this.image, 15, cx, cy).detect();\n      pointA = cornerPoints[0];\n      pointB = cornerPoints[1];\n      pointC = cornerPoints[2];\n      pointD = cornerPoints[3];\n    } catch (e) {\n      // This exception can be in case the initial rectangle is white\n      // In that case we try to expand the rectangle.\n      pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n      pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n      pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n      pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n    }\n    // Recompute the center of the rectangle\n    cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n    cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n    return new Point(cx, cy);\n  };\n  /**\n   * Gets the Aztec code corners from the bull's eye corners and the parameters.\n   *\n   * @param bullsEyeCorners the array of bull's eye corners\n   * @return the array of aztec code corners\n   */\n  Detector.prototype.getMatrixCornerPoints = function (bullsEyeCorners) {\n    return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());\n  };\n  /**\n   * Creates a BitMatrix by sampling the provided image.\n   * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the\n   * diagonal just outside the bull's eye.\n   */\n  Detector.prototype.sampleGrid = function (image, topLeft, topRight, bottomRight, bottomLeft) {\n    var sampler = GridSamplerInstance_1.default.getInstance();\n    var dimension = this.getDimension();\n    var low = dimension / 2 - this.nbCenterLayers;\n    var high = dimension / 2 + this.nbCenterLayers;\n    return sampler.sampleGrid(image, dimension, dimension, low, low,\n    // topleft\n    high, low,\n    // topright\n    high, high,\n    // bottomright\n    low, high,\n    // bottomleft\n    topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n  };\n  /**\n   * Samples a line.\n   *\n   * @param p1   start point (inclusive)\n   * @param p2   end point (exclusive)\n   * @param size number of bits\n   * @return the array of bits as an int (first bit is high-order bit of result)\n   */\n  Detector.prototype.sampleLine = function (p1, p2, size) {\n    var result = 0;\n    var d = this.distanceResultPoint(p1, p2);\n    var moduleSize = d / size;\n    var px = p1.getX();\n    var py = p1.getY();\n    var dx = moduleSize * (p2.getX() - p1.getX()) / d;\n    var dy = moduleSize * (p2.getY() - p1.getY()) / d;\n    for (var i = 0; i < size; i++) {\n      if (this.image.get(MathUtils_1.default.round(px + i * dx), MathUtils_1.default.round(py + i * dy))) {\n        result |= 1 << size - i - 1;\n      }\n    }\n    return result;\n  };\n  /**\n   * @return true if the border of the rectangle passed in parameter is compound of white points only\n   *         or black points only\n   */\n  Detector.prototype.isWhiteOrBlackRectangle = function (p1, p2, p3, p4) {\n    var corr = 3;\n    p1 = new Point(p1.getX() - corr, p1.getY() + corr);\n    p2 = new Point(p2.getX() - corr, p2.getY() - corr);\n    p3 = new Point(p3.getX() + corr, p3.getY() - corr);\n    p4 = new Point(p4.getX() + corr, p4.getY() + corr);\n    var cInit = this.getColor(p4, p1);\n    if (cInit === 0) {\n      return false;\n    }\n    var c = this.getColor(p1, p2);\n    if (c !== cInit) {\n      return false;\n    }\n    c = this.getColor(p2, p3);\n    if (c !== cInit) {\n      return false;\n    }\n    c = this.getColor(p3, p4);\n    return c === cInit;\n  };\n  /**\n   * Gets the color of a segment\n   *\n   * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else\n   */\n  Detector.prototype.getColor = function (p1, p2) {\n    var d = this.distancePoint(p1, p2);\n    var dx = (p2.getX() - p1.getX()) / d;\n    var dy = (p2.getY() - p1.getY()) / d;\n    var error = 0;\n    var px = p1.getX();\n    var py = p1.getY();\n    var colorModel = this.image.get(p1.getX(), p1.getY());\n    var iMax = Math.ceil(d);\n    for (var i = 0; i < iMax; i++) {\n      px += dx;\n      py += dy;\n      if (this.image.get(MathUtils_1.default.round(px), MathUtils_1.default.round(py)) !== colorModel) {\n        error++;\n      }\n    }\n    var errRatio = error / d;\n    if (errRatio > 0.1 && errRatio < 0.9) {\n      return 0;\n    }\n    return errRatio <= 0.1 === colorModel ? 1 : -1;\n  };\n  /**\n   * Gets the coordinate of the first point with a different color in the given direction\n   */\n  Detector.prototype.getFirstDifferent = function (init, color, dx, dy) {\n    var x = init.getX() + dx;\n    var y = init.getY() + dy;\n    while (this.isValid(x, y) && this.image.get(x, y) === color) {\n      x += dx;\n      y += dy;\n    }\n    x -= dx;\n    y -= dy;\n    while (this.isValid(x, y) && this.image.get(x, y) === color) {\n      x += dx;\n    }\n    x -= dx;\n    while (this.isValid(x, y) && this.image.get(x, y) === color) {\n      y += dy;\n    }\n    y -= dy;\n    return new Point(x, y);\n  };\n  /**\n   * Expand the square represented by the corner points by pushing out equally in all directions\n   *\n   * @param cornerPoints the corners of the square, which has the bull's eye at its center\n   * @param oldSide the original length of the side of the square in the target bit matrix\n   * @param newSide the new length of the size of the square in the target bit matrix\n   * @return the corners of the expanded square\n   */\n  Detector.prototype.expandSquare = function (cornerPoints, oldSide, newSide) {\n    var ratio = newSide / (2.0 * oldSide);\n    var dx = cornerPoints[0].getX() - cornerPoints[2].getX();\n    var dy = cornerPoints[0].getY() - cornerPoints[2].getY();\n    var centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0;\n    var centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0;\n    var result0 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);\n    var result2 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);\n    dx = cornerPoints[1].getX() - cornerPoints[3].getX();\n    dy = cornerPoints[1].getY() - cornerPoints[3].getY();\n    centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0;\n    centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0;\n    var result1 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);\n    var result3 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);\n    var results = [result0, result1, result2, result3];\n    return results;\n  };\n  Detector.prototype.isValid = function (x, y) {\n    return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();\n  };\n  Detector.prototype.isValidPoint = function (point) {\n    var x = MathUtils_1.default.round(point.getX());\n    var y = MathUtils_1.default.round(point.getY());\n    return this.isValid(x, y);\n  };\n  Detector.prototype.distancePoint = function (a, b) {\n    return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());\n  };\n  Detector.prototype.distanceResultPoint = function (a, b) {\n    return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());\n  };\n  Detector.prototype.getDimension = function () {\n    if (this.compact) {\n      return 4 * this.nbLayers + 11;\n    }\n    if (this.nbLayers <= 4) {\n      return 4 * this.nbLayers + 15;\n    }\n    return 4 * this.nbLayers + 2 * (Integer_1.default.truncDivision(this.nbLayers - 4, 8) + 1) + 15;\n  };\n  return Detector;\n}();\nexports.default = Detector;","map":{"version":3,"sources":["../../../../src/core/aztec/detector/Detector.ts"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;AAcG;;;;AAEH,IAAA,aAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AACA,IAAA,qBAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;AAGA,IAAA,WAAA,GAAA,OAAA,CAAA,iCAAA,CAAA;AACA,IAAA,wBAAA,GAAA,OAAA,CAAA,8CAAA,CAAA;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,oCAAA,CAAA;AACA,IAAA,oBAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;AACA,IAAA,mBAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;AACA,IAAA,qBAAA,GAAA,OAAA,CAAA,kCAAA,CAAA;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;AAGA,IAAA,KAAA,GAAA,aAAA,YAAA;EAQI,SAAA,KAAA,CAAmB,CAAS,EAAE,CAAS,EAAA;IACnC,IAAI,CAAC,CAAC,GAAG,CAAC;IACV,IAAI,CAAC,CAAC,GAAG,CAAC;EACd;EAPO,KAAA,CAAA,SAAA,CAAA,aAAa,GAApB,YAAA;IACI,OAAO,IAAI,aAAA,CAAA,OAAW,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC;EACpD,CAAC;EAOM,KAAA,CAAA,SAAA,CAAA,IAAI,GAAX,YAAA;IACI,OAAO,IAAI,CAAC,CAAC;EACjB,CAAC;EAEM,KAAA,CAAA,SAAA,CAAA,IAAI,GAAX,YAAA;IACI,OAAO,IAAI,CAAC,CAAC;EACjB,CAAC;EAML,OAAA,KAAC;AAAD,CAAC,EAAA;AAzBY,OAAA,CAAA,KAAA,GAAA,KAAA;AA2Bb;;;;;;AAMG;AACH,IAAA,QAAA,GAAA,aAAA,YAAA;EAiBI,SAAA,QAAA,CAAmB,KAAgB,EAAA;IAf3B,IAAA,CAAA,oBAAoB,GAAG,IAAI,UAAU,CAAC,CAC1C,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,CACR,CAAC;IAWE,IAAI,CAAC,KAAK,GAAG,KAAK;EACtB;EAEO,QAAA,CAAA,SAAA,CAAA,MAAM,GAAb,YAAA;IACI,OAAO,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC;EACnC,CAAC;EAED;;;;;;AAMG;EACI,QAAA,CAAA,SAAA,CAAA,YAAY,GAAnB,UAAoB,QAAiB,EAAA;IAEjC;IACA,IAAI,OAAO,GAAG,IAAI,CAAC,eAAe,EAAE;IAEpC;IACA;IACA,IAAI,eAAe,GAAG,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC;IAEtD,IAAI,QAAQ,EAAE;MACV,IAAI,IAAI,GAAG,eAAe,CAAC,CAAC,CAAC;MAC7B,eAAe,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC;MACvC,eAAe,CAAC,CAAC,CAAC,GAAG,IAAI;IAC5B;IAED;IACA,IAAI,CAAC,iBAAiB,CAAC,eAAe,CAAC;IAGvC;IACA,IAAI,IAAI,GAAc,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,EAC5C,eAAe,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,EAC/B,eAAe,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC,EACrC,eAAe,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC,EACrC,eAAe,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC,CACxC;IAED;IACA,IAAI,OAAO,GAAkB,IAAI,CAAC,qBAAqB,CAAC,eAAe,CAAC;IAExE,OAAO,IAAI,qBAAA,CAAA,OAAmB,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC;EACjG,CAAC;EAED;;;;;AAKG;EACK,QAAA,CAAA,SAAA,CAAA,iBAAiB,GAAzB,UAA0B,eAA8B,EAAA;IACpD,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,IAChF,CAAC,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,EAAE;MAClF,MAAM,IAAI,mBAAA,CAAA,OAAiB,EAAE;IAChC;IACD,IAAI,MAAM,GAAG,CAAC,GAAG,IAAI,CAAC,cAAc;IACpC;IACA,IAAI,KAAK,GAAG,IAAI,UAAU,CAAC,CACvB,IAAI,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,EAC/D,IAAI,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,EAC/D,IAAI,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,EAC/D,IAAI,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAE;IAAA,CACpE,CAAC;IAEF;IACA;IACA;IACA;IACA,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,MAAM,CAAC;IAE5C;IACA,IAAI,aAAa,GAAG,CAAC;IACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;MACxB,IAAI,IAAI,GAAG,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC;MACtC,IAAI,IAAI,CAAC,OAAO,EAAE;QACd;QACA,aAAa,KAAK,CAAC;QACnB,aAAa,IAAK,IAAI,IAAI,CAAC,GAAI,IAAI;OACtC,MAAM;QACH;QACA,aAAa,KAAK,EAAE;QACpB,aAAa,IAAI,CAAE,IAAI,IAAI,CAAC,GAAK,IAAI,IAAI,CAAE,KAAM,IAAI,IAAI,CAAC,GAAI,IAAI,CAAC;MACtE;IACJ;IAED;IACA;IACA,IAAI,aAAa,GAAG,IAAI,CAAC,yBAAyB,CAAC,aAAa,EAAE,IAAI,CAAC,OAAO,CAAC;IAE/E,IAAI,IAAI,CAAC,OAAO,EAAE;MACd;MACA,IAAI,CAAC,QAAQ,GAAG,CAAC,aAAa,IAAI,CAAC,IAAI,CAAC;MACxC,IAAI,CAAC,YAAY,GAAG,CAAC,aAAa,GAAG,IAAI,IAAI,CAAC;KACjD,MAAM;MACH;MACA,IAAI,CAAC,QAAQ,GAAG,CAAC,aAAa,IAAI,EAAE,IAAI,CAAC;MACzC,IAAI,CAAC,YAAY,GAAG,CAAC,aAAa,GAAG,KAAK,IAAI,CAAC;IAClD;EACL,CAAC;EAEO,QAAA,CAAA,SAAA,CAAA,WAAW,GAAnB,UAAoB,KAAiB,EAAE,MAAc,EAAA;IACjD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,UAAU,GAAG,CAAC;IAClB,KAAK,CAAC,OAAO,CAAC,UAAC,IAAI,EAAE,GAAG,EAAE,GAAG,EAAA;MACzB;MACA,IAAI,CAAC,GAAG,CAAE,IAAI,IAAK,MAAM,GAAG,CAAE,IAAK,CAAC,KAAK,IAAI,GAAG,CAAC,CAAC;MAClD,UAAU,GAAG,CAAC,UAAU,IAAI,CAAC,IAAI,CAAC;IACtC,CAAC,CAAC;IACF;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA,UAAU,GAAG,CAAC,CAAC,UAAU,GAAG,CAAC,KAAK,EAAE,KAAK,UAAU,IAAI,CAAC,CAAC;IACzD;IACA;IACA;IACA,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,CAAC,EAAE,KAAK,EAAE,EAAE;MACpC,IAAI,SAAA,CAAA,OAAO,CAAC,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,EAAE;QACtE,OAAO,KAAK;MACf;IACJ;IACD,MAAM,IAAI,mBAAA,CAAA,OAAiB,EAAE;EACjC,CAAC;EAED;;;;;;AAMG;EACK,QAAA,CAAA,SAAA,CAAA,yBAAyB,GAAjC,UAAkC,aAAqB,EAAE,OAAgB,EAAA;IACrE,IAAI,YAAY;IAChB,IAAI,gBAAgB;IAEpB,IAAI,OAAO,EAAE;MACT,YAAY,GAAG,CAAC;MAChB,gBAAgB,GAAG,CAAC;KACvB,MAAM;MACH,YAAY,GAAG,EAAE;MACjB,gBAAgB,GAAG,CAAC;IACvB;IAED,IAAI,cAAc,GAAG,YAAY,GAAG,gBAAgB;IACpD,IAAI,cAAc,GAAe,IAAI,UAAU,CAAC,YAAY,CAAC;IAC7D,KAAK,IAAI,CAAC,GAAG,YAAY,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE;MACxC,cAAc,CAAC,CAAC,CAAC,GAAG,aAAa,GAAG,GAAG;MACvC,aAAa,KAAK,CAAC;IACtB;IACD,IAAI;MACA,IAAI,SAAS,GAAG,IAAI,oBAAA,CAAA,OAAkB,CAAC,WAAA,CAAA,OAAS,CAAC,WAAW,CAAC;MAC7D,SAAS,CAAC,MAAM,CAAC,cAAc,EAAE,cAAc,CAAC;KACnD,CAAC,OAAO,OAAO,EAAE;MACd,MAAM,IAAI,mBAAA,CAAA,OAAiB,EAAE;IAChC;IACD;IACA,IAAI,MAAM,GAAG,CAAC;IACd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,EAAE,CAAC,EAAE,EAAE;MACvC,MAAM,GAAG,CAAC,MAAM,IAAI,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC;IAC7C;IACD,OAAO,MAAM;EACjB,CAAC;EAED;;;;;;;;AAQG;EACK,QAAA,CAAA,SAAA,CAAA,kBAAkB,GAA1B,UAA2B,OAAc,EAAA;IAGrC,IAAI,IAAI,GAAG,OAAO;IAClB,IAAI,IAAI,GAAG,OAAO;IAClB,IAAI,IAAI,GAAG,OAAO;IAClB,IAAI,IAAI,GAAG,OAAO;IAElB,IAAI,KAAK,GAAG,IAAI;IAEhB,KAAK,IAAI,CAAC,cAAc,GAAG,CAAC,EAAE,IAAI,CAAC,cAAc,GAAG,CAAC,EAAE,IAAI,CAAC,cAAc,EAAE,EAAE;MAE1E,IAAI,KAAK,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MACtD,IAAI,KAAK,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;MACrD,IAAI,KAAK,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MACtD,IAAI,KAAK,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAEvD;MACA;MACA;MAEA,IAAI,IAAI,CAAC,cAAc,GAAG,CAAC,EAAE;QACzB,IAAI,CAAC,GAAI,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,CAAC,GAAG,IAAI,CAAC,cAAc,IAAK,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC,CAAC;QAC/H,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE;UACnF;QACH;MACJ;MAED,IAAI,GAAG,KAAK;MACZ,IAAI,GAAG,KAAK;MACZ,IAAI,GAAG,KAAK;MACZ,IAAI,GAAG,KAAK;MAEZ,KAAK,GAAG,CAAC,KAAK;IACjB;IAED,IAAI,IAAI,CAAC,cAAc,KAAK,CAAC,IAAI,IAAI,CAAC,cAAc,KAAK,CAAC,EAAE;MACxD,MAAM,IAAI,mBAAA,CAAA,OAAiB,EAAE;IAChC;IAED,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,cAAc,KAAK,CAAC;IAExC;IACA;IACA,IAAI,KAAK,GAAG,IAAI,aAAA,CAAA,OAAW,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,GAAG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAG,GAAG,CAAC;IACjE,IAAI,KAAK,GAAG,IAAI,aAAA,CAAA,OAAW,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,GAAG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAG,GAAG,CAAC;IACjE,IAAI,KAAK,GAAG,IAAI,aAAA,CAAA,OAAW,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,GAAG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAG,GAAG,CAAC;IACjE,IAAI,KAAK,GAAG,IAAI,aAAA,CAAA,OAAW,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,GAAG,EAAE,IAAI,CAAC,IAAI,EAAE,GAAG,GAAG,CAAC;IAEjE;IACA;IACA,OAAO,IAAI,CAAC,YAAY,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,EACjD,CAAC,GAAG,IAAI,CAAC,cAAc,GAAG,CAAC,EAC3B,CAAC,GAAG,IAAI,CAAC,cAAc,CAAC;EAChC,CAAC;EAED;;;;AAIG;EACK,QAAA,CAAA,SAAA,CAAA,eAAe,GAAvB,YAAA;IAEI,IAAI,MAAmB;IACvB,IAAI,MAAmB;IACvB,IAAI,MAAmB;IACvB,IAAI,MAAmB;IAEvB;IACA,IAAI;MAEA,IAAI,YAAY,GAAG,IAAI,wBAAA,CAAA,OAAsB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,EAAE;MAClE,MAAM,GAAG,YAAY,CAAC,CAAC,CAAC;MACxB,MAAM,GAAG,YAAY,CAAC,CAAC,CAAC;MACxB,MAAM,GAAG,YAAY,CAAC,CAAC,CAAC;MACxB,MAAM,GAAG,YAAY,CAAC,CAAC,CAAC;KAE3B,CAAC,OAAO,CAAC,EAAE;MAER;MACA;MACA,IAAI,IAAE,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAG,CAAC;MAClC,IAAI,IAAE,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,GAAG,CAAC;MACnC,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,CAAC,IAAE,GAAG,CAAC,EAAE,IAAE,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,aAAa,EAAE;MACxF,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,CAAC,IAAE,GAAG,CAAC,EAAE,IAAE,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,aAAa,EAAE;MACvF,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,CAAC,IAAE,GAAG,CAAC,EAAE,IAAE,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,aAAa,EAAE;MACxF,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,CAAC,IAAE,GAAG,CAAC,EAAE,IAAE,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,aAAa,EAAE;IAE5F;IAED;IACA,IAAI,EAAE,GAAG,WAAA,CAAA,OAAS,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,IAAI,EAAE,IAAI,GAAG,CAAC;IAC/F,IAAI,EAAE,GAAG,WAAA,CAAA,OAAS,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,IAAI,EAAE,IAAI,GAAG,CAAC;IAE/F;IACA;IACA;IACA,IAAI;MACA,IAAI,YAAY,GAAG,IAAI,wBAAA,CAAA,OAAsB,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,MAAM,EAAE;MAC9E,MAAM,GAAG,YAAY,CAAC,CAAC,CAAC;MACxB,MAAM,GAAG,YAAY,CAAC,CAAC,CAAC;MACxB,MAAM,GAAG,YAAY,CAAC,CAAC,CAAC;MACxB,MAAM,GAAG,YAAY,CAAC,CAAC,CAAC;KAC3B,CAAC,OAAO,CAAC,EAAE;MACR;MACA;MACA,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,aAAa,EAAE;MACxF,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,aAAa,EAAE;MACvF,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,aAAa,EAAE;MACxF,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,aAAa,EAAE;IAC5F;IAED;IACA,EAAE,GAAG,WAAA,CAAA,OAAS,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,IAAI,EAAE,IAAI,GAAG,CAAC;IAC3F,EAAE,GAAG,WAAA,CAAA,OAAS,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,IAAI,EAAE,IAAI,GAAG,CAAC;IAE3F,OAAO,IAAI,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;EAC5B,CAAC;EAED;;;;;AAKG;EACK,QAAA,CAAA,SAAA,CAAA,qBAAqB,GAA7B,UAA8B,eAA8B,EAAA;IACxD,OAAO,IAAI,CAAC,YAAY,CAAC,eAAe,EAAE,CAAC,GAAG,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,YAAY,EAAE,CAAC;EAC3F,CAAC;EAED;;;;AAIG;EACK,QAAA,CAAA,SAAA,CAAA,UAAU,GAAlB,UAAmB,KAAgB,EAC/B,OAAoB,EACpB,QAAqB,EACrB,WAAwB,EACxB,UAAuB,EAAA;IAEvB,IAAI,OAAO,GAAG,qBAAA,CAAA,OAAmB,CAAC,WAAW,EAAE;IAC/C,IAAI,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE;IAEnC,IAAI,GAAG,GAAG,SAAS,GAAG,CAAC,GAAG,IAAI,CAAC,cAAc;IAC7C,IAAI,IAAI,GAAG,SAAS,GAAG,CAAC,GAAG,IAAI,CAAC,cAAc;IAE9C,OAAO,OAAO,CAAC,UAAU,CAAC,KAAK,EAC3B,SAAS,EACT,SAAS,EACT,GAAG,EAAE,GAAG;IAAI;IACZ,IAAI,EAAE,GAAG;IAAG;IACZ,IAAI,EAAE,IAAI;IAAE;IACZ,GAAG,EAAE,IAAI;IAAG;IACZ,OAAO,CAAC,IAAI,EAAE,EAAE,OAAO,CAAC,IAAI,EAAE,EAC9B,QAAQ,CAAC,IAAI,EAAE,EAAE,QAAQ,CAAC,IAAI,EAAE,EAChC,WAAW,CAAC,IAAI,EAAE,EAAE,WAAW,CAAC,IAAI,EAAE,EACtC,UAAU,CAAC,IAAI,EAAE,EAAE,UAAU,CAAC,IAAI,EAAE,CAAC;EAC7C,CAAC;EAED;;;;;;;AAOG;EACK,QAAA,CAAA,SAAA,CAAA,UAAU,GAAlB,UAAmB,EAAe,EAAE,EAAe,EAAE,IAAY,EAAA;IAC7D,IAAI,MAAM,GAAG,CAAC;IAEd,IAAI,CAAC,GAAG,IAAI,CAAC,mBAAmB,CAAC,EAAE,EAAE,EAAE,CAAC;IACxC,IAAI,UAAU,GAAG,CAAC,GAAG,IAAI;IACzB,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE;IAClB,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE;IAClB,IAAI,EAAE,GAAG,UAAU,IAAI,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC;IACjD,IAAI,EAAE,GAAG,UAAU,IAAI,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC;IACjD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE;MAC3B,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,WAAA,CAAA,OAAS,CAAC,KAAK,CAAC,EAAE,GAAG,CAAC,GAAG,EAAE,CAAC,EAAE,WAAA,CAAA,OAAS,CAAC,KAAK,CAAC,EAAE,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE;QAC5E,MAAM,IAAI,CAAC,IAAK,IAAI,GAAG,CAAC,GAAG,CAAE;MAChC;IACJ;IACD,OAAO,MAAM;EACjB,CAAC;EAED;;;AAGG;EACK,QAAA,CAAA,SAAA,CAAA,uBAAuB,GAA/B,UAAgC,EAAS,EACrC,EAAS,EACT,EAAS,EACT,EAAS,EAAA;IAET,IAAI,IAAI,GAAG,CAAC;IACZ,EAAE,GAAG,IAAI,KAAK,CAAC,EAAE,CAAC,IAAI,EAAE,GAAG,IAAI,EAAE,EAAE,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC;IAClD,EAAE,GAAG,IAAI,KAAK,CAAC,EAAE,CAAC,IAAI,EAAE,GAAG,IAAI,EAAE,EAAE,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC;IAClD,EAAE,GAAG,IAAI,KAAK,CAAC,EAAE,CAAC,IAAI,EAAE,GAAG,IAAI,EAAE,EAAE,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC;IAClD,EAAE,GAAG,IAAI,KAAK,CAAC,EAAE,CAAC,IAAI,EAAE,GAAG,IAAI,EAAE,EAAE,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC;IAElD,IAAI,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,EAAE,CAAC;IAEjC,IAAI,KAAK,KAAK,CAAC,EAAE;MACb,OAAO,KAAK;IACf;IAED,IAAI,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,EAAE,CAAC;IAE7B,IAAI,CAAC,KAAK,KAAK,EAAE;MACb,OAAO,KAAK;IACf;IAED,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,EAAE,CAAC;IAEzB,IAAI,CAAC,KAAK,KAAK,EAAE;MACb,OAAO,KAAK;IACf;IAED,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,EAAE,CAAC;IAEzB,OAAO,CAAC,KAAK,KAAK;EAEtB,CAAC;EAED;;;;AAIG;EACK,QAAA,CAAA,SAAA,CAAA,QAAQ,GAAhB,UAAiB,EAAS,EAAE,EAAS,EAAA;IACjC,IAAI,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,EAAE,EAAE,EAAE,CAAC;IAClC,IAAI,EAAE,GAAG,CAAC,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC;IACpC,IAAI,EAAE,GAAG,CAAC,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC;IACpC,IAAI,KAAK,GAAG,CAAC;IAEb,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE;IAClB,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE;IAElB,IAAI,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,IAAI,EAAE,CAAC;IAErD,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE;MAC3B,EAAE,IAAI,EAAE;MACR,EAAE,IAAI,EAAE;MACR,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,WAAA,CAAA,OAAS,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,WAAA,CAAA,OAAS,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,KAAK,UAAU,EAAE;QACzE,KAAK,EAAE;MACV;IACJ;IAED,IAAI,QAAQ,GAAG,KAAK,GAAG,CAAC;IAExB,IAAI,QAAQ,GAAG,GAAG,IAAI,QAAQ,GAAG,GAAG,EAAE;MAClC,OAAO,CAAC;IACX;IAED,OAAQ,QAAQ,IAAI,GAAG,KAAM,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC;EACpD,CAAC;EAED;;AAEG;EACK,QAAA,CAAA,SAAA,CAAA,iBAAiB,GAAzB,UAA0B,IAAW,EAAE,KAAc,EAAE,EAAU,EAAE,EAAU,EAAA;IACzE,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE;IACxB,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE;IAExB,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,KAAK,EAAE;MACzD,CAAC,IAAI,EAAE;MACP,CAAC,IAAI,EAAE;IACV;IAED,CAAC,IAAI,EAAE;IACP,CAAC,IAAI,EAAE;IAEP,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,KAAK,EAAE;MACzD,CAAC,IAAI,EAAE;IACV;IACD,CAAC,IAAI,EAAE;IAEP,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,KAAK,EAAE;MACzD,CAAC,IAAI,EAAE;IACV;IACD,CAAC,IAAI,EAAE;IAEP,OAAO,IAAI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;EAC1B,CAAC;EAED;;;;;;;AAOG;EACK,QAAA,CAAA,SAAA,CAAA,YAAY,GAApB,UAAqB,YAA2B,EAAE,OAAe,EAAE,OAAe,EAAA;IAC9E,IAAI,KAAK,GAAG,OAAO,IAAI,GAAG,GAAG,OAAO,CAAC;IACrC,IAAI,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;IACxD,IAAI,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;IACxD,IAAI,OAAO,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,GAAG;IACrE,IAAI,OAAO,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,GAAG;IAErE,IAAI,OAAO,GAAG,IAAI,aAAA,CAAA,OAAW,CAAC,OAAO,GAAG,KAAK,GAAG,EAAE,EAAE,OAAO,GAAG,KAAK,GAAG,EAAE,CAAC;IACzE,IAAI,OAAO,GAAG,IAAI,aAAA,CAAA,OAAW,CAAC,OAAO,GAAG,KAAK,GAAG,EAAE,EAAE,OAAO,GAAG,KAAK,GAAG,EAAE,CAAC;IAEzE,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;IACpD,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;IACpD,OAAO,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,GAAG;IACjE,OAAO,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,GAAG;IACjE,IAAI,OAAO,GAAG,IAAI,aAAA,CAAA,OAAW,CAAC,OAAO,GAAG,KAAK,GAAG,EAAE,EAAE,OAAO,GAAG,KAAK,GAAG,EAAE,CAAC;IACzE,IAAI,OAAO,GAAG,IAAI,aAAA,CAAA,OAAW,CAAC,OAAO,GAAG,KAAK,GAAG,EAAE,EAAE,OAAO,GAAG,KAAK,GAAG,EAAE,CAAC;IAEzE,IAAI,OAAO,GAAkB,CAAC,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,CAAC;IACjE,OAAO,OAAO;EAClB,CAAC;EAEO,QAAA,CAAA,SAAA,CAAA,OAAO,GAAf,UAAgB,CAAS,EAAE,CAAS,EAAA;IAChC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE;EACrF,CAAC;EAEO,QAAA,CAAA,SAAA,CAAA,YAAY,GAApB,UAAqB,KAAkB,EAAA;IACnC,IAAI,CAAC,GAAG,WAAA,CAAA,OAAS,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;IACrC,IAAI,CAAC,GAAG,WAAA,CAAA,OAAS,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;IACrC,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;EAC7B,CAAC;EAEO,QAAA,CAAA,SAAA,CAAA,aAAa,GAArB,UAAsB,CAAQ,EAAE,CAAQ,EAAA;IACpC,OAAO,WAAA,CAAA,OAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;EACrE,CAAC;EAEO,QAAA,CAAA,SAAA,CAAA,mBAAmB,GAA3B,UAA4B,CAAc,EAAE,CAAc,EAAA;IACtD,OAAO,WAAA,CAAA,OAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;EACrE,CAAC;EAEO,QAAA,CAAA,SAAA,CAAA,YAAY,GAApB,YAAA;IACI,IAAI,IAAI,CAAC,OAAO,EAAE;MACd,OAAO,CAAC,GAAG,IAAI,CAAC,QAAQ,GAAG,EAAE;IAChC;IACD,IAAI,IAAI,CAAC,QAAQ,IAAI,CAAC,EAAE;MACpB,OAAO,CAAC,GAAG,IAAI,CAAC,QAAQ,GAAG,EAAE;IAChC;IACD,OAAO,CAAC,GAAG,IAAI,CAAC,QAAQ,GAAG,CAAC,IAAI,SAAA,CAAA,OAAO,CAAC,aAAa,CAAE,IAAI,CAAC,QAAQ,GAAG,CAAC,EAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE;EAC3F,CAAC;EAEL,OAAA,QAAC;AAAD,CAAC,EAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ResultPoint_1 = require(\"../../ResultPoint\");\nvar AztecDetectorResult_1 = require(\"../AztecDetectorResult\");\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\");\nvar WhiteRectangleDetector_1 = require(\"../../common/detector/WhiteRectangleDetector\");\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\nvar NotFoundException_1 = require(\"../../NotFoundException\");\nvar GridSamplerInstance_1 = require(\"../../common/GridSamplerInstance\");\nvar Integer_1 = require(\"../../util/Integer\");\nvar Point = /** @class */ (function () {\n    function Point(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    Point.prototype.toResultPoint = function () {\n        return new ResultPoint_1.default(this.getX(), this.getY());\n    };\n    Point.prototype.getX = function () {\n        return this.x;\n    };\n    Point.prototype.getY = function () {\n        return this.y;\n    };\n    return Point;\n}());\nexports.Point = Point;\n/**\n * Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code\n * is rotated or skewed, or partially obscured.\n *\n * @author David Olivier\n * @author Frank Yellin\n */\nvar Detector = /** @class */ (function () {\n    function Detector(image) {\n        this.EXPECTED_CORNER_BITS = new Int32Array([\n            0xee0,\n            0x1dc,\n            0x83b,\n            0x707,\n        ]);\n        this.image = image;\n    }\n    Detector.prototype.detect = function () {\n        return this.detectMirror(false);\n    };\n    /**\n     * Detects an Aztec Code in an image.\n     *\n     * @param isMirror if true, image is a mirror-image of original\n     * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code\n     * @throws NotFoundException if no Aztec Code can be found\n     */\n    Detector.prototype.detectMirror = function (isMirror) {\n        // 1. Get the center of the aztec matrix\n        var pCenter = this.getMatrixCenter();\n        // 2. Get the center points of the four diagonal points just outside the bull's eye\n        //  [topRight, bottomRight, bottomLeft, topLeft]\n        var bullsEyeCorners = this.getBullsEyeCorners(pCenter);\n        if (isMirror) {\n            var temp = bullsEyeCorners[0];\n            bullsEyeCorners[0] = bullsEyeCorners[2];\n            bullsEyeCorners[2] = temp;\n        }\n        // 3. Get the size of the matrix and other parameters from the bull's eye\n        this.extractParameters(bullsEyeCorners);\n        // 4. Sample the grid\n        var bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);\n        // 5. Get the corners of the matrix.\n        var corners = this.getMatrixCornerPoints(bullsEyeCorners);\n        return new AztecDetectorResult_1.default(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);\n    };\n    /**\n     * Extracts the number of data layers and data blocks from the layer around the bull's eye.\n     *\n     * @param bullsEyeCorners the array of bull's eye corners\n     * @throws NotFoundException in case of too many errors or invalid parameters\n     */\n    Detector.prototype.extractParameters = function (bullsEyeCorners) {\n        if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) ||\n            !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {\n            throw new NotFoundException_1.default();\n        }\n        var length = 2 * this.nbCenterLayers;\n        // Get the bits around the bull's eye\n        var sides = new Int32Array([\n            this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),\n            this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),\n            this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),\n            this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) // Top\n        ]);\n        // bullsEyeCorners[shift] is the corner of the bulls'eye that has three\n        // orientation marks.\n        // sides[shift] is the row/column that goes from the corner with three\n        // orientation marks to the corner with two.\n        this.shift = this.getRotation(sides, length);\n        // Flatten the parameter bits into a single 28- or 40-bit long\n        var parameterData = 0;\n        for (var i = 0; i < 4; i++) {\n            var side = sides[(this.shift + i) % 4];\n            if (this.compact) {\n                // Each side of the form ..XXXXXXX. where Xs are parameter data\n                parameterData <<= 7;\n                parameterData += (side >> 1) & 0x7F;\n            }\n            else {\n                // Each side of the form ..XXXXX.XXXXX. where Xs are parameter data\n                parameterData <<= 10;\n                parameterData += ((side >> 2) & (0x1f << 5)) + ((side >> 1) & 0x1F);\n            }\n        }\n        // Corrects parameter data using RS.  Returns just the data portion\n        // without the error correction.\n        var correctedData = this.getCorrectedParameterData(parameterData, this.compact);\n        if (this.compact) {\n            // 8 bits:  2 bits layers and 6 bits data blocks\n            this.nbLayers = (correctedData >> 6) + 1;\n            this.nbDataBlocks = (correctedData & 0x3F) + 1;\n        }\n        else {\n            // 16 bits:  5 bits layers and 11 bits data blocks\n            this.nbLayers = (correctedData >> 11) + 1;\n            this.nbDataBlocks = (correctedData & 0x7FF) + 1;\n        }\n    };\n    Detector.prototype.getRotation = function (sides, length) {\n        // In a normal pattern, we expect to See\n        //   **    .*             D       A\n        //   *      *\n        //\n        //   .      *\n        //   ..    ..             C       B\n        //\n        // Grab the 3 bits from each of the sides the form the locator pattern and concatenate\n        // into a 12-bit integer.  Start with the bit at A\n        var cornerBits = 0;\n        sides.forEach(function (side, idx, arr) {\n            // XX......X where X's are orientation marks\n            var t = ((side >> (length - 2)) << 1) + (side & 1);\n            cornerBits = (cornerBits << 3) + t;\n        });\n        // for (var side in sides) {\n        //     // XX......X where X's are orientation marks\n        //     var t = ((side >> (length - 2)) << 1) + (side & 1);\n        //     cornerBits = (cornerBits << 3) + t;\n        // }\n        // Mov the bottom bit to the top, so that the three bits of the locator pattern at A are\n        // together.  cornerBits is now:\n        //  3 orientation bits at A || 3 orientation bits at B || ... || 3 orientation bits at D\n        cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);\n        // The result shift indicates which element of BullsEyeCorners[] goes into the top-left\n        // corner. Since the four rotation values have a Hamming distance of 8, we\n        // can easily tolerate two errors.\n        for (var shift = 0; shift < 4; shift++) {\n            if (Integer_1.default.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {\n                return shift;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    /**\n     * Corrects the parameter bits using Reed-Solomon algorithm.\n     *\n     * @param parameterData parameter bits\n     * @param compact true if this is a compact Aztec code\n     * @throws NotFoundException if the array contains too many errors\n     */\n    Detector.prototype.getCorrectedParameterData = function (parameterData, compact) {\n        var numCodewords;\n        var numDataCodewords;\n        if (compact) {\n            numCodewords = 7;\n            numDataCodewords = 2;\n        }\n        else {\n            numCodewords = 10;\n            numDataCodewords = 4;\n        }\n        var numECCodewords = numCodewords - numDataCodewords;\n        var parameterWords = new Int32Array(numCodewords);\n        for (var i = numCodewords - 1; i >= 0; --i) {\n            parameterWords[i] = parameterData & 0xF;\n            parameterData >>= 4;\n        }\n        try {\n            var rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.AZTEC_PARAM);\n            rsDecoder.decode(parameterWords, numECCodewords);\n        }\n        catch (ignored) {\n            throw new NotFoundException_1.default();\n        }\n        // Toss the error correction.  Just return the data as an integer\n        var result = 0;\n        for (var i = 0; i < numDataCodewords; i++) {\n            result = (result << 4) + parameterWords[i];\n        }\n        return result;\n    };\n    /**\n     * Finds the corners of a bull-eye centered on the passed point.\n     * This returns the centers of the diagonal points just outside the bull's eye\n     * Returns [topRight, bottomRight, bottomLeft, topLeft]\n     *\n     * @param pCenter Center point\n     * @return The corners of the bull-eye\n     * @throws NotFoundException If no valid bull-eye can be found\n     */\n    Detector.prototype.getBullsEyeCorners = function (pCenter) {\n        var pina = pCenter;\n        var pinb = pCenter;\n        var pinc = pCenter;\n        var pind = pCenter;\n        var color = true;\n        for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {\n            var pouta = this.getFirstDifferent(pina, color, 1, -1);\n            var poutb = this.getFirstDifferent(pinb, color, 1, 1);\n            var poutc = this.getFirstDifferent(pinc, color, -1, 1);\n            var poutd = this.getFirstDifferent(pind, color, -1, -1);\n            // d      a\n            //\n            // c      b\n            if (this.nbCenterLayers > 2) {\n                var q = (this.distancePoint(poutd, pouta) * this.nbCenterLayers) / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));\n                if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {\n                    break;\n                }\n            }\n            pina = pouta;\n            pinb = poutb;\n            pinc = poutc;\n            pind = poutd;\n            color = !color;\n        }\n        if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {\n            throw new NotFoundException_1.default();\n        }\n        this.compact = this.nbCenterLayers === 5;\n        // Expand the square by .5 pixel in each direction so that we're on the border\n        // between the white square and the black square\n        var pinax = new ResultPoint_1.default(pina.getX() + 0.5, pina.getY() - 0.5);\n        var pinbx = new ResultPoint_1.default(pinb.getX() + 0.5, pinb.getY() + 0.5);\n        var pincx = new ResultPoint_1.default(pinc.getX() - 0.5, pinc.getY() + 0.5);\n        var pindx = new ResultPoint_1.default(pind.getX() - 0.5, pind.getY() - 0.5);\n        // Expand the square so that its corners are the centers of the points\n        // just outside the bull's eye.\n        return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);\n    };\n    /**\n     * Finds a candidate center point of an Aztec code from an image\n     *\n     * @return the center point\n     */\n    Detector.prototype.getMatrixCenter = function () {\n        var pointA;\n        var pointB;\n        var pointC;\n        var pointD;\n        // Get a white rectangle that can be the border of the matrix in center bull's eye or\n        try {\n            var cornerPoints = new WhiteRectangleDetector_1.default(this.image).detect();\n            pointA = cornerPoints[0];\n            pointB = cornerPoints[1];\n            pointC = cornerPoints[2];\n            pointD = cornerPoints[3];\n        }\n        catch (e) {\n            // This exception can be in case the initial rectangle is white\n            // In that case, surely in the bull's eye, we try to expand the rectangle.\n            var cx_1 = this.image.getWidth() / 2;\n            var cy_1 = this.image.getHeight() / 2;\n            pointA = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 - 7), false, 1, -1).toResultPoint();\n            pointB = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 + 7), false, 1, 1).toResultPoint();\n            pointC = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 + 7), false, -1, 1).toResultPoint();\n            pointD = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 - 7), false, -1, -1).toResultPoint();\n        }\n        // Compute the center of the rectangle\n        var cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n        var cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n        // Redetermine the white rectangle starting from previously computed center.\n        // This will ensure that we end up with a white rectangle in center bull's eye\n        // in order to compute a more accurate center.\n        try {\n            var cornerPoints = new WhiteRectangleDetector_1.default(this.image, 15, cx, cy).detect();\n            pointA = cornerPoints[0];\n            pointB = cornerPoints[1];\n            pointC = cornerPoints[2];\n            pointD = cornerPoints[3];\n        }\n        catch (e) {\n            // This exception can be in case the initial rectangle is white\n            // In that case we try to expand the rectangle.\n            pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n            pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n            pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n            pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n        }\n        // Recompute the center of the rectangle\n        cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n        cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n        return new Point(cx, cy);\n    };\n    /**\n     * Gets the Aztec code corners from the bull's eye corners and the parameters.\n     *\n     * @param bullsEyeCorners the array of bull's eye corners\n     * @return the array of aztec code corners\n     */\n    Detector.prototype.getMatrixCornerPoints = function (bullsEyeCorners) {\n        return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());\n    };\n    /**\n     * Creates a BitMatrix by sampling the provided image.\n     * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the\n     * diagonal just outside the bull's eye.\n     */\n    Detector.prototype.sampleGrid = function (image, topLeft, topRight, bottomRight, bottomLeft) {\n        var sampler = GridSamplerInstance_1.default.getInstance();\n        var dimension = this.getDimension();\n        var low = dimension / 2 - this.nbCenterLayers;\n        var high = dimension / 2 + this.nbCenterLayers;\n        return sampler.sampleGrid(image, dimension, dimension, low, low, // topleft\n        high, low, // topright\n        high, high, // bottomright\n        low, high, // bottomleft\n        topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n    };\n    /**\n     * Samples a line.\n     *\n     * @param p1   start point (inclusive)\n     * @param p2   end point (exclusive)\n     * @param size number of bits\n     * @return the array of bits as an int (first bit is high-order bit of result)\n     */\n    Detector.prototype.sampleLine = function (p1, p2, size) {\n        var result = 0;\n        var d = this.distanceResultPoint(p1, p2);\n        var moduleSize = d / size;\n        var px = p1.getX();\n        var py = p1.getY();\n        var dx = moduleSize * (p2.getX() - p1.getX()) / d;\n        var dy = moduleSize * (p2.getY() - p1.getY()) / d;\n        for (var i = 0; i < size; i++) {\n            if (this.image.get(MathUtils_1.default.round(px + i * dx), MathUtils_1.default.round(py + i * dy))) {\n                result |= 1 << (size - i - 1);\n            }\n        }\n        return result;\n    };\n    /**\n     * @return true if the border of the rectangle passed in parameter is compound of white points only\n     *         or black points only\n     */\n    Detector.prototype.isWhiteOrBlackRectangle = function (p1, p2, p3, p4) {\n        var corr = 3;\n        p1 = new Point(p1.getX() - corr, p1.getY() + corr);\n        p2 = new Point(p2.getX() - corr, p2.getY() - corr);\n        p3 = new Point(p3.getX() + corr, p3.getY() - corr);\n        p4 = new Point(p4.getX() + corr, p4.getY() + corr);\n        var cInit = this.getColor(p4, p1);\n        if (cInit === 0) {\n            return false;\n        }\n        var c = this.getColor(p1, p2);\n        if (c !== cInit) {\n            return false;\n        }\n        c = this.getColor(p2, p3);\n        if (c !== cInit) {\n            return false;\n        }\n        c = this.getColor(p3, p4);\n        return c === cInit;\n    };\n    /**\n     * Gets the color of a segment\n     *\n     * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else\n     */\n    Detector.prototype.getColor = function (p1, p2) {\n        var d = this.distancePoint(p1, p2);\n        var dx = (p2.getX() - p1.getX()) / d;\n        var dy = (p2.getY() - p1.getY()) / d;\n        var error = 0;\n        var px = p1.getX();\n        var py = p1.getY();\n        var colorModel = this.image.get(p1.getX(), p1.getY());\n        var iMax = Math.ceil(d);\n        for (var i = 0; i < iMax; i++) {\n            px += dx;\n            py += dy;\n            if (this.image.get(MathUtils_1.default.round(px), MathUtils_1.default.round(py)) !== colorModel) {\n                error++;\n            }\n        }\n        var errRatio = error / d;\n        if (errRatio > 0.1 && errRatio < 0.9) {\n            return 0;\n        }\n        return (errRatio <= 0.1) === colorModel ? 1 : -1;\n    };\n    /**\n     * Gets the coordinate of the first point with a different color in the given direction\n     */\n    Detector.prototype.getFirstDifferent = function (init, color, dx, dy) {\n        var x = init.getX() + dx;\n        var y = init.getY() + dy;\n        while (this.isValid(x, y) && this.image.get(x, y) === color) {\n            x += dx;\n            y += dy;\n        }\n        x -= dx;\n        y -= dy;\n        while (this.isValid(x, y) && this.image.get(x, y) === color) {\n            x += dx;\n        }\n        x -= dx;\n        while (this.isValid(x, y) && this.image.get(x, y) === color) {\n            y += dy;\n        }\n        y -= dy;\n        return new Point(x, y);\n    };\n    /**\n     * Expand the square represented by the corner points by pushing out equally in all directions\n     *\n     * @param cornerPoints the corners of the square, which has the bull's eye at its center\n     * @param oldSide the original length of the side of the square in the target bit matrix\n     * @param newSide the new length of the size of the square in the target bit matrix\n     * @return the corners of the expanded square\n     */\n    Detector.prototype.expandSquare = function (cornerPoints, oldSide, newSide) {\n        var ratio = newSide / (2.0 * oldSide);\n        var dx = cornerPoints[0].getX() - cornerPoints[2].getX();\n        var dy = cornerPoints[0].getY() - cornerPoints[2].getY();\n        var centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0;\n        var centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0;\n        var result0 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);\n        var result2 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);\n        dx = cornerPoints[1].getX() - cornerPoints[3].getX();\n        dy = cornerPoints[1].getY() - cornerPoints[3].getY();\n        centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0;\n        centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0;\n        var result1 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);\n        var result3 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);\n        var results = [result0, result1, result2, result3];\n        return results;\n    };\n    Detector.prototype.isValid = function (x, y) {\n        return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();\n    };\n    Detector.prototype.isValidPoint = function (point) {\n        var x = MathUtils_1.default.round(point.getX());\n        var y = MathUtils_1.default.round(point.getY());\n        return this.isValid(x, y);\n    };\n    Detector.prototype.distancePoint = function (a, b) {\n        return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());\n    };\n    Detector.prototype.distanceResultPoint = function (a, b) {\n        return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());\n    };\n    Detector.prototype.getDimension = function () {\n        if (this.compact) {\n            return 4 * this.nbLayers + 11;\n        }\n        if (this.nbLayers <= 4) {\n            return 4 * this.nbLayers + 15;\n        }\n        return 4 * this.nbLayers + 2 * (Integer_1.default.truncDivision((this.nbLayers - 4), 8) + 1) + 15;\n    };\n    return Detector;\n}());\nexports.default = Detector;\n//# sourceMappingURL=Detector.js.map"]},"metadata":{},"sourceType":"script"}