{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing {*/\nvar MathUtils_1 = require(\"./common/detector/MathUtils\");\nvar Float_1 = require(\"./util/Float\");\n/**\n * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this\n * would be the location of a finder pattern or the corner of the barcode, for example.</p>\n *\n * @author Sean Owen\n */\nvar ResultPoint = /** @class */function () {\n  function ResultPoint(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  ResultPoint.prototype.getX = function () {\n    return this.x;\n  };\n  ResultPoint.prototype.getY = function () {\n    return this.y;\n  };\n  /*@Override*/\n  ResultPoint.prototype.equals = function (other) {\n    if (other instanceof ResultPoint) {\n      var otherPoint = other;\n      return this.x === otherPoint.x && this.y === otherPoint.y;\n    }\n    return false;\n  };\n  /*@Override*/\n  ResultPoint.prototype.hashCode = function () {\n    return 31 * Float_1.default.floatToIntBits(this.x) + Float_1.default.floatToIntBits(this.y);\n  };\n  /*@Override*/\n  ResultPoint.prototype.toString = function () {\n    return '(' + this.x + ',' + this.y + ')';\n  };\n  /**\n   * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC\n   * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.\n   *\n   * @param patterns array of three {@code ResultPoint} to order\n   */\n  ResultPoint.orderBestPatterns = function (patterns) {\n    // Find distances between pattern centers\n    var zeroOneDistance = this.distance(patterns[0], patterns[1]);\n    var oneTwoDistance = this.distance(patterns[1], patterns[2]);\n    var zeroTwoDistance = this.distance(patterns[0], patterns[2]);\n    var pointA;\n    var pointB;\n    var pointC;\n    // Assume one closest to other two is B; A and C will just be guesses at first\n    if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {\n      pointB = patterns[0];\n      pointA = patterns[1];\n      pointC = patterns[2];\n    } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {\n      pointB = patterns[1];\n      pointA = patterns[0];\n      pointC = patterns[2];\n    } else {\n      pointB = patterns[2];\n      pointA = patterns[0];\n      pointC = patterns[1];\n    }\n    // Use cross product to figure out whether A and C are correct or flipped.\n    // This asks whether BC x BA has a positive z component, which is the arrangement\n    // we want for A, B, C. If it's negative, then we've got it flipped around and\n    // should swap A and C.\n    if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {\n      var temp = pointA;\n      pointA = pointC;\n      pointC = temp;\n    }\n    patterns[0] = pointA;\n    patterns[1] = pointB;\n    patterns[2] = pointC;\n  };\n  /**\n   * @param pattern1 first pattern\n   * @param pattern2 second pattern\n   * @return distance between two points\n   */\n  ResultPoint.distance = function (pattern1, pattern2) {\n    return MathUtils_1.default.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);\n  };\n  /**\n   * Returns the z component of the cross product between vectors BC and BA.\n   */\n  ResultPoint.crossProductZ = function (pointA, pointB, pointC) {\n    var bX = pointB.x;\n    var bY = pointB.y;\n    return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX);\n  };\n  return ResultPoint;\n}();\nexports.default = ResultPoint;","map":{"version":3,"sources":["../../src/core/ResultPoint.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing {*/\nvar MathUtils_1 = require(\"./common/detector/MathUtils\");\nvar Float_1 = require(\"./util/Float\");\n/**\n * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this\n * would be the location of a finder pattern or the corner of the barcode, for example.</p>\n *\n * @author Sean Owen\n */\nvar ResultPoint = /** @class */ (function () {\n    function ResultPoint(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    ResultPoint.prototype.getX = function () {\n        return this.x;\n    };\n    ResultPoint.prototype.getY = function () {\n        return this.y;\n    };\n    /*@Override*/\n    ResultPoint.prototype.equals = function (other) {\n        if (other instanceof ResultPoint) {\n            var otherPoint = other;\n            return this.x === otherPoint.x && this.y === otherPoint.y;\n        }\n        return false;\n    };\n    /*@Override*/\n    ResultPoint.prototype.hashCode = function () {\n        return 31 * Float_1.default.floatToIntBits(this.x) + Float_1.default.floatToIntBits(this.y);\n    };\n    /*@Override*/\n    ResultPoint.prototype.toString = function () {\n        return '(' + this.x + ',' + this.y + ')';\n    };\n    /**\n     * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC\n     * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.\n     *\n     * @param patterns array of three {@code ResultPoint} to order\n     */\n    ResultPoint.orderBestPatterns = function (patterns) {\n        // Find distances between pattern centers\n        var zeroOneDistance = this.distance(patterns[0], patterns[1]);\n        var oneTwoDistance = this.distance(patterns[1], patterns[2]);\n        var zeroTwoDistance = this.distance(patterns[0], patterns[2]);\n        var pointA;\n        var pointB;\n        var pointC;\n        // Assume one closest to other two is B; A and C will just be guesses at first\n        if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {\n            pointB = patterns[0];\n            pointA = patterns[1];\n            pointC = patterns[2];\n        }\n        else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {\n            pointB = patterns[1];\n            pointA = patterns[0];\n            pointC = patterns[2];\n        }\n        else {\n            pointB = patterns[2];\n            pointA = patterns[0];\n            pointC = patterns[1];\n        }\n        // Use cross product to figure out whether A and C are correct or flipped.\n        // This asks whether BC x BA has a positive z component, which is the arrangement\n        // we want for A, B, C. If it's negative, then we've got it flipped around and\n        // should swap A and C.\n        if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {\n            var temp = pointA;\n            pointA = pointC;\n            pointC = temp;\n        }\n        patterns[0] = pointA;\n        patterns[1] = pointB;\n        patterns[2] = pointC;\n    };\n    /**\n     * @param pattern1 first pattern\n     * @param pattern2 second pattern\n     * @return distance between two points\n     */\n    ResultPoint.distance = function (pattern1, pattern2) {\n        return MathUtils_1.default.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);\n    };\n    /**\n     * Returns the z component of the cross product between vectors BC and BA.\n     */\n    ResultPoint.crossProductZ = function (pointA, pointB, pointC) {\n        var bX = pointB.x;\n        var bY = pointB.y;\n        return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));\n    };\n    return ResultPoint;\n}());\nexports.default = ResultPoint;\n//# sourceMappingURL=ResultPoint.js.map"]},"metadata":{},"sourceType":"script"}