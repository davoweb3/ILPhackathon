{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common {*/\n/*import java.util.List;*/\n/**\n * <p>Encapsulates the result of decoding a matrix of bits. This typically\n * applies to 2D barcode formats. For now it contains the raw bytes obtained,\n * as well as a String interpretation of those bytes, if applicable.</p>\n *\n * @author Sean Owen\n */\nvar DecoderResult = /** @class */function () {\n  // public constructor(rawBytes: Uint8Array,\n  //                      text: string,\n  //                      List<Uint8Array> byteSegments,\n  //                      String ecLevel) {\n  //   this(rawBytes, text, byteSegments, ecLevel, -1, -1)\n  // }\n  function DecoderResult(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber, structuredAppendParity) {\n    if (structuredAppendSequenceNumber === void 0) {\n      structuredAppendSequenceNumber = -1;\n    }\n    if (structuredAppendParity === void 0) {\n      structuredAppendParity = -1;\n    }\n    this.rawBytes = rawBytes;\n    this.text = text;\n    this.byteSegments = byteSegments;\n    this.ecLevel = ecLevel;\n    this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;\n    this.structuredAppendParity = structuredAppendParity;\n    this.numBits = rawBytes === undefined || rawBytes === null ? 0 : 8 * rawBytes.length;\n  }\n  /**\n   * @return raw bytes representing the result, or {@code null} if not applicable\n   */\n  DecoderResult.prototype.getRawBytes = function () {\n    return this.rawBytes;\n  };\n  /**\n   * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length\n   * @since 3.3.0\n   */\n  DecoderResult.prototype.getNumBits = function () {\n    return this.numBits;\n  };\n  /**\n   * @param numBits overrides the number of bits that are valid in {@link #getRawBytes()}\n   * @since 3.3.0\n   */\n  DecoderResult.prototype.setNumBits = function (numBits /*int*/) {\n    this.numBits = numBits;\n  };\n  /**\n   * @return text representation of the result\n   */\n  DecoderResult.prototype.getText = function () {\n    return this.text;\n  };\n  /**\n   * @return list of byte segments in the result, or {@code null} if not applicable\n   */\n  DecoderResult.prototype.getByteSegments = function () {\n    return this.byteSegments;\n  };\n  /**\n   * @return name of error correction level used, or {@code null} if not applicable\n   */\n  DecoderResult.prototype.getECLevel = function () {\n    return this.ecLevel;\n  };\n  /**\n   * @return number of errors corrected, or {@code null} if not applicable\n   */\n  DecoderResult.prototype.getErrorsCorrected = function () {\n    return this.errorsCorrected;\n  };\n  DecoderResult.prototype.setErrorsCorrected = function (errorsCorrected /*Integer*/) {\n    this.errorsCorrected = errorsCorrected;\n  };\n  /**\n   * @return number of erasures corrected, or {@code null} if not applicable\n   */\n  DecoderResult.prototype.getErasures = function () {\n    return this.erasures;\n  };\n  DecoderResult.prototype.setErasures = function (erasures /*Integer*/) {\n    this.erasures = erasures;\n  };\n  /**\n   * @return arbitrary additional metadata\n   */\n  DecoderResult.prototype.getOther = function () {\n    return this.other;\n  };\n  DecoderResult.prototype.setOther = function (other) {\n    this.other = other;\n  };\n  DecoderResult.prototype.hasStructuredAppend = function () {\n    return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;\n  };\n  DecoderResult.prototype.getStructuredAppendParity = function () {\n    return this.structuredAppendParity;\n  };\n  DecoderResult.prototype.getStructuredAppendSequenceNumber = function () {\n    return this.structuredAppendSequenceNumber;\n  };\n  return DecoderResult;\n}();\nexports.default = DecoderResult;","map":{"version":3,"sources":["../../../src/core/common/DecoderResult.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.common {*/\n/*import java.util.List;*/\n/**\n * <p>Encapsulates the result of decoding a matrix of bits. This typically\n * applies to 2D barcode formats. For now it contains the raw bytes obtained,\n * as well as a String interpretation of those bytes, if applicable.</p>\n *\n * @author Sean Owen\n */\nvar DecoderResult = /** @class */ (function () {\n    // public constructor(rawBytes: Uint8Array,\n    //                      text: string,\n    //                      List<Uint8Array> byteSegments,\n    //                      String ecLevel) {\n    //   this(rawBytes, text, byteSegments, ecLevel, -1, -1)\n    // }\n    function DecoderResult(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber, structuredAppendParity) {\n        if (structuredAppendSequenceNumber === void 0) { structuredAppendSequenceNumber = -1; }\n        if (structuredAppendParity === void 0) { structuredAppendParity = -1; }\n        this.rawBytes = rawBytes;\n        this.text = text;\n        this.byteSegments = byteSegments;\n        this.ecLevel = ecLevel;\n        this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;\n        this.structuredAppendParity = structuredAppendParity;\n        this.numBits = (rawBytes === undefined || rawBytes === null) ? 0 : 8 * rawBytes.length;\n    }\n    /**\n     * @return raw bytes representing the result, or {@code null} if not applicable\n     */\n    DecoderResult.prototype.getRawBytes = function () {\n        return this.rawBytes;\n    };\n    /**\n     * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length\n     * @since 3.3.0\n     */\n    DecoderResult.prototype.getNumBits = function () {\n        return this.numBits;\n    };\n    /**\n     * @param numBits overrides the number of bits that are valid in {@link #getRawBytes()}\n     * @since 3.3.0\n     */\n    DecoderResult.prototype.setNumBits = function (numBits /*int*/) {\n        this.numBits = numBits;\n    };\n    /**\n     * @return text representation of the result\n     */\n    DecoderResult.prototype.getText = function () {\n        return this.text;\n    };\n    /**\n     * @return list of byte segments in the result, or {@code null} if not applicable\n     */\n    DecoderResult.prototype.getByteSegments = function () {\n        return this.byteSegments;\n    };\n    /**\n     * @return name of error correction level used, or {@code null} if not applicable\n     */\n    DecoderResult.prototype.getECLevel = function () {\n        return this.ecLevel;\n    };\n    /**\n     * @return number of errors corrected, or {@code null} if not applicable\n     */\n    DecoderResult.prototype.getErrorsCorrected = function () {\n        return this.errorsCorrected;\n    };\n    DecoderResult.prototype.setErrorsCorrected = function (errorsCorrected /*Integer*/) {\n        this.errorsCorrected = errorsCorrected;\n    };\n    /**\n     * @return number of erasures corrected, or {@code null} if not applicable\n     */\n    DecoderResult.prototype.getErasures = function () {\n        return this.erasures;\n    };\n    DecoderResult.prototype.setErasures = function (erasures /*Integer*/) {\n        this.erasures = erasures;\n    };\n    /**\n     * @return arbitrary additional metadata\n     */\n    DecoderResult.prototype.getOther = function () {\n        return this.other;\n    };\n    DecoderResult.prototype.setOther = function (other) {\n        this.other = other;\n    };\n    DecoderResult.prototype.hasStructuredAppend = function () {\n        return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;\n    };\n    DecoderResult.prototype.getStructuredAppendParity = function () {\n        return this.structuredAppendParity;\n    };\n    DecoderResult.prototype.getStructuredAppendSequenceNumber = function () {\n        return this.structuredAppendSequenceNumber;\n    };\n    return DecoderResult;\n}());\nexports.default = DecoderResult;\n//# sourceMappingURL=DecoderResult.js.map"]},"metadata":{},"sourceType":"script"}