{"ast":null,"code":"\"use strict\";\n\n/*\n* Copyright 2012 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n    i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// package com.google.zxing.pdf417.decoder.ec;\n// import com.google.zxing.ChecksumException;\nvar ChecksumException_1 = require(\"../../../ChecksumException\");\nvar ModulusPoly_1 = require(\"./ModulusPoly\");\nvar ModulusGF_1 = require(\"./ModulusGF\");\n/**\n * <p>PDF417 error correction implementation.</p>\n *\n * <p>This <a href=\"http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example\">example</a>\n * is quite useful in understanding the algorithm.</p>\n *\n * @author Sean Owen\n * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder\n */\nvar ErrorCorrection = /** @class */function () {\n  function ErrorCorrection() {\n    this.field = ModulusGF_1.default.PDF417_GF;\n  }\n  /**\n   * @param received received codewords\n   * @param numECCodewords number of those codewords used for EC\n   * @param erasures location of erasures\n   * @return number of errors\n   * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors\n   */\n  ErrorCorrection.prototype.decode = function (received, numECCodewords, erasures) {\n    var e_1, _a;\n    var poly = new ModulusPoly_1.default(this.field, received);\n    var S = new Int32Array(numECCodewords);\n    var error = false;\n    for (var i /*int*/ = numECCodewords; i > 0; i--) {\n      var evaluation = poly.evaluateAt(this.field.exp(i));\n      S[numECCodewords - i] = evaluation;\n      if (evaluation !== 0) {\n        error = true;\n      }\n    }\n    if (!error) {\n      return 0;\n    }\n    var knownErrors = this.field.getOne();\n    if (erasures != null) {\n      try {\n        for (var erasures_1 = __values(erasures), erasures_1_1 = erasures_1.next(); !erasures_1_1.done; erasures_1_1 = erasures_1.next()) {\n          var erasure = erasures_1_1.value;\n          var b = this.field.exp(received.length - 1 - erasure);\n          // Add (1 - bx) term:\n          var term = new ModulusPoly_1.default(this.field, new Int32Array([this.field.subtract(0, b), 1]));\n          knownErrors = knownErrors.multiply(term);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (erasures_1_1 && !erasures_1_1.done && (_a = erasures_1.return)) _a.call(erasures_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n    var syndrome = new ModulusPoly_1.default(this.field, S);\n    // syndrome = syndrome.multiply(knownErrors);\n    var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);\n    var sigma = sigmaOmega[0];\n    var omega = sigmaOmega[1];\n    // sigma = sigma.multiply(knownErrors);\n    var errorLocations = this.findErrorLocations(sigma);\n    var errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);\n    for (var i /*int*/ = 0; i < errorLocations.length; i++) {\n      var position = received.length - 1 - this.field.log(errorLocations[i]);\n      if (position < 0) {\n        throw ChecksumException_1.default.getChecksumInstance();\n      }\n      received[position] = this.field.subtract(received[position], errorMagnitudes[i]);\n    }\n    return errorLocations.length;\n  };\n  /**\n   *\n   * @param ModulusPoly\n   * @param a\n   * @param ModulusPoly\n   * @param b\n   * @param int\n   * @param R\n   * @throws ChecksumException\n   */\n  ErrorCorrection.prototype.runEuclideanAlgorithm = function (a, b, R) {\n    // Assume a's degree is >= b's\n    if (a.getDegree() < b.getDegree()) {\n      var temp = a;\n      a = b;\n      b = temp;\n    }\n    var rLast = a;\n    var r = b;\n    var tLast = this.field.getZero();\n    var t = this.field.getOne();\n    // Run Euclidean algorithm until r's degree is less than R/2\n    while (r.getDegree() >= Math.round(R / 2)) {\n      var rLastLast = rLast;\n      var tLastLast = tLast;\n      rLast = r;\n      tLast = t;\n      // Divide rLastLast by rLast, with quotient in q and remainder in r\n      if (rLast.isZero()) {\n        // Oops, Euclidean algorithm already terminated?\n        throw ChecksumException_1.default.getChecksumInstance();\n      }\n      r = rLastLast;\n      var q = this.field.getZero();\n      var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n      var dltInverse = this.field.inverse(denominatorLeadingTerm);\n      while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n        var degreeDiff = r.getDegree() - rLast.getDegree();\n        var scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n        q = q.add(this.field.buildMonomial(degreeDiff, scale));\n        r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));\n      }\n      t = q.multiply(tLast).subtract(tLastLast).negative();\n    }\n    var sigmaTildeAtZero = t.getCoefficient(0);\n    if (sigmaTildeAtZero === 0) {\n      throw ChecksumException_1.default.getChecksumInstance();\n    }\n    var inverse = this.field.inverse(sigmaTildeAtZero);\n    var sigma = t.multiply(inverse);\n    var omega = r.multiply(inverse);\n    return [sigma, omega];\n  };\n  /**\n   *\n   * @param errorLocator\n   * @throws ChecksumException\n   */\n  ErrorCorrection.prototype.findErrorLocations = function (errorLocator) {\n    // This is a direct application of Chien's search\n    var numErrors = errorLocator.getDegree();\n    var result = new Int32Array(numErrors);\n    var e = 0;\n    for (var i /*int*/ = 1; i < this.field.getSize() && e < numErrors; i++) {\n      if (errorLocator.evaluateAt(i) === 0) {\n        result[e] = this.field.inverse(i);\n        e++;\n      }\n    }\n    if (e !== numErrors) {\n      throw ChecksumException_1.default.getChecksumInstance();\n    }\n    return result;\n  };\n  ErrorCorrection.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocator, errorLocations) {\n    var errorLocatorDegree = errorLocator.getDegree();\n    var formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);\n    for (var i /*int*/ = 1; i <= errorLocatorDegree; i++) {\n      formalDerivativeCoefficients[errorLocatorDegree - i] = this.field.multiply(i, errorLocator.getCoefficient(i));\n    }\n    var formalDerivative = new ModulusPoly_1.default(this.field, formalDerivativeCoefficients);\n    // This is directly applying Forney's Formula\n    var s = errorLocations.length;\n    var result = new Int32Array(s);\n    for (var i /*int*/ = 0; i < s; i++) {\n      var xiInverse = this.field.inverse(errorLocations[i]);\n      var numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));\n      var denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));\n      result[i] = this.field.multiply(numerator, denominator);\n    }\n    return result;\n  };\n  return ErrorCorrection;\n}();\nexports.default = ErrorCorrection;","map":{"version":3,"sources":["../../../../../src/core/pdf417/decoder/ec/ErrorCorrection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n* Copyright 2012 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// package com.google.zxing.pdf417.decoder.ec;\n// import com.google.zxing.ChecksumException;\nvar ChecksumException_1 = require(\"../../../ChecksumException\");\nvar ModulusPoly_1 = require(\"./ModulusPoly\");\nvar ModulusGF_1 = require(\"./ModulusGF\");\n/**\n * <p>PDF417 error correction implementation.</p>\n *\n * <p>This <a href=\"http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example\">example</a>\n * is quite useful in understanding the algorithm.</p>\n *\n * @author Sean Owen\n * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder\n */\nvar ErrorCorrection = /** @class */ (function () {\n    function ErrorCorrection() {\n        this.field = ModulusGF_1.default.PDF417_GF;\n    }\n    /**\n     * @param received received codewords\n     * @param numECCodewords number of those codewords used for EC\n     * @param erasures location of erasures\n     * @return number of errors\n     * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors\n     */\n    ErrorCorrection.prototype.decode = function (received, numECCodewords, erasures) {\n        var e_1, _a;\n        var poly = new ModulusPoly_1.default(this.field, received);\n        var S = new Int32Array(numECCodewords);\n        var error = false;\n        for (var i /*int*/ = numECCodewords; i > 0; i--) {\n            var evaluation = poly.evaluateAt(this.field.exp(i));\n            S[numECCodewords - i] = evaluation;\n            if (evaluation !== 0) {\n                error = true;\n            }\n        }\n        if (!error) {\n            return 0;\n        }\n        var knownErrors = this.field.getOne();\n        if (erasures != null) {\n            try {\n                for (var erasures_1 = __values(erasures), erasures_1_1 = erasures_1.next(); !erasures_1_1.done; erasures_1_1 = erasures_1.next()) {\n                    var erasure = erasures_1_1.value;\n                    var b = this.field.exp(received.length - 1 - erasure);\n                    // Add (1 - bx) term:\n                    var term = new ModulusPoly_1.default(this.field, new Int32Array([this.field.subtract(0, b), 1]));\n                    knownErrors = knownErrors.multiply(term);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (erasures_1_1 && !erasures_1_1.done && (_a = erasures_1.return)) _a.call(erasures_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        var syndrome = new ModulusPoly_1.default(this.field, S);\n        // syndrome = syndrome.multiply(knownErrors);\n        var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);\n        var sigma = sigmaOmega[0];\n        var omega = sigmaOmega[1];\n        // sigma = sigma.multiply(knownErrors);\n        var errorLocations = this.findErrorLocations(sigma);\n        var errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);\n        for (var i /*int*/ = 0; i < errorLocations.length; i++) {\n            var position = received.length - 1 - this.field.log(errorLocations[i]);\n            if (position < 0) {\n                throw ChecksumException_1.default.getChecksumInstance();\n            }\n            received[position] = this.field.subtract(received[position], errorMagnitudes[i]);\n        }\n        return errorLocations.length;\n    };\n    /**\n     *\n     * @param ModulusPoly\n     * @param a\n     * @param ModulusPoly\n     * @param b\n     * @param int\n     * @param R\n     * @throws ChecksumException\n     */\n    ErrorCorrection.prototype.runEuclideanAlgorithm = function (a, b, R) {\n        // Assume a's degree is >= b's\n        if (a.getDegree() < b.getDegree()) {\n            var temp = a;\n            a = b;\n            b = temp;\n        }\n        var rLast = a;\n        var r = b;\n        var tLast = this.field.getZero();\n        var t = this.field.getOne();\n        // Run Euclidean algorithm until r's degree is less than R/2\n        while (r.getDegree() >= Math.round(R / 2)) {\n            var rLastLast = rLast;\n            var tLastLast = tLast;\n            rLast = r;\n            tLast = t;\n            // Divide rLastLast by rLast, with quotient in q and remainder in r\n            if (rLast.isZero()) {\n                // Oops, Euclidean algorithm already terminated?\n                throw ChecksumException_1.default.getChecksumInstance();\n            }\n            r = rLastLast;\n            var q = this.field.getZero();\n            var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n            var dltInverse = this.field.inverse(denominatorLeadingTerm);\n            while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n                var degreeDiff = r.getDegree() - rLast.getDegree();\n                var scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n                q = q.add(this.field.buildMonomial(degreeDiff, scale));\n                r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));\n            }\n            t = q.multiply(tLast).subtract(tLastLast).negative();\n        }\n        var sigmaTildeAtZero = t.getCoefficient(0);\n        if (sigmaTildeAtZero === 0) {\n            throw ChecksumException_1.default.getChecksumInstance();\n        }\n        var inverse = this.field.inverse(sigmaTildeAtZero);\n        var sigma = t.multiply(inverse);\n        var omega = r.multiply(inverse);\n        return [sigma, omega];\n    };\n    /**\n     *\n     * @param errorLocator\n     * @throws ChecksumException\n     */\n    ErrorCorrection.prototype.findErrorLocations = function (errorLocator) {\n        // This is a direct application of Chien's search\n        var numErrors = errorLocator.getDegree();\n        var result = new Int32Array(numErrors);\n        var e = 0;\n        for (var i /*int*/ = 1; i < this.field.getSize() && e < numErrors; i++) {\n            if (errorLocator.evaluateAt(i) === 0) {\n                result[e] = this.field.inverse(i);\n                e++;\n            }\n        }\n        if (e !== numErrors) {\n            throw ChecksumException_1.default.getChecksumInstance();\n        }\n        return result;\n    };\n    ErrorCorrection.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocator, errorLocations) {\n        var errorLocatorDegree = errorLocator.getDegree();\n        var formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);\n        for (var i /*int*/ = 1; i <= errorLocatorDegree; i++) {\n            formalDerivativeCoefficients[errorLocatorDegree - i] =\n                this.field.multiply(i, errorLocator.getCoefficient(i));\n        }\n        var formalDerivative = new ModulusPoly_1.default(this.field, formalDerivativeCoefficients);\n        // This is directly applying Forney's Formula\n        var s = errorLocations.length;\n        var result = new Int32Array(s);\n        for (var i /*int*/ = 0; i < s; i++) {\n            var xiInverse = this.field.inverse(errorLocations[i]);\n            var numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));\n            var denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));\n            result[i] = this.field.multiply(numerator, denominator);\n        }\n        return result;\n    };\n    return ErrorCorrection;\n}());\nexports.default = ErrorCorrection;\n//# sourceMappingURL=ErrorCorrection.js.map"]},"metadata":{},"sourceType":"script"}