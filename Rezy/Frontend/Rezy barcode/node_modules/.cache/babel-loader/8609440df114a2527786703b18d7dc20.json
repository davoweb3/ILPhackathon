{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common.reedsolomon {*/\nvar AbstractGenericGF_1 = require(\"./AbstractGenericGF\");\nvar System_1 = require(\"../../util/System\");\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\n/**\n * <p>Represents a polynomial whose coefficients are elements of a GF.\n * Instances of this class are immutable.</p>\n *\n * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\n * port of his C++ Reed-Solomon implementation.</p>\n *\n * @author Sean Owen\n */\nvar GenericGFPoly = /** @class */function () {\n  /**\n   * @param field the {@link GenericGF} instance representing the field to use\n   * to perform computations\n   * @param coefficients coefficients as ints representing elements of GF(size), arranged\n   * from most significant (highest-power term) coefficient to least significant\n   * @throws IllegalArgumentException if argument is null or empty,\n   * or if leading coefficient is 0 and this is not a\n   * constant polynomial (that is, it is not the monomial \"0\")\n   */\n  function GenericGFPoly(field, coefficients) {\n    if (coefficients.length === 0) {\n      throw new IllegalArgumentException_1.default();\n    }\n    this.field = field;\n    var coefficientsLength = coefficients.length;\n    if (coefficientsLength > 1 && coefficients[0] === 0) {\n      // Leading term must be non-zero for anything except the constant polynomial \"0\"\n      var firstNonZero = 1;\n      while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {\n        firstNonZero++;\n      }\n      if (firstNonZero === coefficientsLength) {\n        this.coefficients = Int32Array.from([0]);\n      } else {\n        this.coefficients = new Int32Array(coefficientsLength - firstNonZero);\n        System_1.default.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);\n      }\n    } else {\n      this.coefficients = coefficients;\n    }\n  }\n  GenericGFPoly.prototype.getCoefficients = function () {\n    return this.coefficients;\n  };\n  /**\n   * @return degree of this polynomial\n   */\n  GenericGFPoly.prototype.getDegree = function () {\n    return this.coefficients.length - 1;\n  };\n  /**\n   * @return true iff this polynomial is the monomial \"0\"\n   */\n  GenericGFPoly.prototype.isZero = function () {\n    return this.coefficients[0] === 0;\n  };\n  /**\n   * @return coefficient of x^degree term in this polynomial\n   */\n  GenericGFPoly.prototype.getCoefficient = function (degree /*int*/) {\n    return this.coefficients[this.coefficients.length - 1 - degree];\n  };\n  /**\n   * @return evaluation of this polynomial at a given point\n   */\n  GenericGFPoly.prototype.evaluateAt = function (a /*int*/) {\n    if (a === 0) {\n      // Just return the x^0 coefficient\n      return this.getCoefficient(0);\n    }\n    var coefficients = this.coefficients;\n    var result;\n    if (a === 1) {\n      // Just the sum of the coefficients\n      result = 0;\n      for (var i = 0, length_1 = coefficients.length; i !== length_1; i++) {\n        var coefficient = coefficients[i];\n        result = AbstractGenericGF_1.default.addOrSubtract(result, coefficient);\n      }\n      return result;\n    }\n    result = coefficients[0];\n    var size = coefficients.length;\n    var field = this.field;\n    for (var i = 1; i < size; i++) {\n      result = AbstractGenericGF_1.default.addOrSubtract(field.multiply(a, result), coefficients[i]);\n    }\n    return result;\n  };\n  GenericGFPoly.prototype.addOrSubtract = function (other) {\n    if (!this.field.equals(other.field)) {\n      throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');\n    }\n    if (this.isZero()) {\n      return other;\n    }\n    if (other.isZero()) {\n      return this;\n    }\n    var smallerCoefficients = this.coefficients;\n    var largerCoefficients = other.coefficients;\n    if (smallerCoefficients.length > largerCoefficients.length) {\n      var temp = smallerCoefficients;\n      smallerCoefficients = largerCoefficients;\n      largerCoefficients = temp;\n    }\n    var sumDiff = new Int32Array(largerCoefficients.length);\n    var lengthDiff = largerCoefficients.length - smallerCoefficients.length;\n    // Copy high-order terms only found in higher-degree polynomial's coefficients\n    System_1.default.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);\n    for (var i = lengthDiff; i < largerCoefficients.length; i++) {\n      sumDiff[i] = AbstractGenericGF_1.default.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);\n    }\n    return new GenericGFPoly(this.field, sumDiff);\n  };\n  GenericGFPoly.prototype.multiply = function (other) {\n    if (!this.field.equals(other.field)) {\n      throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');\n    }\n    if (this.isZero() || other.isZero()) {\n      return this.field.getZero();\n    }\n    var aCoefficients = this.coefficients;\n    var aLength = aCoefficients.length;\n    var bCoefficients = other.coefficients;\n    var bLength = bCoefficients.length;\n    var product = new Int32Array(aLength + bLength - 1);\n    var field = this.field;\n    for (var i = 0; i < aLength; i++) {\n      var aCoeff = aCoefficients[i];\n      for (var j = 0; j < bLength; j++) {\n        product[i + j] = AbstractGenericGF_1.default.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));\n      }\n    }\n    return new GenericGFPoly(field, product);\n  };\n  GenericGFPoly.prototype.multiplyScalar = function (scalar /*int*/) {\n    if (scalar === 0) {\n      return this.field.getZero();\n    }\n    if (scalar === 1) {\n      return this;\n    }\n    var size = this.coefficients.length;\n    var field = this.field;\n    var product = new Int32Array(size);\n    var coefficients = this.coefficients;\n    for (var i = 0; i < size; i++) {\n      product[i] = field.multiply(coefficients[i], scalar);\n    }\n    return new GenericGFPoly(field, product);\n  };\n  GenericGFPoly.prototype.multiplyByMonomial = function (degree /*int*/, coefficient /*int*/) {\n    if (degree < 0) {\n      throw new IllegalArgumentException_1.default();\n    }\n    if (coefficient === 0) {\n      return this.field.getZero();\n    }\n    var coefficients = this.coefficients;\n    var size = coefficients.length;\n    var product = new Int32Array(size + degree);\n    var field = this.field;\n    for (var i = 0; i < size; i++) {\n      product[i] = field.multiply(coefficients[i], coefficient);\n    }\n    return new GenericGFPoly(field, product);\n  };\n  GenericGFPoly.prototype.divide = function (other) {\n    if (!this.field.equals(other.field)) {\n      throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');\n    }\n    if (other.isZero()) {\n      throw new IllegalArgumentException_1.default('Divide by 0');\n    }\n    var field = this.field;\n    var quotient = field.getZero();\n    var remainder = this;\n    var denominatorLeadingTerm = other.getCoefficient(other.getDegree());\n    var inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);\n    while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {\n      var degreeDifference = remainder.getDegree() - other.getDegree();\n      var scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);\n      var term = other.multiplyByMonomial(degreeDifference, scale);\n      var iterationQuotient = field.buildMonomial(degreeDifference, scale);\n      quotient = quotient.addOrSubtract(iterationQuotient);\n      remainder = remainder.addOrSubtract(term);\n    }\n    return [quotient, remainder];\n  };\n  /*@Override*/\n  GenericGFPoly.prototype.toString = function () {\n    var result = '';\n    for (var degree = this.getDegree(); degree >= 0; degree--) {\n      var coefficient = this.getCoefficient(degree);\n      if (coefficient !== 0) {\n        if (coefficient < 0) {\n          result += ' - ';\n          coefficient = -coefficient;\n        } else {\n          if (result.length > 0) {\n            result += ' + ';\n          }\n        }\n        if (degree === 0 || coefficient !== 1) {\n          var alphaPower = this.field.log(coefficient);\n          if (alphaPower === 0) {\n            result += '1';\n          } else if (alphaPower === 1) {\n            result += 'a';\n          } else {\n            result += 'a^';\n            result += alphaPower;\n          }\n        }\n        if (degree !== 0) {\n          if (degree === 1) {\n            result += 'x';\n          } else {\n            result += 'x^';\n            result += degree;\n          }\n        }\n      }\n    }\n    return result;\n  };\n  return GenericGFPoly;\n}();\nexports.default = GenericGFPoly;","map":{"version":3,"sources":["../../../../src/core/common/reedsolomon/GenericGFPoly.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.common.reedsolomon {*/\nvar AbstractGenericGF_1 = require(\"./AbstractGenericGF\");\nvar System_1 = require(\"../../util/System\");\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\n/**\n * <p>Represents a polynomial whose coefficients are elements of a GF.\n * Instances of this class are immutable.</p>\n *\n * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\n * port of his C++ Reed-Solomon implementation.</p>\n *\n * @author Sean Owen\n */\nvar GenericGFPoly = /** @class */ (function () {\n    /**\n     * @param field the {@link GenericGF} instance representing the field to use\n     * to perform computations\n     * @param coefficients coefficients as ints representing elements of GF(size), arranged\n     * from most significant (highest-power term) coefficient to least significant\n     * @throws IllegalArgumentException if argument is null or empty,\n     * or if leading coefficient is 0 and this is not a\n     * constant polynomial (that is, it is not the monomial \"0\")\n     */\n    function GenericGFPoly(field, coefficients) {\n        if (coefficients.length === 0) {\n            throw new IllegalArgumentException_1.default();\n        }\n        this.field = field;\n        var coefficientsLength = coefficients.length;\n        if (coefficientsLength > 1 && coefficients[0] === 0) {\n            // Leading term must be non-zero for anything except the constant polynomial \"0\"\n            var firstNonZero = 1;\n            while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {\n                firstNonZero++;\n            }\n            if (firstNonZero === coefficientsLength) {\n                this.coefficients = Int32Array.from([0]);\n            }\n            else {\n                this.coefficients = new Int32Array(coefficientsLength - firstNonZero);\n                System_1.default.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);\n            }\n        }\n        else {\n            this.coefficients = coefficients;\n        }\n    }\n    GenericGFPoly.prototype.getCoefficients = function () {\n        return this.coefficients;\n    };\n    /**\n     * @return degree of this polynomial\n     */\n    GenericGFPoly.prototype.getDegree = function () {\n        return this.coefficients.length - 1;\n    };\n    /**\n     * @return true iff this polynomial is the monomial \"0\"\n     */\n    GenericGFPoly.prototype.isZero = function () {\n        return this.coefficients[0] === 0;\n    };\n    /**\n     * @return coefficient of x^degree term in this polynomial\n     */\n    GenericGFPoly.prototype.getCoefficient = function (degree /*int*/) {\n        return this.coefficients[this.coefficients.length - 1 - degree];\n    };\n    /**\n     * @return evaluation of this polynomial at a given point\n     */\n    GenericGFPoly.prototype.evaluateAt = function (a /*int*/) {\n        if (a === 0) {\n            // Just return the x^0 coefficient\n            return this.getCoefficient(0);\n        }\n        var coefficients = this.coefficients;\n        var result;\n        if (a === 1) {\n            // Just the sum of the coefficients\n            result = 0;\n            for (var i = 0, length_1 = coefficients.length; i !== length_1; i++) {\n                var coefficient = coefficients[i];\n                result = AbstractGenericGF_1.default.addOrSubtract(result, coefficient);\n            }\n            return result;\n        }\n        result = coefficients[0];\n        var size = coefficients.length;\n        var field = this.field;\n        for (var i = 1; i < size; i++) {\n            result = AbstractGenericGF_1.default.addOrSubtract(field.multiply(a, result), coefficients[i]);\n        }\n        return result;\n    };\n    GenericGFPoly.prototype.addOrSubtract = function (other) {\n        if (!this.field.equals(other.field)) {\n            throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');\n        }\n        if (this.isZero()) {\n            return other;\n        }\n        if (other.isZero()) {\n            return this;\n        }\n        var smallerCoefficients = this.coefficients;\n        var largerCoefficients = other.coefficients;\n        if (smallerCoefficients.length > largerCoefficients.length) {\n            var temp = smallerCoefficients;\n            smallerCoefficients = largerCoefficients;\n            largerCoefficients = temp;\n        }\n        var sumDiff = new Int32Array(largerCoefficients.length);\n        var lengthDiff = largerCoefficients.length - smallerCoefficients.length;\n        // Copy high-order terms only found in higher-degree polynomial's coefficients\n        System_1.default.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);\n        for (var i = lengthDiff; i < largerCoefficients.length; i++) {\n            sumDiff[i] = AbstractGenericGF_1.default.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);\n        }\n        return new GenericGFPoly(this.field, sumDiff);\n    };\n    GenericGFPoly.prototype.multiply = function (other) {\n        if (!this.field.equals(other.field)) {\n            throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');\n        }\n        if (this.isZero() || other.isZero()) {\n            return this.field.getZero();\n        }\n        var aCoefficients = this.coefficients;\n        var aLength = aCoefficients.length;\n        var bCoefficients = other.coefficients;\n        var bLength = bCoefficients.length;\n        var product = new Int32Array(aLength + bLength - 1);\n        var field = this.field;\n        for (var i = 0; i < aLength; i++) {\n            var aCoeff = aCoefficients[i];\n            for (var j = 0; j < bLength; j++) {\n                product[i + j] = AbstractGenericGF_1.default.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));\n            }\n        }\n        return new GenericGFPoly(field, product);\n    };\n    GenericGFPoly.prototype.multiplyScalar = function (scalar /*int*/) {\n        if (scalar === 0) {\n            return this.field.getZero();\n        }\n        if (scalar === 1) {\n            return this;\n        }\n        var size = this.coefficients.length;\n        var field = this.field;\n        var product = new Int32Array(size);\n        var coefficients = this.coefficients;\n        for (var i = 0; i < size; i++) {\n            product[i] = field.multiply(coefficients[i], scalar);\n        }\n        return new GenericGFPoly(field, product);\n    };\n    GenericGFPoly.prototype.multiplyByMonomial = function (degree /*int*/, coefficient /*int*/) {\n        if (degree < 0) {\n            throw new IllegalArgumentException_1.default();\n        }\n        if (coefficient === 0) {\n            return this.field.getZero();\n        }\n        var coefficients = this.coefficients;\n        var size = coefficients.length;\n        var product = new Int32Array(size + degree);\n        var field = this.field;\n        for (var i = 0; i < size; i++) {\n            product[i] = field.multiply(coefficients[i], coefficient);\n        }\n        return new GenericGFPoly(field, product);\n    };\n    GenericGFPoly.prototype.divide = function (other) {\n        if (!this.field.equals(other.field)) {\n            throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');\n        }\n        if (other.isZero()) {\n            throw new IllegalArgumentException_1.default('Divide by 0');\n        }\n        var field = this.field;\n        var quotient = field.getZero();\n        var remainder = this;\n        var denominatorLeadingTerm = other.getCoefficient(other.getDegree());\n        var inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);\n        while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {\n            var degreeDifference = remainder.getDegree() - other.getDegree();\n            var scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);\n            var term = other.multiplyByMonomial(degreeDifference, scale);\n            var iterationQuotient = field.buildMonomial(degreeDifference, scale);\n            quotient = quotient.addOrSubtract(iterationQuotient);\n            remainder = remainder.addOrSubtract(term);\n        }\n        return [quotient, remainder];\n    };\n    /*@Override*/\n    GenericGFPoly.prototype.toString = function () {\n        var result = '';\n        for (var degree = this.getDegree(); degree >= 0; degree--) {\n            var coefficient = this.getCoefficient(degree);\n            if (coefficient !== 0) {\n                if (coefficient < 0) {\n                    result += ' - ';\n                    coefficient = -coefficient;\n                }\n                else {\n                    if (result.length > 0) {\n                        result += ' + ';\n                    }\n                }\n                if (degree === 0 || coefficient !== 1) {\n                    var alphaPower = this.field.log(coefficient);\n                    if (alphaPower === 0) {\n                        result += '1';\n                    }\n                    else if (alphaPower === 1) {\n                        result += 'a';\n                    }\n                    else {\n                        result += 'a^';\n                        result += alphaPower;\n                    }\n                }\n                if (degree !== 0) {\n                    if (degree === 1) {\n                        result += 'x';\n                    }\n                    else {\n                        result += 'x^';\n                        result += degree;\n                    }\n                }\n            }\n        }\n        return result;\n    };\n    return GenericGFPoly;\n}());\nexports.default = GenericGFPoly;\n//# sourceMappingURL=GenericGFPoly.js.map"]},"metadata":{},"sourceType":"script"}