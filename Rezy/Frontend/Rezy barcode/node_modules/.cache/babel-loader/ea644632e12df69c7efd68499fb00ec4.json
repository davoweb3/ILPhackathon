{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.qrcode {*/\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\nvar EncodeHintType_1 = require(\"../EncodeHintType\");\nvar BitMatrix_1 = require(\"../common/BitMatrix\");\nvar ErrorCorrectionLevel_1 = require(\"./decoder/ErrorCorrectionLevel\");\nvar Encoder_1 = require(\"./encoder/Encoder\");\nvar IllegalArgumentException_1 = require(\"../IllegalArgumentException\");\nvar IllegalStateException_1 = require(\"../IllegalStateException\");\n/*import java.util.Map;*/\n/**\n * This object renders a QR Code as a BitMatrix 2D array of greyscale values.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar QRCodeWriter = /** @class */function () {\n  function QRCodeWriter() {}\n  /*@Override*/\n  // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix\n  //     /*throws WriterException */ {\n  //   return encode(contents, format, width, height, null)\n  // }\n  /*@Override*/\n  QRCodeWriter.prototype.encode = function (contents, format, width /*int*/, height /*int*/, hints) {\n    if (contents.length === 0) {\n      throw new IllegalArgumentException_1.default('Found empty contents');\n    }\n    if (format !== BarcodeFormat_1.default.QR_CODE) {\n      throw new IllegalArgumentException_1.default('Can only encode QR_CODE, but got ' + format);\n    }\n    if (width < 0 || height < 0) {\n      throw new IllegalArgumentException_1.default(\"Requested dimensions are too small: \" + width + \"x\" + height);\n    }\n    var errorCorrectionLevel = ErrorCorrectionLevel_1.default.L;\n    var quietZone = QRCodeWriter.QUIET_ZONE_SIZE;\n    if (hints !== null) {\n      if (undefined !== hints.get(EncodeHintType_1.default.ERROR_CORRECTION)) {\n        errorCorrectionLevel = ErrorCorrectionLevel_1.default.fromString(hints.get(EncodeHintType_1.default.ERROR_CORRECTION).toString());\n      }\n      if (undefined !== hints.get(EncodeHintType_1.default.MARGIN)) {\n        quietZone = Number.parseInt(hints.get(EncodeHintType_1.default.MARGIN).toString(), 10);\n      }\n    }\n    var code = Encoder_1.default.encode(contents, errorCorrectionLevel, hints);\n    return QRCodeWriter.renderResult(code, width, height, quietZone);\n  };\n  // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses\n  // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).\n  QRCodeWriter.renderResult = function (code, width /*int*/, height /*int*/, quietZone /*int*/) {\n    var input = code.getMatrix();\n    if (input === null) {\n      throw new IllegalStateException_1.default();\n    }\n    var inputWidth = input.getWidth();\n    var inputHeight = input.getHeight();\n    var qrWidth = inputWidth + quietZone * 2;\n    var qrHeight = inputHeight + quietZone * 2;\n    var outputWidth = Math.max(width, qrWidth);\n    var outputHeight = Math.max(height, qrHeight);\n    var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));\n    // Padding includes both the quiet zone and the extra white pixels to accommodate the requested\n    // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.\n    // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will\n    // handle all the padding from 100x100 (the actual QR) up to 200x160.\n    var leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);\n    var topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);\n    var output = new BitMatrix_1.default(outputWidth, outputHeight);\n    for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {\n      // Write the contents of this row of the barcode\n      for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {\n        if (input.get(inputX, inputY) === 1) {\n          output.setRegion(outputX, outputY, multiple, multiple);\n        }\n      }\n    }\n    return output;\n  };\n  QRCodeWriter.QUIET_ZONE_SIZE = 4;\n  return QRCodeWriter;\n}();\nexports.default = QRCodeWriter;","map":{"version":3,"sources":["../../../src/core/qrcode/QRCodeWriter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.qrcode {*/\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\nvar EncodeHintType_1 = require(\"../EncodeHintType\");\nvar BitMatrix_1 = require(\"../common/BitMatrix\");\nvar ErrorCorrectionLevel_1 = require(\"./decoder/ErrorCorrectionLevel\");\nvar Encoder_1 = require(\"./encoder/Encoder\");\nvar IllegalArgumentException_1 = require(\"../IllegalArgumentException\");\nvar IllegalStateException_1 = require(\"../IllegalStateException\");\n/*import java.util.Map;*/\n/**\n * This object renders a QR Code as a BitMatrix 2D array of greyscale values.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar QRCodeWriter = /** @class */ (function () {\n    function QRCodeWriter() {\n    }\n    /*@Override*/\n    // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix\n    //     /*throws WriterException */ {\n    //   return encode(contents, format, width, height, null)\n    // }\n    /*@Override*/\n    QRCodeWriter.prototype.encode = function (contents, format, width /*int*/, height /*int*/, hints) {\n        if (contents.length === 0) {\n            throw new IllegalArgumentException_1.default('Found empty contents');\n        }\n        if (format !== BarcodeFormat_1.default.QR_CODE) {\n            throw new IllegalArgumentException_1.default('Can only encode QR_CODE, but got ' + format);\n        }\n        if (width < 0 || height < 0) {\n            throw new IllegalArgumentException_1.default(\"Requested dimensions are too small: \" + width + \"x\" + height);\n        }\n        var errorCorrectionLevel = ErrorCorrectionLevel_1.default.L;\n        var quietZone = QRCodeWriter.QUIET_ZONE_SIZE;\n        if (hints !== null) {\n            if (undefined !== hints.get(EncodeHintType_1.default.ERROR_CORRECTION)) {\n                errorCorrectionLevel = ErrorCorrectionLevel_1.default.fromString(hints.get(EncodeHintType_1.default.ERROR_CORRECTION).toString());\n            }\n            if (undefined !== hints.get(EncodeHintType_1.default.MARGIN)) {\n                quietZone = Number.parseInt(hints.get(EncodeHintType_1.default.MARGIN).toString(), 10);\n            }\n        }\n        var code = Encoder_1.default.encode(contents, errorCorrectionLevel, hints);\n        return QRCodeWriter.renderResult(code, width, height, quietZone);\n    };\n    // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses\n    // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).\n    QRCodeWriter.renderResult = function (code, width /*int*/, height /*int*/, quietZone /*int*/) {\n        var input = code.getMatrix();\n        if (input === null) {\n            throw new IllegalStateException_1.default();\n        }\n        var inputWidth = input.getWidth();\n        var inputHeight = input.getHeight();\n        var qrWidth = inputWidth + (quietZone * 2);\n        var qrHeight = inputHeight + (quietZone * 2);\n        var outputWidth = Math.max(width, qrWidth);\n        var outputHeight = Math.max(height, qrHeight);\n        var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));\n        // Padding includes both the quiet zone and the extra white pixels to accommodate the requested\n        // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.\n        // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will\n        // handle all the padding from 100x100 (the actual QR) up to 200x160.\n        var leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);\n        var topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);\n        var output = new BitMatrix_1.default(outputWidth, outputHeight);\n        for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {\n            // Write the contents of this row of the barcode\n            for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {\n                if (input.get(inputX, inputY) === 1) {\n                    output.setRegion(outputX, outputY, multiple, multiple);\n                }\n            }\n        }\n        return output;\n    };\n    QRCodeWriter.QUIET_ZONE_SIZE = 4;\n    return QRCodeWriter;\n}());\nexports.default = QRCodeWriter;\n//# sourceMappingURL=QRCodeWriter.js.map"]},"metadata":{},"sourceType":"script"}