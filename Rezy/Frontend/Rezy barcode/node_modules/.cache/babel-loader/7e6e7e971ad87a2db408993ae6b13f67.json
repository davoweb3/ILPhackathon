{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common {*/\nvar IllegalArgumentException_1 = require(\"../IllegalArgumentException\");\n/**\n * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the\n * number of bits read is not often a multiple of 8.</p>\n *\n * <p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array\n * it passed in, in which case all bets are off.</p>\n *\n * @author Sean Owen\n */\nvar BitSource = /** @class */function () {\n  /**\n   * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.\n   * Bits are read within a byte from most-significant to least-significant bit.\n   */\n  function BitSource(bytes) {\n    this.bytes = bytes;\n    this.byteOffset = 0;\n    this.bitOffset = 0;\n  }\n  /**\n   * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.\n   */\n  BitSource.prototype.getBitOffset = function () {\n    return this.bitOffset;\n  };\n  /**\n   * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.\n   */\n  BitSource.prototype.getByteOffset = function () {\n    return this.byteOffset;\n  };\n  /**\n   * @param numBits number of bits to read\n   * @return int representing the bits read. The bits will appear as the least-significant\n   *         bits of the int\n   * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available\n   */\n  BitSource.prototype.readBits = function (numBits /*int*/) {\n    if (numBits < 1 || numBits > 32 || numBits > this.available()) {\n      throw new IllegalArgumentException_1.default('' + numBits);\n    }\n    var result = 0;\n    var bitOffset = this.bitOffset;\n    var byteOffset = this.byteOffset;\n    var bytes = this.bytes;\n    // First, read remainder from current byte\n    if (bitOffset > 0) {\n      var bitsLeft = 8 - bitOffset;\n      var toRead = numBits < bitsLeft ? numBits : bitsLeft;\n      var bitsToNotRead = bitsLeft - toRead;\n      var mask = 0xFF >> 8 - toRead << bitsToNotRead;\n      result = (bytes[byteOffset] & mask) >> bitsToNotRead;\n      numBits -= toRead;\n      bitOffset += toRead;\n      if (bitOffset === 8) {\n        bitOffset = 0;\n        byteOffset++;\n      }\n    }\n    // Next read whole bytes\n    if (numBits > 0) {\n      while (numBits >= 8) {\n        result = result << 8 | bytes[byteOffset] & 0xFF;\n        byteOffset++;\n        numBits -= 8;\n      }\n      // Finally read a partial byte\n      if (numBits > 0) {\n        var bitsToNotRead = 8 - numBits;\n        var mask = 0xFF >> bitsToNotRead << bitsToNotRead;\n        result = result << numBits | (bytes[byteOffset] & mask) >> bitsToNotRead;\n        bitOffset += numBits;\n      }\n    }\n    this.bitOffset = bitOffset;\n    this.byteOffset = byteOffset;\n    return result;\n  };\n  /**\n   * @return number of bits that can be read successfully\n   */\n  BitSource.prototype.available = function () {\n    return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;\n  };\n  return BitSource;\n}();\nexports.default = BitSource;","map":{"version":3,"sources":["../../../src/core/common/BitSource.ts"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;AAcG;;;;AAEH;AAGA,IAAA,0BAAA,GAAA,OAAA,CAAA,6BAAA,CAAA;AAEA;;;;;;;;AAQG;AACH,IAAA,SAAA,GAAA,aAAA,YAAA;EAKI;;;AAGG;EACH,SAAA,SAAA,CAA2B,KAAiB,EAAA;IAAjB,IAAA,CAAA,KAAK,GAAL,KAAK;IAC5B,IAAI,CAAC,UAAU,GAAG,CAAC;IACnB,IAAI,CAAC,SAAS,GAAG,CAAC;EACtB;EAEA;;AAEG;EACI,SAAA,CAAA,SAAA,CAAA,YAAY,GAAnB,YAAA;IACI,OAAO,IAAI,CAAC,SAAS;EACzB,CAAC;EAED;;AAEG;EACI,SAAA,CAAA,SAAA,CAAA,aAAa,GAApB,YAAA;IACI,OAAO,IAAI,CAAC,UAAU;EAC1B,CAAC;EAED;;;;;AAKG;EACI,SAAA,CAAA,SAAA,CAAA,QAAQ,GAAf,UAAgB,OAAe,CAAC,SAAO;IACnC,IAAI,OAAO,GAAG,CAAC,IAAI,OAAO,GAAG,EAAE,IAAI,OAAO,GAAG,IAAI,CAAC,SAAS,EAAE,EAAE;MAC3D,MAAM,IAAI,0BAAA,CAAA,OAAwB,CAAC,EAAE,GAAG,OAAO,CAAC;IACnD;IAED,IAAI,MAAM,GAAG,CAAC;IAEd,IAAI,SAAS,GAAG,IAAI,CAAC,SAAS;IAC9B,IAAI,UAAU,GAAG,IAAI,CAAC,UAAU;IAEhC,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK;IACxB;IACA,IAAI,SAAS,GAAG,CAAC,EAAE;MACf,IAAM,QAAQ,GAAG,CAAC,GAAG,SAAS;MAC9B,IAAM,MAAM,GAAG,OAAO,GAAG,QAAQ,GAAG,OAAO,GAAG,QAAQ;MACtD,IAAM,aAAa,GAAG,QAAQ,GAAG,MAAM;MACvC,IAAM,IAAI,GAAI,IAAI,IAAK,CAAC,GAAG,MAAO,IAAK,aAAa;MAEpD,MAAM,GAAG,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,IAAI,KAAK,aAAa;MACpD,OAAO,IAAI,MAAM;MACjB,SAAS,IAAI,MAAM;MAEnB,IAAI,SAAS,KAAK,CAAC,EAAE;QACjB,SAAS,GAAG,CAAC;QACb,UAAU,EAAE;MACf;IACJ;IAED;IACA,IAAI,OAAO,GAAG,CAAC,EAAE;MAEb,OAAO,OAAO,IAAI,CAAC,EAAE;QACjB,MAAM,GAAI,MAAM,IAAI,CAAC,GAAK,KAAK,CAAC,UAAU,CAAC,GAAG,IAAK;QACnD,UAAU,EAAE;QACZ,OAAO,IAAI,CAAC;MACf;MAED;MACA,IAAI,OAAO,GAAG,CAAC,EAAE;QACb,IAAM,aAAa,GAAG,CAAC,GAAG,OAAO;QACjC,IAAM,IAAI,GAAI,IAAI,IAAI,aAAa,IAAK,aAAa;QAErD,MAAM,GAAI,MAAM,IAAI,OAAO,GAAK,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,IAAI,KAAK,aAAc;QAC5E,SAAS,IAAI,OAAO;MACvB;IACJ;IAED,IAAI,CAAC,SAAS,GAAG,SAAS;IAC1B,IAAI,CAAC,UAAU,GAAG,UAAU;IAE5B,OAAO,MAAM;EACjB,CAAC;EAED;;AAEG;EACI,SAAA,CAAA,SAAA,CAAA,SAAS,GAAhB,YAAA;IACI,OAAO,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,SAAS;EACrE,CAAC;EAEL,OAAA,SAAC;AAAD,CAAC,EAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.common {*/\nvar IllegalArgumentException_1 = require(\"../IllegalArgumentException\");\n/**\n * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the\n * number of bits read is not often a multiple of 8.</p>\n *\n * <p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array\n * it passed in, in which case all bets are off.</p>\n *\n * @author Sean Owen\n */\nvar BitSource = /** @class */ (function () {\n    /**\n     * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.\n     * Bits are read within a byte from most-significant to least-significant bit.\n     */\n    function BitSource(bytes) {\n        this.bytes = bytes;\n        this.byteOffset = 0;\n        this.bitOffset = 0;\n    }\n    /**\n     * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.\n     */\n    BitSource.prototype.getBitOffset = function () {\n        return this.bitOffset;\n    };\n    /**\n     * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.\n     */\n    BitSource.prototype.getByteOffset = function () {\n        return this.byteOffset;\n    };\n    /**\n     * @param numBits number of bits to read\n     * @return int representing the bits read. The bits will appear as the least-significant\n     *         bits of the int\n     * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available\n     */\n    BitSource.prototype.readBits = function (numBits /*int*/) {\n        if (numBits < 1 || numBits > 32 || numBits > this.available()) {\n            throw new IllegalArgumentException_1.default('' + numBits);\n        }\n        var result = 0;\n        var bitOffset = this.bitOffset;\n        var byteOffset = this.byteOffset;\n        var bytes = this.bytes;\n        // First, read remainder from current byte\n        if (bitOffset > 0) {\n            var bitsLeft = 8 - bitOffset;\n            var toRead = numBits < bitsLeft ? numBits : bitsLeft;\n            var bitsToNotRead = bitsLeft - toRead;\n            var mask = (0xFF >> (8 - toRead)) << bitsToNotRead;\n            result = (bytes[byteOffset] & mask) >> bitsToNotRead;\n            numBits -= toRead;\n            bitOffset += toRead;\n            if (bitOffset === 8) {\n                bitOffset = 0;\n                byteOffset++;\n            }\n        }\n        // Next read whole bytes\n        if (numBits > 0) {\n            while (numBits >= 8) {\n                result = (result << 8) | (bytes[byteOffset] & 0xFF);\n                byteOffset++;\n                numBits -= 8;\n            }\n            // Finally read a partial byte\n            if (numBits > 0) {\n                var bitsToNotRead = 8 - numBits;\n                var mask = (0xFF >> bitsToNotRead) << bitsToNotRead;\n                result = (result << numBits) | ((bytes[byteOffset] & mask) >> bitsToNotRead);\n                bitOffset += numBits;\n            }\n        }\n        this.bitOffset = bitOffset;\n        this.byteOffset = byteOffset;\n        return result;\n    };\n    /**\n     * @return number of bits that can be read successfully\n     */\n    BitSource.prototype.available = function () {\n        return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;\n    };\n    return BitSource;\n}());\nexports.default = BitSource;\n//# sourceMappingURL=BitSource.js.map"]},"metadata":{},"sourceType":"script"}