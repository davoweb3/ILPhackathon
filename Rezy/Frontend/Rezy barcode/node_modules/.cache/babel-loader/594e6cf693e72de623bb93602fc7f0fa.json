{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ResultPoint_1 = require(\"../../ResultPoint\");\nvar DetectorResult_1 = require(\"../../common/DetectorResult\");\nvar GridSamplerInstance_1 = require(\"../../common/GridSamplerInstance\");\nvar WhiteRectangleDetector_1 = require(\"../../common/detector/WhiteRectangleDetector\");\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * <p>Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code\n * is rotated or skewed, or partially obscured.</p>\n *\n * @author Sean Owen\n */\nvar Detector = /** @class */function () {\n  function Detector(image) {\n    this.image = image;\n    this.rectangleDetector = new WhiteRectangleDetector_1.default(this.image);\n  }\n  /**\n   * <p>Detects a Data Matrix Code in an image.</p>\n   *\n   * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code\n   * @throws NotFoundException if no Data Matrix Code can be found\n   */\n  Detector.prototype.detect = function () {\n    var cornerPoints = this.rectangleDetector.detect();\n    var points = this.detectSolid1(cornerPoints);\n    points = this.detectSolid2(points);\n    points[3] = this.correctTopRight(points);\n    if (!points[3]) {\n      throw new NotFoundException_1.default();\n    }\n    points = this.shiftToModuleCenter(points);\n    var topLeft = points[0];\n    var bottomLeft = points[1];\n    var bottomRight = points[2];\n    var topRight = points[3];\n    var dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;\n    var dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;\n    if ((dimensionTop & 0x01) === 1) {\n      dimensionTop += 1;\n    }\n    if ((dimensionRight & 0x01) === 1) {\n      dimensionRight += 1;\n    }\n    if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {\n      // The matrix is square\n      dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);\n    }\n    var bits = Detector.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);\n    return new DetectorResult_1.default(bits, [topLeft, bottomLeft, bottomRight, topRight]);\n  };\n  Detector.shiftPoint = function (point, to, div) {\n    var x = (to.getX() - point.getX()) / (div + 1);\n    var y = (to.getY() - point.getY()) / (div + 1);\n    return new ResultPoint_1.default(point.getX() + x, point.getY() + y);\n  };\n  Detector.moveAway = function (point, fromX, fromY) {\n    var x = point.getX();\n    var y = point.getY();\n    if (x < fromX) {\n      x -= 1;\n    } else {\n      x += 1;\n    }\n    if (y < fromY) {\n      y -= 1;\n    } else {\n      y += 1;\n    }\n    return new ResultPoint_1.default(x, y);\n  };\n  /**\n   * Detect a solid side which has minimum transition.\n   */\n  Detector.prototype.detectSolid1 = function (cornerPoints) {\n    // 0  2\n    // 1  3\n    var pointA = cornerPoints[0];\n    var pointB = cornerPoints[1];\n    var pointC = cornerPoints[3];\n    var pointD = cornerPoints[2];\n    var trAB = this.transitionsBetween(pointA, pointB);\n    var trBC = this.transitionsBetween(pointB, pointC);\n    var trCD = this.transitionsBetween(pointC, pointD);\n    var trDA = this.transitionsBetween(pointD, pointA);\n    // 0..3\n    // :  :\n    // 1--2\n    var min = trAB;\n    var points = [pointD, pointA, pointB, pointC];\n    if (min > trBC) {\n      min = trBC;\n      points[0] = pointA;\n      points[1] = pointB;\n      points[2] = pointC;\n      points[3] = pointD;\n    }\n    if (min > trCD) {\n      min = trCD;\n      points[0] = pointB;\n      points[1] = pointC;\n      points[2] = pointD;\n      points[3] = pointA;\n    }\n    if (min > trDA) {\n      points[0] = pointC;\n      points[1] = pointD;\n      points[2] = pointA;\n      points[3] = pointB;\n    }\n    return points;\n  };\n  /**\n   * Detect a second solid side next to first solid side.\n   */\n  Detector.prototype.detectSolid2 = function (points) {\n    // A..D\n    // :  :\n    // B--C\n    var pointA = points[0];\n    var pointB = points[1];\n    var pointC = points[2];\n    var pointD = points[3];\n    // Transition detection on the edge is not stable.\n    // To safely detect, shift the points to the module center.\n    var tr = this.transitionsBetween(pointA, pointD);\n    var pointBs = Detector.shiftPoint(pointB, pointC, (tr + 1) * 4);\n    var pointCs = Detector.shiftPoint(pointC, pointB, (tr + 1) * 4);\n    var trBA = this.transitionsBetween(pointBs, pointA);\n    var trCD = this.transitionsBetween(pointCs, pointD);\n    // 0..3\n    // |  :\n    // 1--2\n    if (trBA < trCD) {\n      // solid sides: A-B-C\n      points[0] = pointA;\n      points[1] = pointB;\n      points[2] = pointC;\n      points[3] = pointD;\n    } else {\n      // solid sides: B-C-D\n      points[0] = pointB;\n      points[1] = pointC;\n      points[2] = pointD;\n      points[3] = pointA;\n    }\n    return points;\n  };\n  /**\n   * Calculates the corner position of the white top right module.\n   */\n  Detector.prototype.correctTopRight = function (points) {\n    // A..D\n    // |  :\n    // B--C\n    var pointA = points[0];\n    var pointB = points[1];\n    var pointC = points[2];\n    var pointD = points[3];\n    // shift points for safe transition detection.\n    var trTop = this.transitionsBetween(pointA, pointD);\n    var trRight = this.transitionsBetween(pointB, pointD);\n    var pointAs = Detector.shiftPoint(pointA, pointB, (trRight + 1) * 4);\n    var pointCs = Detector.shiftPoint(pointC, pointB, (trTop + 1) * 4);\n    trTop = this.transitionsBetween(pointAs, pointD);\n    trRight = this.transitionsBetween(pointCs, pointD);\n    var candidate1 = new ResultPoint_1.default(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));\n    var candidate2 = new ResultPoint_1.default(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));\n    if (!this.isValid(candidate1)) {\n      if (this.isValid(candidate2)) {\n        return candidate2;\n      }\n      return null;\n    }\n    if (!this.isValid(candidate2)) {\n      return candidate1;\n    }\n    var sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);\n    var sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);\n    if (sumc1 > sumc2) {\n      return candidate1;\n    } else {\n      return candidate2;\n    }\n  };\n  /**\n   * Shift the edge points to the module center.\n   */\n  Detector.prototype.shiftToModuleCenter = function (points) {\n    // A..D\n    // |  :\n    // B--C\n    var pointA = points[0];\n    var pointB = points[1];\n    var pointC = points[2];\n    var pointD = points[3];\n    // calculate pseudo dimensions\n    var dimH = this.transitionsBetween(pointA, pointD) + 1;\n    var dimV = this.transitionsBetween(pointC, pointD) + 1;\n    // shift points for safe dimension detection\n    var pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);\n    var pointCs = Detector.shiftPoint(pointC, pointB, dimH * 4);\n    //  calculate more precise dimensions\n    dimH = this.transitionsBetween(pointAs, pointD) + 1;\n    dimV = this.transitionsBetween(pointCs, pointD) + 1;\n    if ((dimH & 0x01) === 1) {\n      dimH += 1;\n    }\n    if ((dimV & 0x01) === 1) {\n      dimV += 1;\n    }\n    // WhiteRectangleDetector returns points inside of the rectangle.\n    // I want points on the edges.\n    var centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;\n    var centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;\n    pointA = Detector.moveAway(pointA, centerX, centerY);\n    pointB = Detector.moveAway(pointB, centerX, centerY);\n    pointC = Detector.moveAway(pointC, centerX, centerY);\n    pointD = Detector.moveAway(pointD, centerX, centerY);\n    var pointBs;\n    var pointDs;\n    // shift points to the center of each modules\n    pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);\n    pointAs = Detector.shiftPoint(pointAs, pointD, dimH * 4);\n    pointBs = Detector.shiftPoint(pointB, pointA, dimV * 4);\n    pointBs = Detector.shiftPoint(pointBs, pointC, dimH * 4);\n    pointCs = Detector.shiftPoint(pointC, pointD, dimV * 4);\n    pointCs = Detector.shiftPoint(pointCs, pointB, dimH * 4);\n    pointDs = Detector.shiftPoint(pointD, pointC, dimV * 4);\n    pointDs = Detector.shiftPoint(pointDs, pointA, dimH * 4);\n    return [pointAs, pointBs, pointCs, pointDs];\n  };\n  Detector.prototype.isValid = function (p) {\n    return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();\n  };\n  Detector.sampleGrid = function (image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {\n    var sampler = GridSamplerInstance_1.default.getInstance();\n    return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n  };\n  /**\n   * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.\n   */\n  Detector.prototype.transitionsBetween = function (from, to) {\n    // See QR Code Detector, sizeOfBlackWhiteBlackRun()\n    var fromX = Math.trunc(from.getX());\n    var fromY = Math.trunc(from.getY());\n    var toX = Math.trunc(to.getX());\n    var toY = Math.trunc(to.getY());\n    var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n    if (steep) {\n      var temp = fromX;\n      fromX = fromY;\n      fromY = temp;\n      temp = toX;\n      toX = toY;\n      toY = temp;\n    }\n    var dx = Math.abs(toX - fromX);\n    var dy = Math.abs(toY - fromY);\n    var error = -dx / 2;\n    var ystep = fromY < toY ? 1 : -1;\n    var xstep = fromX < toX ? 1 : -1;\n    var transitions = 0;\n    var inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);\n    for (var x = fromX, y = fromY; x !== toX; x += xstep) {\n      var isBlack = this.image.get(steep ? y : x, steep ? x : y);\n      if (isBlack !== inBlack) {\n        transitions++;\n        inBlack = isBlack;\n      }\n      error += dy;\n      if (error > 0) {\n        if (y === toY) {\n          break;\n        }\n        y += ystep;\n        error -= dx;\n      }\n    }\n    return transitions;\n  };\n  return Detector;\n}();\nexports.default = Detector;","map":{"version":3,"sources":["../../../../src/core/datamatrix/detector/Detector.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ResultPoint_1 = require(\"../../ResultPoint\");\nvar DetectorResult_1 = require(\"../../common/DetectorResult\");\nvar GridSamplerInstance_1 = require(\"../../common/GridSamplerInstance\");\nvar WhiteRectangleDetector_1 = require(\"../../common/detector/WhiteRectangleDetector\");\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * <p>Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code\n * is rotated or skewed, or partially obscured.</p>\n *\n * @author Sean Owen\n */\nvar Detector = /** @class */ (function () {\n    function Detector(image) {\n        this.image = image;\n        this.rectangleDetector = new WhiteRectangleDetector_1.default(this.image);\n    }\n    /**\n     * <p>Detects a Data Matrix Code in an image.</p>\n     *\n     * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code\n     * @throws NotFoundException if no Data Matrix Code can be found\n     */\n    Detector.prototype.detect = function () {\n        var cornerPoints = this.rectangleDetector.detect();\n        var points = this.detectSolid1(cornerPoints);\n        points = this.detectSolid2(points);\n        points[3] = this.correctTopRight(points);\n        if (!points[3]) {\n            throw new NotFoundException_1.default();\n        }\n        points = this.shiftToModuleCenter(points);\n        var topLeft = points[0];\n        var bottomLeft = points[1];\n        var bottomRight = points[2];\n        var topRight = points[3];\n        var dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;\n        var dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;\n        if ((dimensionTop & 0x01) === 1) {\n            dimensionTop += 1;\n        }\n        if ((dimensionRight & 0x01) === 1) {\n            dimensionRight += 1;\n        }\n        if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {\n            // The matrix is square\n            dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);\n        }\n        var bits = Detector.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);\n        return new DetectorResult_1.default(bits, [topLeft, bottomLeft, bottomRight, topRight]);\n    };\n    Detector.shiftPoint = function (point, to, div) {\n        var x = (to.getX() - point.getX()) / (div + 1);\n        var y = (to.getY() - point.getY()) / (div + 1);\n        return new ResultPoint_1.default(point.getX() + x, point.getY() + y);\n    };\n    Detector.moveAway = function (point, fromX, fromY) {\n        var x = point.getX();\n        var y = point.getY();\n        if (x < fromX) {\n            x -= 1;\n        }\n        else {\n            x += 1;\n        }\n        if (y < fromY) {\n            y -= 1;\n        }\n        else {\n            y += 1;\n        }\n        return new ResultPoint_1.default(x, y);\n    };\n    /**\n     * Detect a solid side which has minimum transition.\n     */\n    Detector.prototype.detectSolid1 = function (cornerPoints) {\n        // 0  2\n        // 1  3\n        var pointA = cornerPoints[0];\n        var pointB = cornerPoints[1];\n        var pointC = cornerPoints[3];\n        var pointD = cornerPoints[2];\n        var trAB = this.transitionsBetween(pointA, pointB);\n        var trBC = this.transitionsBetween(pointB, pointC);\n        var trCD = this.transitionsBetween(pointC, pointD);\n        var trDA = this.transitionsBetween(pointD, pointA);\n        // 0..3\n        // :  :\n        // 1--2\n        var min = trAB;\n        var points = [pointD, pointA, pointB, pointC];\n        if (min > trBC) {\n            min = trBC;\n            points[0] = pointA;\n            points[1] = pointB;\n            points[2] = pointC;\n            points[3] = pointD;\n        }\n        if (min > trCD) {\n            min = trCD;\n            points[0] = pointB;\n            points[1] = pointC;\n            points[2] = pointD;\n            points[3] = pointA;\n        }\n        if (min > trDA) {\n            points[0] = pointC;\n            points[1] = pointD;\n            points[2] = pointA;\n            points[3] = pointB;\n        }\n        return points;\n    };\n    /**\n     * Detect a second solid side next to first solid side.\n     */\n    Detector.prototype.detectSolid2 = function (points) {\n        // A..D\n        // :  :\n        // B--C\n        var pointA = points[0];\n        var pointB = points[1];\n        var pointC = points[2];\n        var pointD = points[3];\n        // Transition detection on the edge is not stable.\n        // To safely detect, shift the points to the module center.\n        var tr = this.transitionsBetween(pointA, pointD);\n        var pointBs = Detector.shiftPoint(pointB, pointC, (tr + 1) * 4);\n        var pointCs = Detector.shiftPoint(pointC, pointB, (tr + 1) * 4);\n        var trBA = this.transitionsBetween(pointBs, pointA);\n        var trCD = this.transitionsBetween(pointCs, pointD);\n        // 0..3\n        // |  :\n        // 1--2\n        if (trBA < trCD) {\n            // solid sides: A-B-C\n            points[0] = pointA;\n            points[1] = pointB;\n            points[2] = pointC;\n            points[3] = pointD;\n        }\n        else {\n            // solid sides: B-C-D\n            points[0] = pointB;\n            points[1] = pointC;\n            points[2] = pointD;\n            points[3] = pointA;\n        }\n        return points;\n    };\n    /**\n     * Calculates the corner position of the white top right module.\n     */\n    Detector.prototype.correctTopRight = function (points) {\n        // A..D\n        // |  :\n        // B--C\n        var pointA = points[0];\n        var pointB = points[1];\n        var pointC = points[2];\n        var pointD = points[3];\n        // shift points for safe transition detection.\n        var trTop = this.transitionsBetween(pointA, pointD);\n        var trRight = this.transitionsBetween(pointB, pointD);\n        var pointAs = Detector.shiftPoint(pointA, pointB, (trRight + 1) * 4);\n        var pointCs = Detector.shiftPoint(pointC, pointB, (trTop + 1) * 4);\n        trTop = this.transitionsBetween(pointAs, pointD);\n        trRight = this.transitionsBetween(pointCs, pointD);\n        var candidate1 = new ResultPoint_1.default(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));\n        var candidate2 = new ResultPoint_1.default(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));\n        if (!this.isValid(candidate1)) {\n            if (this.isValid(candidate2)) {\n                return candidate2;\n            }\n            return null;\n        }\n        if (!this.isValid(candidate2)) {\n            return candidate1;\n        }\n        var sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);\n        var sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);\n        if (sumc1 > sumc2) {\n            return candidate1;\n        }\n        else {\n            return candidate2;\n        }\n    };\n    /**\n     * Shift the edge points to the module center.\n     */\n    Detector.prototype.shiftToModuleCenter = function (points) {\n        // A..D\n        // |  :\n        // B--C\n        var pointA = points[0];\n        var pointB = points[1];\n        var pointC = points[2];\n        var pointD = points[3];\n        // calculate pseudo dimensions\n        var dimH = this.transitionsBetween(pointA, pointD) + 1;\n        var dimV = this.transitionsBetween(pointC, pointD) + 1;\n        // shift points for safe dimension detection\n        var pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);\n        var pointCs = Detector.shiftPoint(pointC, pointB, dimH * 4);\n        //  calculate more precise dimensions\n        dimH = this.transitionsBetween(pointAs, pointD) + 1;\n        dimV = this.transitionsBetween(pointCs, pointD) + 1;\n        if ((dimH & 0x01) === 1) {\n            dimH += 1;\n        }\n        if ((dimV & 0x01) === 1) {\n            dimV += 1;\n        }\n        // WhiteRectangleDetector returns points inside of the rectangle.\n        // I want points on the edges.\n        var centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;\n        var centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;\n        pointA = Detector.moveAway(pointA, centerX, centerY);\n        pointB = Detector.moveAway(pointB, centerX, centerY);\n        pointC = Detector.moveAway(pointC, centerX, centerY);\n        pointD = Detector.moveAway(pointD, centerX, centerY);\n        var pointBs;\n        var pointDs;\n        // shift points to the center of each modules\n        pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);\n        pointAs = Detector.shiftPoint(pointAs, pointD, dimH * 4);\n        pointBs = Detector.shiftPoint(pointB, pointA, dimV * 4);\n        pointBs = Detector.shiftPoint(pointBs, pointC, dimH * 4);\n        pointCs = Detector.shiftPoint(pointC, pointD, dimV * 4);\n        pointCs = Detector.shiftPoint(pointCs, pointB, dimH * 4);\n        pointDs = Detector.shiftPoint(pointD, pointC, dimV * 4);\n        pointDs = Detector.shiftPoint(pointDs, pointA, dimH * 4);\n        return [pointAs, pointBs, pointCs, pointDs];\n    };\n    Detector.prototype.isValid = function (p) {\n        return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();\n    };\n    Detector.sampleGrid = function (image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {\n        var sampler = GridSamplerInstance_1.default.getInstance();\n        return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n    };\n    /**\n     * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.\n     */\n    Detector.prototype.transitionsBetween = function (from, to) {\n        // See QR Code Detector, sizeOfBlackWhiteBlackRun()\n        var fromX = Math.trunc(from.getX());\n        var fromY = Math.trunc(from.getY());\n        var toX = Math.trunc(to.getX());\n        var toY = Math.trunc(to.getY());\n        var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n        if (steep) {\n            var temp = fromX;\n            fromX = fromY;\n            fromY = temp;\n            temp = toX;\n            toX = toY;\n            toY = temp;\n        }\n        var dx = Math.abs(toX - fromX);\n        var dy = Math.abs(toY - fromY);\n        var error = -dx / 2;\n        var ystep = fromY < toY ? 1 : -1;\n        var xstep = fromX < toX ? 1 : -1;\n        var transitions = 0;\n        var inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);\n        for (var x = fromX, y = fromY; x !== toX; x += xstep) {\n            var isBlack = this.image.get(steep ? y : x, steep ? x : y);\n            if (isBlack !== inBlack) {\n                transitions++;\n                inBlack = isBlack;\n            }\n            error += dy;\n            if (error > 0) {\n                if (y === toY) {\n                    break;\n                }\n                y += ystep;\n                error -= dx;\n            }\n        }\n        return transitions;\n    };\n    return Detector;\n}());\nexports.default = Detector;\n//# sourceMappingURL=Detector.js.map"]},"metadata":{},"sourceType":"script"}