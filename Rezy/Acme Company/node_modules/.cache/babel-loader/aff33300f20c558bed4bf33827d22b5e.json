{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar IllegalArgumentException_1 = require(\"./IllegalArgumentException\");\nvar BinaryBitmap = /** @class */function () {\n  function BinaryBitmap(binarizer) {\n    this.binarizer = binarizer;\n    if (binarizer === null) {\n      throw new IllegalArgumentException_1.default('Binarizer must be non-null.');\n    }\n  }\n  /**\n   * @return The width of the bitmap.\n   */\n  BinaryBitmap.prototype.getWidth = function () {\n    return this.binarizer.getWidth();\n  };\n  /**\n   * @return The height of the bitmap.\n   */\n  BinaryBitmap.prototype.getHeight = function () {\n    return this.binarizer.getHeight();\n  };\n  /**\n   * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return\n   * cached data. Callers should assume this method is expensive and call it as seldom as possible.\n   * This method is intended for decoding 1D barcodes and may choose to apply sharpening.\n   *\n   * @param y The row to fetch, which must be in [0, bitmap height)\n   * @param row An optional preallocated array. If null or too small, it will be ignored.\n   *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.\n   * @return The array of bits for this row (true means black).\n   * @throws NotFoundException if row can't be binarized\n   */\n  BinaryBitmap.prototype.getBlackRow = function (y /*int*/, row) {\n    return this.binarizer.getBlackRow(y, row);\n  };\n  /**\n   * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive\n   * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or\n   * may not apply sharpening. Therefore, a row from this matrix may not be identical to one\n   * fetched using getBlackRow(), so don't mix and match between them.\n   *\n   * @return The 2D array of bits for the image (true means black).\n   * @throws NotFoundException if image can't be binarized to make a matrix\n   */\n  BinaryBitmap.prototype.getBlackMatrix = function () {\n    // The matrix is created on demand the first time it is requested, then cached. There are two\n    // reasons for this:\n    // 1. This work will never be done if the caller only installs 1D Reader objects, or if a\n    //    1D Reader finds a barcode before the 2D Readers run.\n    // 2. This work will only be done once even if the caller installs multiple 2D Readers.\n    if (this.matrix === null || this.matrix === undefined) {\n      this.matrix = this.binarizer.getBlackMatrix();\n    }\n    return this.matrix;\n  };\n  /**\n   * @return Whether this bitmap can be cropped.\n   */\n  BinaryBitmap.prototype.isCropSupported = function () {\n    return this.binarizer.getLuminanceSource().isCropSupported();\n  };\n  /**\n   * Returns a new object with cropped image data. Implementations may keep a reference to the\n   * original data rather than a copy. Only callable if isCropSupported() is true.\n   *\n   * @param left The left coordinate, which must be in [0,getWidth())\n   * @param top The top coordinate, which must be in [0,getHeight())\n   * @param width The width of the rectangle to crop.\n   * @param height The height of the rectangle to crop.\n   * @return A cropped version of this object.\n   */\n  BinaryBitmap.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n    var newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);\n    return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n  };\n  /**\n   * @return Whether this bitmap supports counter-clockwise rotation.\n   */\n  BinaryBitmap.prototype.isRotateSupported = function () {\n    return this.binarizer.getLuminanceSource().isRotateSupported();\n  };\n  /**\n   * Returns a new object with rotated image data by 90 degrees counterclockwise.\n   * Only callable if {@link #isRotateSupported()} is true.\n   *\n   * @return A rotated version of this object.\n   */\n  BinaryBitmap.prototype.rotateCounterClockwise = function () {\n    var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();\n    return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n  };\n  /**\n   * Returns a new object with rotated image data by 45 degrees counterclockwise.\n   * Only callable if {@link #isRotateSupported()} is true.\n   *\n   * @return A rotated version of this object.\n   */\n  BinaryBitmap.prototype.rotateCounterClockwise45 = function () {\n    var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();\n    return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n  };\n  /*@Override*/\n  BinaryBitmap.prototype.toString = function () {\n    try {\n      return this.getBlackMatrix().toString();\n    } catch (e /*: NotFoundException*/) {\n      return '';\n    }\n  };\n  return BinaryBitmap;\n}();\nexports.default = BinaryBitmap;","map":{"version":3,"sources":["../../src/core/BinaryBitmap.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar IllegalArgumentException_1 = require(\"./IllegalArgumentException\");\nvar BinaryBitmap = /** @class */ (function () {\n    function BinaryBitmap(binarizer) {\n        this.binarizer = binarizer;\n        if (binarizer === null) {\n            throw new IllegalArgumentException_1.default('Binarizer must be non-null.');\n        }\n    }\n    /**\n     * @return The width of the bitmap.\n     */\n    BinaryBitmap.prototype.getWidth = function () {\n        return this.binarizer.getWidth();\n    };\n    /**\n     * @return The height of the bitmap.\n     */\n    BinaryBitmap.prototype.getHeight = function () {\n        return this.binarizer.getHeight();\n    };\n    /**\n     * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return\n     * cached data. Callers should assume this method is expensive and call it as seldom as possible.\n     * This method is intended for decoding 1D barcodes and may choose to apply sharpening.\n     *\n     * @param y The row to fetch, which must be in [0, bitmap height)\n     * @param row An optional preallocated array. If null or too small, it will be ignored.\n     *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.\n     * @return The array of bits for this row (true means black).\n     * @throws NotFoundException if row can't be binarized\n     */\n    BinaryBitmap.prototype.getBlackRow = function (y /*int*/, row) {\n        return this.binarizer.getBlackRow(y, row);\n    };\n    /**\n     * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive\n     * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or\n     * may not apply sharpening. Therefore, a row from this matrix may not be identical to one\n     * fetched using getBlackRow(), so don't mix and match between them.\n     *\n     * @return The 2D array of bits for the image (true means black).\n     * @throws NotFoundException if image can't be binarized to make a matrix\n     */\n    BinaryBitmap.prototype.getBlackMatrix = function () {\n        // The matrix is created on demand the first time it is requested, then cached. There are two\n        // reasons for this:\n        // 1. This work will never be done if the caller only installs 1D Reader objects, or if a\n        //    1D Reader finds a barcode before the 2D Readers run.\n        // 2. This work will only be done once even if the caller installs multiple 2D Readers.\n        if (this.matrix === null || this.matrix === undefined) {\n            this.matrix = this.binarizer.getBlackMatrix();\n        }\n        return this.matrix;\n    };\n    /**\n     * @return Whether this bitmap can be cropped.\n     */\n    BinaryBitmap.prototype.isCropSupported = function () {\n        return this.binarizer.getLuminanceSource().isCropSupported();\n    };\n    /**\n     * Returns a new object with cropped image data. Implementations may keep a reference to the\n     * original data rather than a copy. Only callable if isCropSupported() is true.\n     *\n     * @param left The left coordinate, which must be in [0,getWidth())\n     * @param top The top coordinate, which must be in [0,getHeight())\n     * @param width The width of the rectangle to crop.\n     * @param height The height of the rectangle to crop.\n     * @return A cropped version of this object.\n     */\n    BinaryBitmap.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n        var newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);\n        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n    };\n    /**\n     * @return Whether this bitmap supports counter-clockwise rotation.\n     */\n    BinaryBitmap.prototype.isRotateSupported = function () {\n        return this.binarizer.getLuminanceSource().isRotateSupported();\n    };\n    /**\n     * Returns a new object with rotated image data by 90 degrees counterclockwise.\n     * Only callable if {@link #isRotateSupported()} is true.\n     *\n     * @return A rotated version of this object.\n     */\n    BinaryBitmap.prototype.rotateCounterClockwise = function () {\n        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();\n        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n    };\n    /**\n     * Returns a new object with rotated image data by 45 degrees counterclockwise.\n     * Only callable if {@link #isRotateSupported()} is true.\n     *\n     * @return A rotated version of this object.\n     */\n    BinaryBitmap.prototype.rotateCounterClockwise45 = function () {\n        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();\n        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n    };\n    /*@Override*/\n    BinaryBitmap.prototype.toString = function () {\n        try {\n            return this.getBlackMatrix().toString();\n        }\n        catch (e /*: NotFoundException*/) {\n            return '';\n        }\n    };\n    return BinaryBitmap;\n}());\nexports.default = BinaryBitmap;\n//# sourceMappingURL=BinaryBitmap.js.map"]},"metadata":{},"sourceType":"script"}