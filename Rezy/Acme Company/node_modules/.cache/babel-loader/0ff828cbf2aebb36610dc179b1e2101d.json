{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Decoder_1 = require(\"./decoder/Decoder\");\nvar Result_1 = require(\"../Result\");\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\nvar BitMatrix_1 = require(\"../common/BitMatrix\");\nvar Detector_1 = require(\"./detector/Detector\");\nvar System_1 = require(\"../util/System\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This implementation can detect and decode Data Matrix codes in an image.\n *\n * @author bbrown@google.com (Brian Brown)\n */\nvar DataMatrixReader = /** @class */function () {\n  function DataMatrixReader() {\n    this.decoder = new Decoder_1.default();\n  }\n  /**\n   * Locates and decodes a Data Matrix code in an image.\n   *\n   * @return a String representing the content encoded by the Data Matrix code\n   * @throws NotFoundException if a Data Matrix code cannot be found\n   * @throws FormatException if a Data Matrix code cannot be decoded\n   * @throws ChecksumException if error correction fails\n   */\n  // @Override\n  // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n  //   return decode(image, null);\n  // }\n  // @Override\n  DataMatrixReader.prototype.decode = function (image, hints) {\n    if (hints === void 0) {\n      hints = null;\n    }\n    var decoderResult;\n    var points;\n    if (hints != null && hints.has(DecodeHintType_1.default.PURE_BARCODE)) {\n      var bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());\n      decoderResult = this.decoder.decode(bits);\n      points = DataMatrixReader.NO_POINTS;\n    } else {\n      var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect();\n      decoderResult = this.decoder.decode(detectorResult.getBits());\n      points = detectorResult.getPoints();\n    }\n    var rawBytes = decoderResult.getRawBytes();\n    var result = new Result_1.default(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat_1.default.DATA_MATRIX, System_1.default.currentTimeMillis());\n    var byteSegments = decoderResult.getByteSegments();\n    if (byteSegments != null) {\n      result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);\n    }\n    var ecLevel = decoderResult.getECLevel();\n    if (ecLevel != null) {\n      result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);\n    }\n    return result;\n  };\n  // @Override\n  DataMatrixReader.prototype.reset = function () {\n    // do nothing\n  };\n  /**\n   * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n   * which contains only an unrotated, unskewed, image of a code, with some white border\n   * around it. This is a specialized method that works exceptionally fast in this special\n   * case.\n   *\n   * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)\n   */\n  DataMatrixReader.extractPureBits = function (image) {\n    var leftTopBlack = image.getTopLeftOnBit();\n    var rightBottomBlack = image.getBottomRightOnBit();\n    if (leftTopBlack == null || rightBottomBlack == null) {\n      throw new NotFoundException_1.default();\n    }\n    var moduleSize = this.moduleSize(leftTopBlack, image);\n    var top = leftTopBlack[1];\n    var bottom = rightBottomBlack[1];\n    var left = leftTopBlack[0];\n    var right = rightBottomBlack[0];\n    var matrixWidth = (right - left + 1) / moduleSize;\n    var matrixHeight = (bottom - top + 1) / moduleSize;\n    if (matrixWidth <= 0 || matrixHeight <= 0) {\n      throw new NotFoundException_1.default();\n    }\n    // Push in the \"border\" by half the module width so that we start\n    // sampling in the middle of the module. Just in case the image is a\n    // little off, this will help recover.\n    var nudge = moduleSize / 2;\n    top += nudge;\n    left += nudge;\n    // Now just read off the bits\n    var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);\n    for (var y = 0; y < matrixHeight; y++) {\n      var iOffset = top + y * moduleSize;\n      for (var x = 0; x < matrixWidth; x++) {\n        if (image.get(left + x * moduleSize, iOffset)) {\n          bits.set(x, y);\n        }\n      }\n    }\n    return bits;\n  };\n  DataMatrixReader.moduleSize = function (leftTopBlack, image) {\n    var width = image.getWidth();\n    var x = leftTopBlack[0];\n    var y = leftTopBlack[1];\n    while (x < width && image.get(x, y)) {\n      x++;\n    }\n    if (x === width) {\n      throw new NotFoundException_1.default();\n    }\n    var moduleSize = x - leftTopBlack[0];\n    if (moduleSize === 0) {\n      throw new NotFoundException_1.default();\n    }\n    return moduleSize;\n  };\n  DataMatrixReader.NO_POINTS = [];\n  return DataMatrixReader;\n}();\nexports.default = DataMatrixReader;","map":{"version":3,"names":["Decoder_1","require","Result_1","BarcodeFormat_1","DecodeHintType_1","ResultMetadataType_1","BitMatrix_1","Detector_1","System_1","NotFoundException_1","DataMatrixReader","decoder","default","prototype","decode","image","hints","decoderResult","points","has","PURE_BARCODE","bits","extractPureBits","getBlackMatrix","NO_POINTS","detectorResult","detect","getBits","getPoints","rawBytes","getRawBytes","result","getText","length","DATA_MATRIX","currentTimeMillis","byteSegments","getByteSegments","putMetadata","BYTE_SEGMENTS","ecLevel","getECLevel","ERROR_CORRECTION_LEVEL","reset","leftTopBlack","getTopLeftOnBit","rightBottomBlack","getBottomRightOnBit","moduleSize","top","bottom","left","right","matrixWidth","matrixHeight","nudge","y","iOffset","x","get","set","width","getWidth"],"sources":["../../../src/core/datamatrix/DataMatrixReader.ts"],"sourcesContent":[null],"mappings":";;;;;AAEA,IAAAA,SAAA,GAAAC,OAAA;AACA,IAAAC,QAAA,GAAAD,OAAA;AACA,IAAAE,eAAA,GAAAF,OAAA;AAEA,IAAAG,gBAAA,GAAAH,OAAA;AACA,IAAAI,oBAAA,GAAAJ,OAAA;AACA,IAAAK,WAAA,GAAAL,OAAA;AAGA,IAAAM,UAAA,GAAAN,OAAA;AAEA,IAAAO,QAAA,GAAAP,OAAA;AACA,IAAAQ,mBAAA,GAAAR,OAAA;AAEA;;;;;;;;;;;;;;;AAgBA;;;;;AAKA,IAAAS,gBAAA;EAAA,SAAAA,iBAAA;IAIU,KAAAC,OAAO,GAAY,IAAIX,SAAA,CAAAY,OAAO,EAAE;EA0H1C;EAxHE;;;;;;;;EAQA;EACA;EACA;EACA;EAEA;EACOF,gBAAA,CAAAG,SAAA,CAAAC,MAAM,GAAb,UAAcC,KAAmB,EAAEC,KAA6C;IAA7C,IAAAA,KAAA;MAAAA,KAAA,OAA6C;IAAA;IAC9E,IAAIC,aAA4B;IAChC,IAAIC,MAAqB;IAEzB,IAAIF,KAAK,IAAI,IAAI,IAAIA,KAAK,CAACG,GAAG,CAACf,gBAAA,CAAAQ,OAAc,CAACQ,YAAY,CAAC,EAAE;MAC3D,IAAMC,IAAI,GAAGX,gBAAgB,CAACY,eAAe,CAACP,KAAK,CAACQ,cAAc,EAAE,CAAC;MACrEN,aAAa,GAAG,IAAI,CAACN,OAAO,CAACG,MAAM,CAACO,IAAI,CAAC;MACzCH,MAAM,GAAGR,gBAAgB,CAACc,SAAS;KACpC,MAAM;MACL,IAAMC,cAAc,GAAG,IAAIlB,UAAA,CAAAK,OAAQ,CAACG,KAAK,CAACQ,cAAc,EAAE,CAAC,CAACG,MAAM,EAAE;MACpET,aAAa,GAAG,IAAI,CAACN,OAAO,CAACG,MAAM,CAACW,cAAc,CAACE,OAAO,EAAE,CAAC;MAC7DT,MAAM,GAAGO,cAAc,CAACG,SAAS,EAAE;;IAErC,IAAMC,QAAQ,GAAGZ,aAAa,CAACa,WAAW,EAAE;IAC5C,IAAMC,MAAM,GAAG,IAAI7B,QAAA,CAAAU,OAAM,CACvBK,aAAa,CAACe,OAAO,EAAE,EACvBH,QAAQ,EACR,CAAC,GAAGA,QAAQ,CAACI,MAAM,EACnBf,MAAM,EACNf,eAAA,CAAAS,OAAa,CAACsB,WAAW,EACzB1B,QAAA,CAAAI,OAAM,CAACuB,iBAAiB,EAAE,CAC3B;IAED,IAAMC,YAAY,GAAGnB,aAAa,CAACoB,eAAe,EAAE;IACpD,IAAID,YAAY,IAAI,IAAI,EAAE;MACxBL,MAAM,CAACO,WAAW,CAACjC,oBAAA,CAAAO,OAAkB,CAAC2B,aAAa,EAAEH,YAAY,CAAC;;IAEpE,IAAMI,OAAO,GAAGvB,aAAa,CAACwB,UAAU,EAAE;IAC1C,IAAID,OAAO,IAAI,IAAI,EAAE;MACnBT,MAAM,CAACO,WAAW,CAACjC,oBAAA,CAAAO,OAAkB,CAAC8B,sBAAsB,EAAEF,OAAO,CAAC;;IAExE,OAAOT,MAAM;EACf,CAAC;EAED;EACOrB,gBAAA,CAAAG,SAAA,CAAA8B,KAAK,GAAZ;IACE;EAAA,CACD;EAED;;;;;;;;EAQejC,gBAAA,CAAAY,eAAe,GAA9B,UAA+BP,KAAgB;IAE7C,IAAM6B,YAAY,GAAG7B,KAAK,CAAC8B,eAAe,EAAE;IAC5C,IAAMC,gBAAgB,GAAG/B,KAAK,CAACgC,mBAAmB,EAAE;IACpD,IAAIH,YAAY,IAAI,IAAI,IAAIE,gBAAgB,IAAI,IAAI,EAAE;MACpD,MAAM,IAAIrC,mBAAA,CAAAG,OAAiB,EAAE;;IAG/B,IAAMoC,UAAU,GAAG,IAAI,CAACA,UAAU,CAACJ,YAAY,EAAE7B,KAAK,CAAC;IAEvD,IAAIkC,GAAG,GAAGL,YAAY,CAAC,CAAC,CAAC;IACzB,IAAMM,MAAM,GAAGJ,gBAAgB,CAAC,CAAC,CAAC;IAClC,IAAIK,IAAI,GAAGP,YAAY,CAAC,CAAC,CAAC;IAC1B,IAAMQ,KAAK,GAAGN,gBAAgB,CAAC,CAAC,CAAC;IAEjC,IAAMO,WAAW,GAAG,CAACD,KAAK,GAAGD,IAAI,GAAG,CAAC,IAAIH,UAAU;IACnD,IAAMM,YAAY,GAAG,CAACJ,MAAM,GAAGD,GAAG,GAAG,CAAC,IAAID,UAAU;IACpD,IAAIK,WAAW,IAAI,CAAC,IAAIC,YAAY,IAAI,CAAC,EAAE;MACzC,MAAM,IAAI7C,mBAAA,CAAAG,OAAiB,EAAE;;IAG/B;IACA;IACA;IACA,IAAM2C,KAAK,GAAGP,UAAU,GAAG,CAAC;IAC5BC,GAAG,IAAIM,KAAK;IACZJ,IAAI,IAAII,KAAK;IAEb;IACA,IAAMlC,IAAI,GAAG,IAAIf,WAAA,CAAAM,OAAS,CAACyC,WAAW,EAAEC,YAAY,CAAC;IACrD,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,YAAY,EAAEE,CAAC,EAAE,EAAE;MACrC,IAAMC,OAAO,GAAGR,GAAG,GAAGO,CAAC,GAAGR,UAAU;MACpC,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,WAAW,EAAEK,CAAC,EAAE,EAAE;QACpC,IAAI3C,KAAK,CAAC4C,GAAG,CAACR,IAAI,GAAGO,CAAC,GAAGV,UAAU,EAAES,OAAO,CAAC,EAAE;UAC7CpC,IAAI,CAACuC,GAAG,CAACF,CAAC,EAAEF,CAAC,CAAC;;;;IAIpB,OAAOnC,IAAI;EACb,CAAC;EAEcX,gBAAA,CAAAsC,UAAU,GAAzB,UAA0BJ,YAAwB,EAAE7B,KAAgB;IAClE,IAAM8C,KAAK,GAAG9C,KAAK,CAAC+C,QAAQ,EAAE;IAC9B,IAAIJ,CAAC,GAAGd,YAAY,CAAC,CAAC,CAAC;IACvB,IAAMY,CAAC,GAAGZ,YAAY,CAAC,CAAC,CAAC;IACzB,OAAOc,CAAC,GAAGG,KAAK,IAAI9C,KAAK,CAAC4C,GAAG,CAACD,CAAC,EAAEF,CAAC,CAAC,EAAE;MACnCE,CAAC,EAAE;;IAEL,IAAIA,CAAC,KAAKG,KAAK,EAAE;MACf,MAAM,IAAIpD,mBAAA,CAAAG,OAAiB,EAAE;;IAG/B,IAAMoC,UAAU,GAAGU,CAAC,GAAGd,YAAY,CAAC,CAAC,CAAC;IACtC,IAAII,UAAU,KAAK,CAAC,EAAE;MACpB,MAAM,IAAIvC,mBAAA,CAAAG,OAAiB,EAAE;;IAE/B,OAAOoC,UAAU;EACnB,CAAC;EA1HctC,gBAAA,CAAAc,SAAS,GAAkB,EAAE;EA4H9C,OAAAd,gBAAC;CAAA,EA9HD;kBAAqBA,gBAAgB"},"metadata":{},"sourceType":"script"}