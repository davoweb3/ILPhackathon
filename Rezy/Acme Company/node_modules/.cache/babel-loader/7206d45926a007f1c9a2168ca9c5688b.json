{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar OneDReader_1 = require(\"./OneDReader\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\nvar FormatException_1 = require(\"../FormatException\");\n/**\n * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n * of one-dimensional barcodes.</p>\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n * @author alasdair@google.com (Alasdair Mackintosh)\n */\nvar AbstractUPCEANReader = /** @class */function (_super) {\n  __extends(AbstractUPCEANReader, _super);\n  function AbstractUPCEANReader() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.decodeRowStringBuffer = '';\n    return _this;\n  }\n  // private final UPCEANExtensionSupport extensionReader;\n  // private final EANManufacturerOrgSupport eanManSupport;\n  /*\n  protected UPCEANReader() {\n      decodeRowStringBuffer = new StringBuilder(20);\n      extensionReader = new UPCEANExtensionSupport();\n      eanManSupport = new EANManufacturerOrgSupport();\n  }\n  */\n  AbstractUPCEANReader.findStartGuardPattern = function (row) {\n    var foundStart = false;\n    var startRange = null;\n    var nextStart = 0;\n    var counters = [0, 0, 0];\n    while (!foundStart) {\n      counters = [0, 0, 0];\n      startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);\n      var start = startRange[0];\n      nextStart = startRange[1];\n      var quietStart = start - (nextStart - start);\n      if (quietStart >= 0) {\n        foundStart = row.isRange(quietStart, start, false);\n      }\n    }\n    return startRange;\n  };\n  AbstractUPCEANReader.checkChecksum = function (s) {\n    return AbstractUPCEANReader.checkStandardUPCEANChecksum(s);\n  };\n  AbstractUPCEANReader.checkStandardUPCEANChecksum = function (s) {\n    var length = s.length;\n    if (length === 0) return false;\n    var check = parseInt(s.charAt(length - 1), 10);\n    return AbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n  };\n  AbstractUPCEANReader.getStandardUPCEANChecksum = function (s) {\n    var length = s.length;\n    var sum = 0;\n    for (var i = length - 1; i >= 0; i -= 2) {\n      var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n      if (digit < 0 || digit > 9) {\n        throw new FormatException_1.default();\n      }\n      sum += digit;\n    }\n    sum *= 3;\n    for (var i = length - 2; i >= 0; i -= 2) {\n      var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n      if (digit < 0 || digit > 9) {\n        throw new FormatException_1.default();\n      }\n      sum += digit;\n    }\n    return (1000 - sum) % 10;\n  };\n  AbstractUPCEANReader.decodeEnd = function (row, endStart) {\n    return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));\n  };\n  AbstractUPCEANReader.findGuardPattern = function (row, rowOffset, whiteFirst, pattern, counters) {\n    var width = row.getSize();\n    rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);\n    var counterPosition = 0;\n    var patternStart = rowOffset;\n    var patternLength = pattern.length;\n    var isWhite = whiteFirst;\n    for (var x = rowOffset; x < width; x++) {\n      if (row.get(x) !== isWhite) {\n        counters[counterPosition]++;\n      } else {\n        if (counterPosition === patternLength - 1) {\n          if (OneDReader_1.default.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {\n            return [patternStart, x];\n          }\n          patternStart += counters[0] + counters[1];\n          var slice = counters.slice(2, counters.length);\n          for (var i = 0; i < counterPosition - 1; i++) {\n            counters[i] = slice[i];\n          }\n          counters[counterPosition - 1] = 0;\n          counters[counterPosition] = 0;\n          counterPosition--;\n        } else {\n          counterPosition++;\n        }\n        counters[counterPosition] = 1;\n        isWhite = !isWhite;\n      }\n    }\n    throw new NotFoundException_1.default();\n  };\n  AbstractUPCEANReader.decodeDigit = function (row, counters, rowOffset, patterns) {\n    this.recordPattern(row, rowOffset, counters);\n    var bestVariance = this.MAX_AVG_VARIANCE;\n    var bestMatch = -1;\n    var max = patterns.length;\n    for (var i = 0; i < max; i++) {\n      var pattern = patterns[i];\n      var variance = OneDReader_1.default.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);\n      if (variance < bestVariance) {\n        bestVariance = variance;\n        bestMatch = i;\n      }\n    }\n    if (bestMatch >= 0) {\n      return bestMatch;\n    } else {\n      throw new NotFoundException_1.default();\n    }\n  };\n  // These two values are critical for determining how permissive the decoding will be.\n  // We've arrived at these values through a lot of trial and error. Setting them any higher\n  // lets false positives creep in quickly.\n  AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;\n  AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n  /**\n   * Start/end guard pattern.\n   */\n  AbstractUPCEANReader.START_END_PATTERN = [1, 1, 1];\n  /**\n   * Pattern marking the middle of a UPC/EAN pattern, separating the two halves.\n   */\n  AbstractUPCEANReader.MIDDLE_PATTERN = [1, 1, 1, 1, 1];\n  /**\n   * end guard pattern.\n   */\n  AbstractUPCEANReader.END_PATTERN = [1, 1, 1, 1, 1, 1];\n  /**\n   * \"Odd\", or \"L\" patterns used to encode UPC/EAN digits.\n   */\n  AbstractUPCEANReader.L_PATTERNS = [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2]];\n  return AbstractUPCEANReader;\n}(OneDReader_1.default);\nexports.default = AbstractUPCEANReader;","map":{"version":3,"sources":["../../../src/core/oned/AbstractUPCEANReader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar OneDReader_1 = require(\"./OneDReader\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\nvar FormatException_1 = require(\"../FormatException\");\n/**\n * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n * of one-dimensional barcodes.</p>\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n * @author alasdair@google.com (Alasdair Mackintosh)\n */\nvar AbstractUPCEANReader = /** @class */ (function (_super) {\n    __extends(AbstractUPCEANReader, _super);\n    function AbstractUPCEANReader() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.decodeRowStringBuffer = '';\n        return _this;\n    }\n    // private final UPCEANExtensionSupport extensionReader;\n    // private final EANManufacturerOrgSupport eanManSupport;\n    /*\n    protected UPCEANReader() {\n        decodeRowStringBuffer = new StringBuilder(20);\n        extensionReader = new UPCEANExtensionSupport();\n        eanManSupport = new EANManufacturerOrgSupport();\n    }\n    */\n    AbstractUPCEANReader.findStartGuardPattern = function (row) {\n        var foundStart = false;\n        var startRange = null;\n        var nextStart = 0;\n        var counters = [0, 0, 0];\n        while (!foundStart) {\n            counters = [0, 0, 0];\n            startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);\n            var start = startRange[0];\n            nextStart = startRange[1];\n            var quietStart = start - (nextStart - start);\n            if (quietStart >= 0) {\n                foundStart = row.isRange(quietStart, start, false);\n            }\n        }\n        return startRange;\n    };\n    AbstractUPCEANReader.checkChecksum = function (s) {\n        return AbstractUPCEANReader.checkStandardUPCEANChecksum(s);\n    };\n    AbstractUPCEANReader.checkStandardUPCEANChecksum = function (s) {\n        var length = s.length;\n        if (length === 0)\n            return false;\n        var check = parseInt(s.charAt(length - 1), 10);\n        return AbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n    };\n    AbstractUPCEANReader.getStandardUPCEANChecksum = function (s) {\n        var length = s.length;\n        var sum = 0;\n        for (var i = length - 1; i >= 0; i -= 2) {\n            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            if (digit < 0 || digit > 9) {\n                throw new FormatException_1.default();\n            }\n            sum += digit;\n        }\n        sum *= 3;\n        for (var i = length - 2; i >= 0; i -= 2) {\n            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            if (digit < 0 || digit > 9) {\n                throw new FormatException_1.default();\n            }\n            sum += digit;\n        }\n        return (1000 - sum) % 10;\n    };\n    AbstractUPCEANReader.decodeEnd = function (row, endStart) {\n        return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));\n    };\n    AbstractUPCEANReader.findGuardPattern = function (row, rowOffset, whiteFirst, pattern, counters) {\n        var width = row.getSize();\n        rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);\n        var counterPosition = 0;\n        var patternStart = rowOffset;\n        var patternLength = pattern.length;\n        var isWhite = whiteFirst;\n        for (var x = rowOffset; x < width; x++) {\n            if (row.get(x) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === patternLength - 1) {\n                    if (OneDReader_1.default.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {\n                        return [patternStart, x];\n                    }\n                    patternStart += counters[0] + counters[1];\n                    var slice = counters.slice(2, counters.length);\n                    for (var i = 0; i < counterPosition - 1; i++) {\n                        counters[i] = slice[i];\n                    }\n                    counters[counterPosition - 1] = 0;\n                    counters[counterPosition] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                counters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    AbstractUPCEANReader.decodeDigit = function (row, counters, rowOffset, patterns) {\n        this.recordPattern(row, rowOffset, counters);\n        var bestVariance = this.MAX_AVG_VARIANCE;\n        var bestMatch = -1;\n        var max = patterns.length;\n        for (var i = 0; i < max; i++) {\n            var pattern = patterns[i];\n            var variance = OneDReader_1.default.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);\n            if (variance < bestVariance) {\n                bestVariance = variance;\n                bestMatch = i;\n            }\n        }\n        if (bestMatch >= 0) {\n            return bestMatch;\n        }\n        else {\n            throw new NotFoundException_1.default();\n        }\n    };\n    // These two values are critical for determining how permissive the decoding will be.\n    // We've arrived at these values through a lot of trial and error. Setting them any higher\n    // lets false positives creep in quickly.\n    AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;\n    AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n    /**\n     * Start/end guard pattern.\n     */\n    AbstractUPCEANReader.START_END_PATTERN = [1, 1, 1];\n    /**\n     * Pattern marking the middle of a UPC/EAN pattern, separating the two halves.\n     */\n    AbstractUPCEANReader.MIDDLE_PATTERN = [1, 1, 1, 1, 1];\n    /**\n     * end guard pattern.\n     */\n    AbstractUPCEANReader.END_PATTERN = [1, 1, 1, 1, 1, 1];\n    /**\n     * \"Odd\", or \"L\" patterns used to encode UPC/EAN digits.\n     */\n    AbstractUPCEANReader.L_PATTERNS = [\n        [3, 2, 1, 1],\n        [2, 2, 2, 1],\n        [2, 1, 2, 2],\n        [1, 4, 1, 1],\n        [1, 1, 3, 2],\n        [1, 2, 3, 1],\n        [1, 1, 1, 4],\n        [1, 3, 1, 2],\n        [1, 2, 1, 3],\n        [3, 1, 1, 2],\n    ];\n    return AbstractUPCEANReader;\n}(OneDReader_1.default));\nexports.default = AbstractUPCEANReader;\n//# sourceMappingURL=AbstractUPCEANReader.js.map"]},"metadata":{},"sourceType":"script"}