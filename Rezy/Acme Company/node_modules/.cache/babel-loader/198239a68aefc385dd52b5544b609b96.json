{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar GlobalHistogramBinarizer_1 = require(\"./GlobalHistogramBinarizer\");\nvar BitMatrix_1 = require(\"./BitMatrix\");\n/**\n * This class implements a local thresholding algorithm, which while slower than the\n * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for\n * high frequency images of barcodes with black data on white backgrounds. For this application,\n * it does a much better job than a global blackpoint with severe shadows and gradients.\n * However it tends to produce artifacts on lower frequency images and is therefore not\n * a good general purpose binarizer for uses outside ZXing.\n *\n * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,\n * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already\n * inherently local, and only fails for horizontal gradients. We can revisit that problem later,\n * but for now it was not a win to use local blocks for 1D.\n *\n * This Binarizer is the default for the unit tests and the recommended class for library users.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar HybridBinarizer = /** @class */function (_super) {\n  __extends(HybridBinarizer, _super);\n  function HybridBinarizer(source) {\n    var _this = _super.call(this, source) || this;\n    _this.matrix = null;\n    return _this;\n  }\n  /**\n   * Calculates the final BitMatrix once for all requests. This could be called once from the\n   * constructor instead, but there are some advantages to doing it lazily, such as making\n   * profiling easier, and not doing heavy lifting when callers don't expect it.\n   */\n  /*@Override*/\n  HybridBinarizer.prototype.getBlackMatrix = function () {\n    if (this.matrix !== null) {\n      return this.matrix;\n    }\n    var source = this.getLuminanceSource();\n    var width = source.getWidth();\n    var height = source.getHeight();\n    if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {\n      var luminances = source.getMatrix();\n      var subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;\n      if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n        subWidth++;\n      }\n      var subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;\n      if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n        subHeight++;\n      }\n      var blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);\n      var newMatrix = new BitMatrix_1.default(width, height);\n      HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);\n      this.matrix = newMatrix;\n    } else {\n      // If the image is too small, fall back to the global histogram approach.\n      this.matrix = _super.prototype.getBlackMatrix.call(this);\n    }\n    return this.matrix;\n  };\n  /*@Override*/\n  HybridBinarizer.prototype.createBinarizer = function (source) {\n    return new HybridBinarizer(source);\n  };\n  /**\n   * For each block in the image, calculate the average black point using a 5x5 grid\n   * of the blocks around it. Also handles the corner cases (fractional blocks are computed based\n   * on the last pixels in the row/column which are also used in the previous block).\n   */\n  HybridBinarizer.calculateThresholdForBlock = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/, blackPoints, matrix) {\n    var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n    var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n    for (var y = 0; y < subHeight; y++) {\n      var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n      if (yoffset > maxYOffset) {\n        yoffset = maxYOffset;\n      }\n      var top_1 = HybridBinarizer.cap(y, 2, subHeight - 3);\n      for (var x = 0; x < subWidth; x++) {\n        var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n        if (xoffset > maxXOffset) {\n          xoffset = maxXOffset;\n        }\n        var left = HybridBinarizer.cap(x, 2, subWidth - 3);\n        var sum = 0;\n        for (var z = -2; z <= 2; z++) {\n          var blackRow = blackPoints[top_1 + z];\n          sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n        }\n        var average = sum / 25;\n        HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n      }\n    }\n  };\n  HybridBinarizer.cap = function (value /*int*/, min /*int*/, max /*int*/) {\n    return value < min ? min : value > max ? max : value;\n  };\n  /**\n   * Applies a single threshold to a block of pixels.\n   */\n  HybridBinarizer.thresholdBlock = function (luminances, xoffset /*int*/, yoffset /*int*/, threshold /*int*/, stride /*int*/, matrix) {\n    for (var y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {\n      for (var x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {\n        // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.\n        if ((luminances[offset + x] & 0xFF) <= threshold) {\n          matrix.set(xoffset + x, yoffset + y);\n        }\n      }\n    }\n  };\n  /**\n   * Calculates a single black point for each block of pixels and saves it away.\n   * See the following thread for a discussion of this algorithm:\n   *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0\n   */\n  HybridBinarizer.calculateBlackPoints = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/) {\n    var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n    var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n    // tslint:disable-next-line:whitespace\n    var blackPoints = new Array(subHeight); // subWidth\n    for (var y = 0; y < subHeight; y++) {\n      blackPoints[y] = new Int32Array(subWidth);\n      var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n      if (yoffset > maxYOffset) {\n        yoffset = maxYOffset;\n      }\n      for (var x = 0; x < subWidth; x++) {\n        var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n        if (xoffset > maxXOffset) {\n          xoffset = maxXOffset;\n        }\n        var sum = 0;\n        var min = 0xFF;\n        var max = 0;\n        for (var yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n          for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n            var pixel = luminances[offset + xx] & 0xFF;\n            sum += pixel;\n            // still looking for good contrast\n            if (pixel < min) {\n              min = pixel;\n            }\n            if (pixel > max) {\n              max = pixel;\n            }\n          }\n          // short-circuit min/max tests once dynamic range is met\n          if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {\n            // finish the rest of the rows quickly\n            for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n              for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n                sum += luminances[offset + xx] & 0xFF;\n              }\n            }\n          }\n        }\n        // The default estimate is the average of the values in the block.\n        var average = sum >> HybridBinarizer.BLOCK_SIZE_POWER * 2;\n        if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {\n          // If variation within the block is low, assume this is a block with only light or only\n          // dark pixels. In that case we do not want to use the average, as it would divide this\n          // low contrast area into black and white pixels, essentially creating data out of noise.\n          //\n          // The default assumption is that the block is light/background. Since no estimate for\n          // the level of dark pixels exists locally, use half the min for the block.\n          average = min / 2;\n          if (y > 0 && x > 0) {\n            // Correct the \"white background\" assumption for blocks that have neighbors by comparing\n            // the pixels in this block to the previously calculated black points. This is based on\n            // the fact that dark barcode symbology is always surrounded by some amount of light\n            // background for which reasonable black point estimates were made. The bp estimated at\n            // the boundaries is used for the interior.\n            // The (min < bp) is arbitrary but works better than other heuristics that were tried.\n            var averageNeighborBlackPoint = (blackPoints[y - 1][x] + 2 * blackPoints[y][x - 1] + blackPoints[y - 1][x - 1]) / 4;\n            if (min < averageNeighborBlackPoint) {\n              average = averageNeighborBlackPoint;\n            }\n          }\n        }\n        blackPoints[y][x] = average;\n      }\n    }\n    return blackPoints;\n  };\n  // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels.\n  // So this is the smallest dimension in each axis we can accept.\n  HybridBinarizer.BLOCK_SIZE_POWER = 3;\n  HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER; // ...0100...00\n  HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1; // ...0011...11\n  HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;\n  HybridBinarizer.MIN_DYNAMIC_RANGE = 24;\n  return HybridBinarizer;\n}(GlobalHistogramBinarizer_1.default);\nexports.default = HybridBinarizer;","map":{"version":3,"sources":["../../../src/core/common/HybridBinarizer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GlobalHistogramBinarizer_1 = require(\"./GlobalHistogramBinarizer\");\nvar BitMatrix_1 = require(\"./BitMatrix\");\n/**\n * This class implements a local thresholding algorithm, which while slower than the\n * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for\n * high frequency images of barcodes with black data on white backgrounds. For this application,\n * it does a much better job than a global blackpoint with severe shadows and gradients.\n * However it tends to produce artifacts on lower frequency images and is therefore not\n * a good general purpose binarizer for uses outside ZXing.\n *\n * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,\n * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already\n * inherently local, and only fails for horizontal gradients. We can revisit that problem later,\n * but for now it was not a win to use local blocks for 1D.\n *\n * This Binarizer is the default for the unit tests and the recommended class for library users.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar HybridBinarizer = /** @class */ (function (_super) {\n    __extends(HybridBinarizer, _super);\n    function HybridBinarizer(source) {\n        var _this = _super.call(this, source) || this;\n        _this.matrix = null;\n        return _this;\n    }\n    /**\n     * Calculates the final BitMatrix once for all requests. This could be called once from the\n     * constructor instead, but there are some advantages to doing it lazily, such as making\n     * profiling easier, and not doing heavy lifting when callers don't expect it.\n     */\n    /*@Override*/\n    HybridBinarizer.prototype.getBlackMatrix = function () {\n        if (this.matrix !== null) {\n            return this.matrix;\n        }\n        var source = this.getLuminanceSource();\n        var width = source.getWidth();\n        var height = source.getHeight();\n        if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {\n            var luminances = source.getMatrix();\n            var subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;\n            if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n                subWidth++;\n            }\n            var subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;\n            if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n                subHeight++;\n            }\n            var blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);\n            var newMatrix = new BitMatrix_1.default(width, height);\n            HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);\n            this.matrix = newMatrix;\n        }\n        else {\n            // If the image is too small, fall back to the global histogram approach.\n            this.matrix = _super.prototype.getBlackMatrix.call(this);\n        }\n        return this.matrix;\n    };\n    /*@Override*/\n    HybridBinarizer.prototype.createBinarizer = function (source) {\n        return new HybridBinarizer(source);\n    };\n    /**\n     * For each block in the image, calculate the average black point using a 5x5 grid\n     * of the blocks around it. Also handles the corner cases (fractional blocks are computed based\n     * on the last pixels in the row/column which are also used in the previous block).\n     */\n    HybridBinarizer.calculateThresholdForBlock = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/, blackPoints, matrix) {\n        var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n        var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n        for (var y = 0; y < subHeight; y++) {\n            var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n            if (yoffset > maxYOffset) {\n                yoffset = maxYOffset;\n            }\n            var top_1 = HybridBinarizer.cap(y, 2, subHeight - 3);\n            for (var x = 0; x < subWidth; x++) {\n                var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n                if (xoffset > maxXOffset) {\n                    xoffset = maxXOffset;\n                }\n                var left = HybridBinarizer.cap(x, 2, subWidth - 3);\n                var sum = 0;\n                for (var z = -2; z <= 2; z++) {\n                    var blackRow = blackPoints[top_1 + z];\n                    sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n                }\n                var average = sum / 25;\n                HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n            }\n        }\n    };\n    HybridBinarizer.cap = function (value /*int*/, min /*int*/, max /*int*/) {\n        return value < min ? min : value > max ? max : value;\n    };\n    /**\n     * Applies a single threshold to a block of pixels.\n     */\n    HybridBinarizer.thresholdBlock = function (luminances, xoffset /*int*/, yoffset /*int*/, threshold /*int*/, stride /*int*/, matrix) {\n        for (var y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {\n            for (var x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {\n                // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.\n                if ((luminances[offset + x] & 0xFF) <= threshold) {\n                    matrix.set(xoffset + x, yoffset + y);\n                }\n            }\n        }\n    };\n    /**\n     * Calculates a single black point for each block of pixels and saves it away.\n     * See the following thread for a discussion of this algorithm:\n     *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0\n     */\n    HybridBinarizer.calculateBlackPoints = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/) {\n        var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n        var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n        // tslint:disable-next-line:whitespace\n        var blackPoints = new Array(subHeight); // subWidth\n        for (var y = 0; y < subHeight; y++) {\n            blackPoints[y] = new Int32Array(subWidth);\n            var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n            if (yoffset > maxYOffset) {\n                yoffset = maxYOffset;\n            }\n            for (var x = 0; x < subWidth; x++) {\n                var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n                if (xoffset > maxXOffset) {\n                    xoffset = maxXOffset;\n                }\n                var sum = 0;\n                var min = 0xFF;\n                var max = 0;\n                for (var yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n                    for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n                        var pixel = luminances[offset + xx] & 0xFF;\n                        sum += pixel;\n                        // still looking for good contrast\n                        if (pixel < min) {\n                            min = pixel;\n                        }\n                        if (pixel > max) {\n                            max = pixel;\n                        }\n                    }\n                    // short-circuit min/max tests once dynamic range is met\n                    if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {\n                        // finish the rest of the rows quickly\n                        for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n                            for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n                                sum += luminances[offset + xx] & 0xFF;\n                            }\n                        }\n                    }\n                }\n                // The default estimate is the average of the values in the block.\n                var average = sum >> (HybridBinarizer.BLOCK_SIZE_POWER * 2);\n                if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {\n                    // If variation within the block is low, assume this is a block with only light or only\n                    // dark pixels. In that case we do not want to use the average, as it would divide this\n                    // low contrast area into black and white pixels, essentially creating data out of noise.\n                    //\n                    // The default assumption is that the block is light/background. Since no estimate for\n                    // the level of dark pixels exists locally, use half the min for the block.\n                    average = min / 2;\n                    if (y > 0 && x > 0) {\n                        // Correct the \"white background\" assumption for blocks that have neighbors by comparing\n                        // the pixels in this block to the previously calculated black points. This is based on\n                        // the fact that dark barcode symbology is always surrounded by some amount of light\n                        // background for which reasonable black point estimates were made. The bp estimated at\n                        // the boundaries is used for the interior.\n                        // The (min < bp) is arbitrary but works better than other heuristics that were tried.\n                        var averageNeighborBlackPoint = (blackPoints[y - 1][x] + (2 * blackPoints[y][x - 1]) + blackPoints[y - 1][x - 1]) / 4;\n                        if (min < averageNeighborBlackPoint) {\n                            average = averageNeighborBlackPoint;\n                        }\n                    }\n                }\n                blackPoints[y][x] = average;\n            }\n        }\n        return blackPoints;\n    };\n    // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels.\n    // So this is the smallest dimension in each axis we can accept.\n    HybridBinarizer.BLOCK_SIZE_POWER = 3;\n    HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER; // ...0100...00\n    HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1; // ...0011...11\n    HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;\n    HybridBinarizer.MIN_DYNAMIC_RANGE = 24;\n    return HybridBinarizer;\n}(GlobalHistogramBinarizer_1.default));\nexports.default = HybridBinarizer;\n//# sourceMappingURL=HybridBinarizer.js.map"]},"metadata":{},"sourceType":"script"}