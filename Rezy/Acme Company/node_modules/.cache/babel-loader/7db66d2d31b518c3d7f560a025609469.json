{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Decoder_1 = require(\"./decoder/Decoder\");\nvar Result_1 = require(\"../Result\");\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\nvar BitMatrix_1 = require(\"../common/BitMatrix\");\nvar Detector_1 = require(\"./detector/Detector\");\nvar System_1 = require(\"../util/System\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This implementation can detect and decode Data Matrix codes in an image.\n *\n * @author bbrown@google.com (Brian Brown)\n */\nvar DataMatrixReader = /** @class */function () {\n  function DataMatrixReader() {\n    this.decoder = new Decoder_1.default();\n  }\n  /**\n   * Locates and decodes a Data Matrix code in an image.\n   *\n   * @return a String representing the content encoded by the Data Matrix code\n   * @throws NotFoundException if a Data Matrix code cannot be found\n   * @throws FormatException if a Data Matrix code cannot be decoded\n   * @throws ChecksumException if error correction fails\n   */\n  // @Override\n  // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n  //   return decode(image, null);\n  // }\n  // @Override\n  DataMatrixReader.prototype.decode = function (image, hints) {\n    if (hints === void 0) {\n      hints = null;\n    }\n    var decoderResult;\n    var points;\n    if (hints != null && hints.has(DecodeHintType_1.default.PURE_BARCODE)) {\n      var bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());\n      decoderResult = this.decoder.decode(bits);\n      points = DataMatrixReader.NO_POINTS;\n    } else {\n      var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect();\n      decoderResult = this.decoder.decode(detectorResult.getBits());\n      points = detectorResult.getPoints();\n    }\n    var rawBytes = decoderResult.getRawBytes();\n    var result = new Result_1.default(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat_1.default.DATA_MATRIX, System_1.default.currentTimeMillis());\n    var byteSegments = decoderResult.getByteSegments();\n    if (byteSegments != null) {\n      result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);\n    }\n    var ecLevel = decoderResult.getECLevel();\n    if (ecLevel != null) {\n      result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);\n    }\n    return result;\n  };\n  // @Override\n  DataMatrixReader.prototype.reset = function () {\n    // do nothing\n  };\n  /**\n   * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n   * which contains only an unrotated, unskewed, image of a code, with some white border\n   * around it. This is a specialized method that works exceptionally fast in this special\n   * case.\n   *\n   * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)\n   */\n  DataMatrixReader.extractPureBits = function (image) {\n    var leftTopBlack = image.getTopLeftOnBit();\n    var rightBottomBlack = image.getBottomRightOnBit();\n    if (leftTopBlack == null || rightBottomBlack == null) {\n      throw new NotFoundException_1.default();\n    }\n    var moduleSize = this.moduleSize(leftTopBlack, image);\n    var top = leftTopBlack[1];\n    var bottom = rightBottomBlack[1];\n    var left = leftTopBlack[0];\n    var right = rightBottomBlack[0];\n    var matrixWidth = (right - left + 1) / moduleSize;\n    var matrixHeight = (bottom - top + 1) / moduleSize;\n    if (matrixWidth <= 0 || matrixHeight <= 0) {\n      throw new NotFoundException_1.default();\n    }\n    // Push in the \"border\" by half the module width so that we start\n    // sampling in the middle of the module. Just in case the image is a\n    // little off, this will help recover.\n    var nudge = moduleSize / 2;\n    top += nudge;\n    left += nudge;\n    // Now just read off the bits\n    var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);\n    for (var y = 0; y < matrixHeight; y++) {\n      var iOffset = top + y * moduleSize;\n      for (var x = 0; x < matrixWidth; x++) {\n        if (image.get(left + x * moduleSize, iOffset)) {\n          bits.set(x, y);\n        }\n      }\n    }\n    return bits;\n  };\n  DataMatrixReader.moduleSize = function (leftTopBlack, image) {\n    var width = image.getWidth();\n    var x = leftTopBlack[0];\n    var y = leftTopBlack[1];\n    while (x < width && image.get(x, y)) {\n      x++;\n    }\n    if (x === width) {\n      throw new NotFoundException_1.default();\n    }\n    var moduleSize = x - leftTopBlack[0];\n    if (moduleSize === 0) {\n      throw new NotFoundException_1.default();\n    }\n    return moduleSize;\n  };\n  DataMatrixReader.NO_POINTS = [];\n  return DataMatrixReader;\n}();\nexports.default = DataMatrixReader;","map":{"version":3,"sources":["../../../src/core/datamatrix/DataMatrixReader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Decoder_1 = require(\"./decoder/Decoder\");\nvar Result_1 = require(\"../Result\");\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\nvar BitMatrix_1 = require(\"../common/BitMatrix\");\nvar Detector_1 = require(\"./detector/Detector\");\nvar System_1 = require(\"../util/System\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This implementation can detect and decode Data Matrix codes in an image.\n *\n * @author bbrown@google.com (Brian Brown)\n */\nvar DataMatrixReader = /** @class */ (function () {\n    function DataMatrixReader() {\n        this.decoder = new Decoder_1.default();\n    }\n    /**\n     * Locates and decodes a Data Matrix code in an image.\n     *\n     * @return a String representing the content encoded by the Data Matrix code\n     * @throws NotFoundException if a Data Matrix code cannot be found\n     * @throws FormatException if a Data Matrix code cannot be decoded\n     * @throws ChecksumException if error correction fails\n     */\n    // @Override\n    // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n    //   return decode(image, null);\n    // }\n    // @Override\n    DataMatrixReader.prototype.decode = function (image, hints) {\n        if (hints === void 0) { hints = null; }\n        var decoderResult;\n        var points;\n        if (hints != null && hints.has(DecodeHintType_1.default.PURE_BARCODE)) {\n            var bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());\n            decoderResult = this.decoder.decode(bits);\n            points = DataMatrixReader.NO_POINTS;\n        }\n        else {\n            var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect();\n            decoderResult = this.decoder.decode(detectorResult.getBits());\n            points = detectorResult.getPoints();\n        }\n        var rawBytes = decoderResult.getRawBytes();\n        var result = new Result_1.default(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat_1.default.DATA_MATRIX, System_1.default.currentTimeMillis());\n        var byteSegments = decoderResult.getByteSegments();\n        if (byteSegments != null) {\n            result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);\n        }\n        var ecLevel = decoderResult.getECLevel();\n        if (ecLevel != null) {\n            result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);\n        }\n        return result;\n    };\n    // @Override\n    DataMatrixReader.prototype.reset = function () {\n        // do nothing\n    };\n    /**\n     * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n     * which contains only an unrotated, unskewed, image of a code, with some white border\n     * around it. This is a specialized method that works exceptionally fast in this special\n     * case.\n     *\n     * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)\n     */\n    DataMatrixReader.extractPureBits = function (image) {\n        var leftTopBlack = image.getTopLeftOnBit();\n        var rightBottomBlack = image.getBottomRightOnBit();\n        if (leftTopBlack == null || rightBottomBlack == null) {\n            throw new NotFoundException_1.default();\n        }\n        var moduleSize = this.moduleSize(leftTopBlack, image);\n        var top = leftTopBlack[1];\n        var bottom = rightBottomBlack[1];\n        var left = leftTopBlack[0];\n        var right = rightBottomBlack[0];\n        var matrixWidth = (right - left + 1) / moduleSize;\n        var matrixHeight = (bottom - top + 1) / moduleSize;\n        if (matrixWidth <= 0 || matrixHeight <= 0) {\n            throw new NotFoundException_1.default();\n        }\n        // Push in the \"border\" by half the module width so that we start\n        // sampling in the middle of the module. Just in case the image is a\n        // little off, this will help recover.\n        var nudge = moduleSize / 2;\n        top += nudge;\n        left += nudge;\n        // Now just read off the bits\n        var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);\n        for (var y = 0; y < matrixHeight; y++) {\n            var iOffset = top + y * moduleSize;\n            for (var x = 0; x < matrixWidth; x++) {\n                if (image.get(left + x * moduleSize, iOffset)) {\n                    bits.set(x, y);\n                }\n            }\n        }\n        return bits;\n    };\n    DataMatrixReader.moduleSize = function (leftTopBlack, image) {\n        var width = image.getWidth();\n        var x = leftTopBlack[0];\n        var y = leftTopBlack[1];\n        while (x < width && image.get(x, y)) {\n            x++;\n        }\n        if (x === width) {\n            throw new NotFoundException_1.default();\n        }\n        var moduleSize = x - leftTopBlack[0];\n        if (moduleSize === 0) {\n            throw new NotFoundException_1.default();\n        }\n        return moduleSize;\n    };\n    DataMatrixReader.NO_POINTS = [];\n    return DataMatrixReader;\n}());\nexports.default = DataMatrixReader;\n//# sourceMappingURL=DataMatrixReader.js.map"]},"metadata":{},"sourceType":"script"}