{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing {*/\n/**\n * Encapsulates a type of hint that a caller may pass to a barcode reader to help it\n * more quickly or accurately decode it. It is up to implementations to decide what,\n * if anything, to do with the information that is supplied.\n *\n * @author Sean Owen\n * @author dswitkin@google.com (Daniel Switkin)\n * @see Reader#decode(BinaryBitmap,java.util.Map)\n */\nvar DecodeHintType;\n(function (DecodeHintType) {\n  /**\n   * Unspecified, application-specific hint. Maps to an unspecified {@link Object}.\n   */\n  DecodeHintType[DecodeHintType[\"OTHER\"] = 0] = \"OTHER\"; /*(Object.class)*/\n  /**\n   * Image is a pure monochrome image of a barcode. Doesn't matter what it maps to;\n   * use {@link Boolean#TRUE}.\n   */\n  DecodeHintType[DecodeHintType[\"PURE_BARCODE\"] = 1] = \"PURE_BARCODE\"; /*(Void.class)*/\n  /**\n   * Image is known to be of one of a few possible formats.\n   * Maps to a {@link List} of {@link BarcodeFormat}s.\n   */\n  DecodeHintType[DecodeHintType[\"POSSIBLE_FORMATS\"] = 2] = \"POSSIBLE_FORMATS\"; /*(List.class)*/\n  /**\n   * Spend more time to try to find a barcode; optimize for accuracy, not speed.\n   * Doesn't matter what it maps to; use {@link Boolean#TRUE}.\n   */\n  DecodeHintType[DecodeHintType[\"TRY_HARDER\"] = 3] = \"TRY_HARDER\"; /*(Void.class)*/\n  /**\n   * Specifies what character encoding to use when decoding, where applicable (type String)\n   */\n  DecodeHintType[DecodeHintType[\"CHARACTER_SET\"] = 4] = \"CHARACTER_SET\"; /*(String.class)*/\n  /**\n   * Allowed lengths of encoded data -- reject anything else. Maps to an {@code Int32Array}.\n   */\n  DecodeHintType[DecodeHintType[\"ALLOWED_LENGTHS\"] = 5] = \"ALLOWED_LENGTHS\"; /*(Int32Array.class)*/\n  /**\n   * Assume Code 39 codes employ a check digit. Doesn't matter what it maps to;\n   * use {@link Boolean#TRUE}.\n   */\n  DecodeHintType[DecodeHintType[\"ASSUME_CODE_39_CHECK_DIGIT\"] = 6] = \"ASSUME_CODE_39_CHECK_DIGIT\"; /*(Void.class)*/\n  /**\n   * Assume the barcode is being processed as a GS1 barcode, and modify behavior as needed.\n   * For example this affects FNC1 handling for Code 128 (aka GS1-128). Doesn't matter what it maps to;\n   * use {@link Boolean#TRUE}.\n   */\n  DecodeHintType[DecodeHintType[\"ASSUME_GS1\"] = 7] = \"ASSUME_GS1\"; /*(Void.class)*/\n  /**\n   * If true, return the start and end digits in a Codabar barcode instead of stripping them. They\n   * are alpha, whereas the rest are numeric. By default, they are stripped, but this causes them\n   * to not be. Doesn't matter what it maps to; use {@link Boolean#TRUE}.\n   */\n  DecodeHintType[DecodeHintType[\"RETURN_CODABAR_START_END\"] = 8] = \"RETURN_CODABAR_START_END\"; /*(Void.class)*/\n  /**\n   * The caller needs to be notified via callback when a possible {@link ResultPoint}\n   * is found. Maps to a {@link ResultPointCallback}.\n   */\n  DecodeHintType[DecodeHintType[\"NEED_RESULT_POINT_CALLBACK\"] = 9] = \"NEED_RESULT_POINT_CALLBACK\"; /*(ResultPointCallback.class)*/\n  /**\n   * Allowed extension lengths for EAN or UPC barcodes. Other formats will ignore this.\n   * Maps to an {@code Int32Array} of the allowed extension lengths, for example [2], [5], or [2, 5].\n   * If it is optional to have an extension, do not set this hint. If this is set,\n   * and a UPC or EAN barcode is found but an extension is not, then no result will be returned\n   * at all.\n   */\n  DecodeHintType[DecodeHintType[\"ALLOWED_EAN_EXTENSIONS\"] = 10] = \"ALLOWED_EAN_EXTENSIONS\"; /*(Int32Array.class)*/\n  // End of enumeration values.\n  /**\n   * Data type the hint is expecting.\n   * Among the possible values the {@link Void} stands out as being used for\n   * hints that do not expect a value to be supplied (flag hints). Such hints\n   * will possibly have their value ignored, or replaced by a\n   * {@link Boolean#TRUE}. Hint suppliers should probably use\n   * {@link Boolean#TRUE} as directed by the actual hint documentation.\n   */\n  // private valueType: Class<?>\n  // DecodeHintType(valueType: Class<?>) {\n  //   this.valueType = valueType\n  // }\n  // public getValueType(): Class<?> {\n  //   return valueType\n  // }\n})(DecodeHintType || (DecodeHintType = {}));\nexports.default = DecodeHintType;","map":{"version":3,"sources":["../../src/core/DecodeHintType.ts"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;AAcG;;;;AAEH;AAEA;;;;;;;;AAQG;AACH,IAAK,cA4FJ;AA5FD,CAAA,UAAK,cAAc,EAAA;EAEf;;AAEG;EACH,cAAA,CAAA,cAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAK,CAAA,CAAA;EAEL;;;AAGG;EACH,cAAA,CAAA,cAAA,CAAA,cAAA,CAAA,GAAA,CAAA,CAAA,GAAA,cAAY,CAAA,CAAA;EAEZ;;;AAGG;EACH,cAAA,CAAA,cAAA,CAAA,kBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,kBAAgB,CAAA,CAAA;EAEhB;;;AAGG;EACH,cAAA,CAAA,cAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAU,CAAA,CAAA;EAEV;;AAEG;EACH,cAAA,CAAA,cAAA,CAAA,eAAA,CAAA,GAAA,CAAA,CAAA,GAAA,eAAa,CAAA,CAAA;EAEb;;AAEG;EACH,cAAA,CAAA,cAAA,CAAA,iBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,iBAAe,CAAA,CAAA;EAEf;;;AAGG;EACH,cAAA,CAAA,cAAA,CAAA,4BAAA,CAAA,GAAA,CAAA,CAAA,GAAA,4BAA0B,CAAA,CAAA;EAE1B;;;;AAIG;EACH,cAAA,CAAA,cAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAU,CAAA,CAAA;EAEV;;;;AAIG;EACH,cAAA,CAAA,cAAA,CAAA,0BAAA,CAAA,GAAA,CAAA,CAAA,GAAA,0BAAwB,CAAA,CAAA;EAExB;;;AAGG;EACH,cAAA,CAAA,cAAA,CAAA,4BAAA,CAAA,GAAA,CAAA,CAAA,GAAA,4BAA0B,CAAA,CAAA;EAG1B;;;;;;AAMG;EACH,cAAA,CAAA,cAAA,CAAA,wBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,wBAAsB,CAAA,CAAA;EAEtB;EAGA;;;;;;;AAOG;EACH;EAEA;EACA;EACA;EAEA;EACA;EACA;AAEJ,CAAC,EA5FI,cAAc,KAAd,cAAc,GAAA,CAAA,CAAA,CAAA,CAAA;AA8FnB,OAAA,CAAA,OAAA,GAAe,cAAc","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing {*/\n/**\n * Encapsulates a type of hint that a caller may pass to a barcode reader to help it\n * more quickly or accurately decode it. It is up to implementations to decide what,\n * if anything, to do with the information that is supplied.\n *\n * @author Sean Owen\n * @author dswitkin@google.com (Daniel Switkin)\n * @see Reader#decode(BinaryBitmap,java.util.Map)\n */\nvar DecodeHintType;\n(function (DecodeHintType) {\n    /**\n     * Unspecified, application-specific hint. Maps to an unspecified {@link Object}.\n     */\n    DecodeHintType[DecodeHintType[\"OTHER\"] = 0] = \"OTHER\"; /*(Object.class)*/\n    /**\n     * Image is a pure monochrome image of a barcode. Doesn't matter what it maps to;\n     * use {@link Boolean#TRUE}.\n     */\n    DecodeHintType[DecodeHintType[\"PURE_BARCODE\"] = 1] = \"PURE_BARCODE\"; /*(Void.class)*/\n    /**\n     * Image is known to be of one of a few possible formats.\n     * Maps to a {@link List} of {@link BarcodeFormat}s.\n     */\n    DecodeHintType[DecodeHintType[\"POSSIBLE_FORMATS\"] = 2] = \"POSSIBLE_FORMATS\"; /*(List.class)*/\n    /**\n     * Spend more time to try to find a barcode; optimize for accuracy, not speed.\n     * Doesn't matter what it maps to; use {@link Boolean#TRUE}.\n     */\n    DecodeHintType[DecodeHintType[\"TRY_HARDER\"] = 3] = \"TRY_HARDER\"; /*(Void.class)*/\n    /**\n     * Specifies what character encoding to use when decoding, where applicable (type String)\n     */\n    DecodeHintType[DecodeHintType[\"CHARACTER_SET\"] = 4] = \"CHARACTER_SET\"; /*(String.class)*/\n    /**\n     * Allowed lengths of encoded data -- reject anything else. Maps to an {@code Int32Array}.\n     */\n    DecodeHintType[DecodeHintType[\"ALLOWED_LENGTHS\"] = 5] = \"ALLOWED_LENGTHS\"; /*(Int32Array.class)*/\n    /**\n     * Assume Code 39 codes employ a check digit. Doesn't matter what it maps to;\n     * use {@link Boolean#TRUE}.\n     */\n    DecodeHintType[DecodeHintType[\"ASSUME_CODE_39_CHECK_DIGIT\"] = 6] = \"ASSUME_CODE_39_CHECK_DIGIT\"; /*(Void.class)*/\n    /**\n     * Assume the barcode is being processed as a GS1 barcode, and modify behavior as needed.\n     * For example this affects FNC1 handling for Code 128 (aka GS1-128). Doesn't matter what it maps to;\n     * use {@link Boolean#TRUE}.\n     */\n    DecodeHintType[DecodeHintType[\"ASSUME_GS1\"] = 7] = \"ASSUME_GS1\"; /*(Void.class)*/\n    /**\n     * If true, return the start and end digits in a Codabar barcode instead of stripping them. They\n     * are alpha, whereas the rest are numeric. By default, they are stripped, but this causes them\n     * to not be. Doesn't matter what it maps to; use {@link Boolean#TRUE}.\n     */\n    DecodeHintType[DecodeHintType[\"RETURN_CODABAR_START_END\"] = 8] = \"RETURN_CODABAR_START_END\"; /*(Void.class)*/\n    /**\n     * The caller needs to be notified via callback when a possible {@link ResultPoint}\n     * is found. Maps to a {@link ResultPointCallback}.\n     */\n    DecodeHintType[DecodeHintType[\"NEED_RESULT_POINT_CALLBACK\"] = 9] = \"NEED_RESULT_POINT_CALLBACK\"; /*(ResultPointCallback.class)*/\n    /**\n     * Allowed extension lengths for EAN or UPC barcodes. Other formats will ignore this.\n     * Maps to an {@code Int32Array} of the allowed extension lengths, for example [2], [5], or [2, 5].\n     * If it is optional to have an extension, do not set this hint. If this is set,\n     * and a UPC or EAN barcode is found but an extension is not, then no result will be returned\n     * at all.\n     */\n    DecodeHintType[DecodeHintType[\"ALLOWED_EAN_EXTENSIONS\"] = 10] = \"ALLOWED_EAN_EXTENSIONS\"; /*(Int32Array.class)*/\n    // End of enumeration values.\n    /**\n     * Data type the hint is expecting.\n     * Among the possible values the {@link Void} stands out as being used for\n     * hints that do not expect a value to be supplied (flag hints). Such hints\n     * will possibly have their value ignored, or replaced by a\n     * {@link Boolean#TRUE}. Hint suppliers should probably use\n     * {@link Boolean#TRUE} as directed by the actual hint documentation.\n     */\n    // private valueType: Class<?>\n    // DecodeHintType(valueType: Class<?>) {\n    //   this.valueType = valueType\n    // }\n    // public getValueType(): Class<?> {\n    //   return valueType\n    // }\n})(DecodeHintType || (DecodeHintType = {}));\nexports.default = DecodeHintType;\n//# sourceMappingURL=DecodeHintType.js.map"]},"metadata":{},"sourceType":"script"}