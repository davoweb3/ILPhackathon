{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common.detector {*/\nvar ResultPoint_1 = require(\"../../ResultPoint\");\nvar MathUtils_1 = require(\"./MathUtils\");\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/**\n * <p>\n * Detects a candidate barcode-like rectangular region within an image. It\n * starts around the center of the image, increases the size of the candidate\n * region until it finds a white rectangular region. By keeping track of the\n * last black points it encountered, it determines the corners of the barcode.\n * </p>\n *\n * @author David Olivier\n */\nvar WhiteRectangleDetector = /** @class */function () {\n  // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {\n  //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)\n  // }\n  /**\n   * @param image barcode image to find a rectangle in\n   * @param initSize initial size of search area around center\n   * @param x x position of search center\n   * @param y y position of search center\n   * @throws NotFoundException if image is too small to accommodate {@code initSize}\n   */\n  function WhiteRectangleDetector(image, initSize /*int*/, x /*int*/, y /*int*/) {\n    this.image = image;\n    this.height = image.getHeight();\n    this.width = image.getWidth();\n    if (undefined === initSize || null === initSize) {\n      initSize = WhiteRectangleDetector.INIT_SIZE;\n    }\n    if (undefined === x || null === x) {\n      x = image.getWidth() / 2 | 0;\n    }\n    if (undefined === y || null === y) {\n      y = image.getHeight() / 2 | 0;\n    }\n    var halfsize = initSize / 2 | 0;\n    this.leftInit = x - halfsize;\n    this.rightInit = x + halfsize;\n    this.upInit = y - halfsize;\n    this.downInit = y + halfsize;\n    if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {\n      throw new NotFoundException_1.default();\n    }\n  }\n  /**\n   * <p>\n   * Detects a candidate barcode-like rectangular region within an image. It\n   * starts around the center of the image, increases the size of the candidate\n   * region until it finds a white rectangular region.\n   * </p>\n   *\n   * @return {@link ResultPoint}[] describing the corners of the rectangular\n   *         region. The first and last points are opposed on the diagonal, as\n   *         are the second and third. The first point will be the topmost\n   *         point and the last, the bottommost. The second point will be\n   *         leftmost and the third, the rightmost\n   * @throws NotFoundException if no Data Matrix Code can be found\n   */\n  WhiteRectangleDetector.prototype.detect = function () {\n    var left = this.leftInit;\n    var right = this.rightInit;\n    var up = this.upInit;\n    var down = this.downInit;\n    var sizeExceeded = false;\n    var aBlackPointFoundOnBorder = true;\n    var atLeastOneBlackPointFoundOnBorder = false;\n    var atLeastOneBlackPointFoundOnRight = false;\n    var atLeastOneBlackPointFoundOnBottom = false;\n    var atLeastOneBlackPointFoundOnLeft = false;\n    var atLeastOneBlackPointFoundOnTop = false;\n    var width = this.width;\n    var height = this.height;\n    while (aBlackPointFoundOnBorder) {\n      aBlackPointFoundOnBorder = false;\n      // .....\n      // .   |\n      // .....\n      var rightBorderNotWhite = true;\n      while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\n        rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);\n        if (rightBorderNotWhite) {\n          right++;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnRight = true;\n        } else if (!atLeastOneBlackPointFoundOnRight) {\n          right++;\n        }\n      }\n      if (right >= width) {\n        sizeExceeded = true;\n        break;\n      }\n      // .....\n      // .   .\n      // .___.\n      var bottomBorderNotWhite = true;\n      while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\n        bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);\n        if (bottomBorderNotWhite) {\n          down++;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnBottom = true;\n        } else if (!atLeastOneBlackPointFoundOnBottom) {\n          down++;\n        }\n      }\n      if (down >= height) {\n        sizeExceeded = true;\n        break;\n      }\n      // .....\n      // |   .\n      // .....\n      var leftBorderNotWhite = true;\n      while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\n        leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);\n        if (leftBorderNotWhite) {\n          left--;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnLeft = true;\n        } else if (!atLeastOneBlackPointFoundOnLeft) {\n          left--;\n        }\n      }\n      if (left < 0) {\n        sizeExceeded = true;\n        break;\n      }\n      // .___.\n      // .   .\n      // .....\n      var topBorderNotWhite = true;\n      while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\n        topBorderNotWhite = this.containsBlackPoint(left, right, up, true);\n        if (topBorderNotWhite) {\n          up--;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnTop = true;\n        } else if (!atLeastOneBlackPointFoundOnTop) {\n          up--;\n        }\n      }\n      if (up < 0) {\n        sizeExceeded = true;\n        break;\n      }\n      if (aBlackPointFoundOnBorder) {\n        atLeastOneBlackPointFoundOnBorder = true;\n      }\n    }\n    if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {\n      var maxSize = right - left;\n      var z = null;\n      for (var i = 1; z === null && i < maxSize; i++) {\n        z = this.getBlackPointOnSegment(left, down - i, left + i, down);\n      }\n      if (z == null) {\n        throw new NotFoundException_1.default();\n      }\n      var t = null;\n      // go down right\n      for (var i = 1; t === null && i < maxSize; i++) {\n        t = this.getBlackPointOnSegment(left, up + i, left + i, up);\n      }\n      if (t == null) {\n        throw new NotFoundException_1.default();\n      }\n      var x = null;\n      // go down left\n      for (var i = 1; x === null && i < maxSize; i++) {\n        x = this.getBlackPointOnSegment(right, up + i, right - i, up);\n      }\n      if (x == null) {\n        throw new NotFoundException_1.default();\n      }\n      var y = null;\n      // go up left\n      for (var i = 1; y === null && i < maxSize; i++) {\n        y = this.getBlackPointOnSegment(right, down - i, right - i, down);\n      }\n      if (y == null) {\n        throw new NotFoundException_1.default();\n      }\n      return this.centerEdges(y, z, x, t);\n    } else {\n      throw new NotFoundException_1.default();\n    }\n  };\n  WhiteRectangleDetector.prototype.getBlackPointOnSegment = function (aX /*float*/, aY /*float*/, bX /*float*/, bY /*float*/) {\n    var dist = MathUtils_1.default.round(MathUtils_1.default.distance(aX, aY, bX, bY));\n    var xStep = (bX - aX) / dist;\n    var yStep = (bY - aY) / dist;\n    var image = this.image;\n    for (var i = 0; i < dist; i++) {\n      var x = MathUtils_1.default.round(aX + i * xStep);\n      var y = MathUtils_1.default.round(aY + i * yStep);\n      if (image.get(x, y)) {\n        return new ResultPoint_1.default(x, y);\n      }\n    }\n    return null;\n  };\n  /**\n   * recenters the points of a constant distance towards the center\n   *\n   * @param y bottom most point\n   * @param z left most point\n   * @param x right most point\n   * @param t top most point\n   * @return {@link ResultPoint}[] describing the corners of the rectangular\n   *         region. The first and last points are opposed on the diagonal, as\n   *         are the second and third. The first point will be the topmost\n   *         point and the last, the bottommost. The second point will be\n   *         leftmost and the third, the rightmost\n   */\n  WhiteRectangleDetector.prototype.centerEdges = function (y, z, x, t) {\n    //\n    //       t            t\n    //  z                      x\n    //        x    OR    z\n    //   y                    y\n    //\n    var yi = y.getX();\n    var yj = y.getY();\n    var zi = z.getX();\n    var zj = z.getY();\n    var xi = x.getX();\n    var xj = x.getY();\n    var ti = t.getX();\n    var tj = t.getY();\n    var CORR = WhiteRectangleDetector.CORR;\n    if (yi < this.width / 2.0) {\n      return [new ResultPoint_1.default(ti - CORR, tj + CORR), new ResultPoint_1.default(zi + CORR, zj + CORR), new ResultPoint_1.default(xi - CORR, xj - CORR), new ResultPoint_1.default(yi + CORR, yj - CORR)];\n    } else {\n      return [new ResultPoint_1.default(ti + CORR, tj + CORR), new ResultPoint_1.default(zi + CORR, zj - CORR), new ResultPoint_1.default(xi - CORR, xj + CORR), new ResultPoint_1.default(yi - CORR, yj - CORR)];\n    }\n  };\n  /**\n   * Determines whether a segment contains a black point\n   *\n   * @param a          min value of the scanned coordinate\n   * @param b          max value of the scanned coordinate\n   * @param fixed      value of fixed coordinate\n   * @param horizontal set to true if scan must be horizontal, false if vertical\n   * @return true if a black point has been found, else false.\n   */\n  WhiteRectangleDetector.prototype.containsBlackPoint = function (a /*int*/, b /*int*/, fixed /*int*/, horizontal) {\n    var image = this.image;\n    if (horizontal) {\n      for (var x = a; x <= b; x++) {\n        if (image.get(x, fixed)) {\n          return true;\n        }\n      }\n    } else {\n      for (var y = a; y <= b; y++) {\n        if (image.get(fixed, y)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  WhiteRectangleDetector.INIT_SIZE = 10;\n  WhiteRectangleDetector.CORR = 1;\n  return WhiteRectangleDetector;\n}();\nexports.default = WhiteRectangleDetector;","map":{"version":3,"sources":["../../../../src/core/common/detector/WhiteRectangleDetector.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.common.detector {*/\nvar ResultPoint_1 = require(\"../../ResultPoint\");\nvar MathUtils_1 = require(\"./MathUtils\");\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/**\n * <p>\n * Detects a candidate barcode-like rectangular region within an image. It\n * starts around the center of the image, increases the size of the candidate\n * region until it finds a white rectangular region. By keeping track of the\n * last black points it encountered, it determines the corners of the barcode.\n * </p>\n *\n * @author David Olivier\n */\nvar WhiteRectangleDetector = /** @class */ (function () {\n    // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {\n    //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)\n    // }\n    /**\n     * @param image barcode image to find a rectangle in\n     * @param initSize initial size of search area around center\n     * @param x x position of search center\n     * @param y y position of search center\n     * @throws NotFoundException if image is too small to accommodate {@code initSize}\n     */\n    function WhiteRectangleDetector(image, initSize /*int*/, x /*int*/, y /*int*/) {\n        this.image = image;\n        this.height = image.getHeight();\n        this.width = image.getWidth();\n        if (undefined === initSize || null === initSize) {\n            initSize = WhiteRectangleDetector.INIT_SIZE;\n        }\n        if (undefined === x || null === x) {\n            x = image.getWidth() / 2 | 0;\n        }\n        if (undefined === y || null === y) {\n            y = image.getHeight() / 2 | 0;\n        }\n        var halfsize = initSize / 2 | 0;\n        this.leftInit = x - halfsize;\n        this.rightInit = x + halfsize;\n        this.upInit = y - halfsize;\n        this.downInit = y + halfsize;\n        if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {\n            throw new NotFoundException_1.default();\n        }\n    }\n    /**\n     * <p>\n     * Detects a candidate barcode-like rectangular region within an image. It\n     * starts around the center of the image, increases the size of the candidate\n     * region until it finds a white rectangular region.\n     * </p>\n     *\n     * @return {@link ResultPoint}[] describing the corners of the rectangular\n     *         region. The first and last points are opposed on the diagonal, as\n     *         are the second and third. The first point will be the topmost\n     *         point and the last, the bottommost. The second point will be\n     *         leftmost and the third, the rightmost\n     * @throws NotFoundException if no Data Matrix Code can be found\n     */\n    WhiteRectangleDetector.prototype.detect = function () {\n        var left = this.leftInit;\n        var right = this.rightInit;\n        var up = this.upInit;\n        var down = this.downInit;\n        var sizeExceeded = false;\n        var aBlackPointFoundOnBorder = true;\n        var atLeastOneBlackPointFoundOnBorder = false;\n        var atLeastOneBlackPointFoundOnRight = false;\n        var atLeastOneBlackPointFoundOnBottom = false;\n        var atLeastOneBlackPointFoundOnLeft = false;\n        var atLeastOneBlackPointFoundOnTop = false;\n        var width = this.width;\n        var height = this.height;\n        while (aBlackPointFoundOnBorder) {\n            aBlackPointFoundOnBorder = false;\n            // .....\n            // .   |\n            // .....\n            var rightBorderNotWhite = true;\n            while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\n                rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);\n                if (rightBorderNotWhite) {\n                    right++;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnRight = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnRight) {\n                    right++;\n                }\n            }\n            if (right >= width) {\n                sizeExceeded = true;\n                break;\n            }\n            // .....\n            // .   .\n            // .___.\n            var bottomBorderNotWhite = true;\n            while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\n                bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);\n                if (bottomBorderNotWhite) {\n                    down++;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnBottom = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnBottom) {\n                    down++;\n                }\n            }\n            if (down >= height) {\n                sizeExceeded = true;\n                break;\n            }\n            // .....\n            // |   .\n            // .....\n            var leftBorderNotWhite = true;\n            while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\n                leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);\n                if (leftBorderNotWhite) {\n                    left--;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnLeft = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnLeft) {\n                    left--;\n                }\n            }\n            if (left < 0) {\n                sizeExceeded = true;\n                break;\n            }\n            // .___.\n            // .   .\n            // .....\n            var topBorderNotWhite = true;\n            while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\n                topBorderNotWhite = this.containsBlackPoint(left, right, up, true);\n                if (topBorderNotWhite) {\n                    up--;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnTop = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnTop) {\n                    up--;\n                }\n            }\n            if (up < 0) {\n                sizeExceeded = true;\n                break;\n            }\n            if (aBlackPointFoundOnBorder) {\n                atLeastOneBlackPointFoundOnBorder = true;\n            }\n        }\n        if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {\n            var maxSize = right - left;\n            var z = null;\n            for (var i = 1; z === null && i < maxSize; i++) {\n                z = this.getBlackPointOnSegment(left, down - i, left + i, down);\n            }\n            if (z == null) {\n                throw new NotFoundException_1.default();\n            }\n            var t = null;\n            // go down right\n            for (var i = 1; t === null && i < maxSize; i++) {\n                t = this.getBlackPointOnSegment(left, up + i, left + i, up);\n            }\n            if (t == null) {\n                throw new NotFoundException_1.default();\n            }\n            var x = null;\n            // go down left\n            for (var i = 1; x === null && i < maxSize; i++) {\n                x = this.getBlackPointOnSegment(right, up + i, right - i, up);\n            }\n            if (x == null) {\n                throw new NotFoundException_1.default();\n            }\n            var y = null;\n            // go up left\n            for (var i = 1; y === null && i < maxSize; i++) {\n                y = this.getBlackPointOnSegment(right, down - i, right - i, down);\n            }\n            if (y == null) {\n                throw new NotFoundException_1.default();\n            }\n            return this.centerEdges(y, z, x, t);\n        }\n        else {\n            throw new NotFoundException_1.default();\n        }\n    };\n    WhiteRectangleDetector.prototype.getBlackPointOnSegment = function (aX /*float*/, aY /*float*/, bX /*float*/, bY /*float*/) {\n        var dist = MathUtils_1.default.round(MathUtils_1.default.distance(aX, aY, bX, bY));\n        var xStep = (bX - aX) / dist;\n        var yStep = (bY - aY) / dist;\n        var image = this.image;\n        for (var i = 0; i < dist; i++) {\n            var x = MathUtils_1.default.round(aX + i * xStep);\n            var y = MathUtils_1.default.round(aY + i * yStep);\n            if (image.get(x, y)) {\n                return new ResultPoint_1.default(x, y);\n            }\n        }\n        return null;\n    };\n    /**\n     * recenters the points of a constant distance towards the center\n     *\n     * @param y bottom most point\n     * @param z left most point\n     * @param x right most point\n     * @param t top most point\n     * @return {@link ResultPoint}[] describing the corners of the rectangular\n     *         region. The first and last points are opposed on the diagonal, as\n     *         are the second and third. The first point will be the topmost\n     *         point and the last, the bottommost. The second point will be\n     *         leftmost and the third, the rightmost\n     */\n    WhiteRectangleDetector.prototype.centerEdges = function (y, z, x, t) {\n        //\n        //       t            t\n        //  z                      x\n        //        x    OR    z\n        //   y                    y\n        //\n        var yi = y.getX();\n        var yj = y.getY();\n        var zi = z.getX();\n        var zj = z.getY();\n        var xi = x.getX();\n        var xj = x.getY();\n        var ti = t.getX();\n        var tj = t.getY();\n        var CORR = WhiteRectangleDetector.CORR;\n        if (yi < this.width / 2.0) {\n            return [\n                new ResultPoint_1.default(ti - CORR, tj + CORR),\n                new ResultPoint_1.default(zi + CORR, zj + CORR),\n                new ResultPoint_1.default(xi - CORR, xj - CORR),\n                new ResultPoint_1.default(yi + CORR, yj - CORR)\n            ];\n        }\n        else {\n            return [\n                new ResultPoint_1.default(ti + CORR, tj + CORR),\n                new ResultPoint_1.default(zi + CORR, zj - CORR),\n                new ResultPoint_1.default(xi - CORR, xj + CORR),\n                new ResultPoint_1.default(yi - CORR, yj - CORR)\n            ];\n        }\n    };\n    /**\n     * Determines whether a segment contains a black point\n     *\n     * @param a          min value of the scanned coordinate\n     * @param b          max value of the scanned coordinate\n     * @param fixed      value of fixed coordinate\n     * @param horizontal set to true if scan must be horizontal, false if vertical\n     * @return true if a black point has been found, else false.\n     */\n    WhiteRectangleDetector.prototype.containsBlackPoint = function (a /*int*/, b /*int*/, fixed /*int*/, horizontal) {\n        var image = this.image;\n        if (horizontal) {\n            for (var x = a; x <= b; x++) {\n                if (image.get(x, fixed)) {\n                    return true;\n                }\n            }\n        }\n        else {\n            for (var y = a; y <= b; y++) {\n                if (image.get(fixed, y)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    WhiteRectangleDetector.INIT_SIZE = 10;\n    WhiteRectangleDetector.CORR = 1;\n    return WhiteRectangleDetector;\n}());\nexports.default = WhiteRectangleDetector;\n//# sourceMappingURL=WhiteRectangleDetector.js.map"]},"metadata":{},"sourceType":"script"}