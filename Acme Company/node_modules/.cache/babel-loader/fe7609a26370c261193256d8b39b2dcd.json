{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BitSource_1 = require(\"../../common/BitSource\");\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\");\nvar DecoderResult_1 = require(\"../../common/DecoderResult\");\nvar StringUtils_1 = require(\"../../common/StringUtils\");\nvar Mode_1 = require(\"./Mode\");\nvar StringBuilder_1 = require(\"../../util/StringBuilder\");\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\nvar FormatException_1 = require(\"../../FormatException\");\n/*import java.io.UnsupportedEncodingException;*/\n/*import java.util.ArrayList;*/\n/*import java.util.Collection;*/\n/*import java.util.List;*/\n/*import java.util.Map;*/\n/**\n * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes\n * in one QR Code. This class decodes the bits back into text.</p>\n *\n * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>\n *\n * @author Sean Owen\n */\nvar DecodedBitStreamParser = /** @class */function () {\n  function DecodedBitStreamParser() {}\n  DecodedBitStreamParser.decode = function (bytes, version, ecLevel, hints) {\n    var bits = new BitSource_1.default(bytes);\n    var result = new StringBuilder_1.default();\n    var byteSegments = new Array(); // 1\n    // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below\n    var symbolSequence = -1;\n    var parityData = -1;\n    try {\n      var currentCharacterSetECI = null;\n      var fc1InEffect = false;\n      var mode = void 0;\n      do {\n        // While still another segment to read...\n        if (bits.available() < 4) {\n          // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here\n          mode = Mode_1.default.TERMINATOR;\n        } else {\n          var modeBits = bits.readBits(4);\n          mode = Mode_1.default.forBits(modeBits); // mode is encoded by 4 bits\n        }\n\n        switch (mode) {\n          case Mode_1.default.TERMINATOR:\n            break;\n          case Mode_1.default.FNC1_FIRST_POSITION:\n          case Mode_1.default.FNC1_SECOND_POSITION:\n            // We do little with FNC1 except alter the parsed result a bit according to the spec\n            fc1InEffect = true;\n            break;\n          case Mode_1.default.STRUCTURED_APPEND:\n            if (bits.available() < 16) {\n              throw new FormatException_1.default();\n            }\n            // sequence number and parity is added later to the result metadata\n            // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue\n            symbolSequence = bits.readBits(8);\n            parityData = bits.readBits(8);\n            break;\n          case Mode_1.default.ECI:\n            // Count doesn't apply to ECI\n            var value = DecodedBitStreamParser.parseECIValue(bits);\n            currentCharacterSetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(value);\n            if (currentCharacterSetECI === null) {\n              throw new FormatException_1.default();\n            }\n            break;\n          case Mode_1.default.HANZI:\n            // First handle Hanzi mode which does not start with character count\n            // Chinese mode contains a sub set indicator right after mode indicator\n            var subset = bits.readBits(4);\n            var countHanzi = bits.readBits(mode.getCharacterCountBits(version));\n            if (subset === DecodedBitStreamParser.GB2312_SUBSET) {\n              DecodedBitStreamParser.decodeHanziSegment(bits, result, countHanzi);\n            }\n            break;\n          default:\n            // \"Normal\" QR code modes:\n            // How many characters will follow, encoded in this mode?\n            var count = bits.readBits(mode.getCharacterCountBits(version));\n            switch (mode) {\n              case Mode_1.default.NUMERIC:\n                DecodedBitStreamParser.decodeNumericSegment(bits, result, count);\n                break;\n              case Mode_1.default.ALPHANUMERIC:\n                DecodedBitStreamParser.decodeAlphanumericSegment(bits, result, count, fc1InEffect);\n                break;\n              case Mode_1.default.BYTE:\n                DecodedBitStreamParser.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);\n                break;\n              case Mode_1.default.KANJI:\n                DecodedBitStreamParser.decodeKanjiSegment(bits, result, count);\n                break;\n              default:\n                throw new FormatException_1.default();\n            }\n            break;\n        }\n      } while (mode !== Mode_1.default.TERMINATOR);\n    } catch (iae /*: IllegalArgumentException*/) {\n      // from readBits() calls\n      throw new FormatException_1.default();\n    }\n    return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);\n  };\n  /**\n   * See specification GBT 18284-2000\n   */\n  DecodedBitStreamParser.decodeHanziSegment = function (bits, result, count /*int*/) {\n    // Don't crash trying to read more bits than we have available.\n    if (count * 13 > bits.available()) {\n      throw new FormatException_1.default();\n    }\n    // Each character will require 2 bytes. Read the characters as 2-byte pairs\n    // and decode as GB2312 afterwards\n    var buffer = new Uint8Array(2 * count);\n    var offset = 0;\n    while (count > 0) {\n      // Each 13 bits encodes a 2-byte character\n      var twoBytes = bits.readBits(13);\n      var assembledTwoBytes = twoBytes / 0x060 << 8 & 0xFFFFFFFF | twoBytes % 0x060;\n      if (assembledTwoBytes < 0x003BF) {\n        // In the 0xA1A1 to 0xAAFE range\n        assembledTwoBytes += 0x0A1A1;\n      } else {\n        // In the 0xB0A1 to 0xFAFE range\n        assembledTwoBytes += 0x0A6A1;\n      }\n      buffer[offset] = /*(byte) */assembledTwoBytes >> 8 & 0xFF;\n      buffer[offset + 1] = /*(byte) */assembledTwoBytes & 0xFF;\n      offset += 2;\n      count--;\n    }\n    try {\n      result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.GB2312));\n      // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point\n    } catch (ignored /*: UnsupportedEncodingException*/) {\n      throw new FormatException_1.default(ignored);\n    }\n  };\n  DecodedBitStreamParser.decodeKanjiSegment = function (bits, result, count /*int*/) {\n    // Don't crash trying to read more bits than we have available.\n    if (count * 13 > bits.available()) {\n      throw new FormatException_1.default();\n    }\n    // Each character will require 2 bytes. Read the characters as 2-byte pairs\n    // and decode as Shift_JIS afterwards\n    var buffer = new Uint8Array(2 * count);\n    var offset = 0;\n    while (count > 0) {\n      // Each 13 bits encodes a 2-byte character\n      var twoBytes = bits.readBits(13);\n      var assembledTwoBytes = twoBytes / 0x0C0 << 8 & 0xFFFFFFFF | twoBytes % 0x0C0;\n      if (assembledTwoBytes < 0x01F00) {\n        // In the 0x8140 to 0x9FFC range\n        assembledTwoBytes += 0x08140;\n      } else {\n        // In the 0xE040 to 0xEBBF range\n        assembledTwoBytes += 0x0C140;\n      }\n      buffer[offset] = /*(byte) */assembledTwoBytes >> 8;\n      buffer[offset + 1] = /*(byte) */assembledTwoBytes;\n      offset += 2;\n      count--;\n    }\n    // Shift_JIS may not be supported in some environments:\n    try {\n      result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.SHIFT_JIS));\n      // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point\n    } catch (ignored /*: UnsupportedEncodingException*/) {\n      throw new FormatException_1.default(ignored);\n    }\n  };\n  DecodedBitStreamParser.decodeByteSegment = function (bits, result, count /*int*/, currentCharacterSetECI, byteSegments, hints) {\n    // Don't crash trying to read more bits than we have available.\n    if (8 * count > bits.available()) {\n      throw new FormatException_1.default();\n    }\n    var readBytes = new Uint8Array(count);\n    for (var i = 0; i < count; i++) {\n      readBytes[i] = /*(byte) */bits.readBits(8);\n    }\n    var encoding;\n    if (currentCharacterSetECI === null) {\n      // The spec isn't clear on this mode; see\n      // section 6.4.5: t does not say which encoding to assuming\n      // upon decoding. I have seen ISO-8859-1 used as well as\n      // Shift_JIS -- without anything like an ECI designator to\n      // give a hint.\n      encoding = StringUtils_1.default.guessEncoding(readBytes, hints);\n    } else {\n      encoding = currentCharacterSetECI.getName();\n    }\n    try {\n      result.append(StringEncoding_1.default.decode(readBytes, encoding));\n    } catch (ignored /*: UnsupportedEncodingException*/) {\n      throw new FormatException_1.default(ignored);\n    }\n    byteSegments.push(readBytes);\n  };\n  DecodedBitStreamParser.toAlphaNumericChar = function (value /*int*/) {\n    if (value >= DecodedBitStreamParser.ALPHANUMERIC_CHARS.length) {\n      throw new FormatException_1.default();\n    }\n    return DecodedBitStreamParser.ALPHANUMERIC_CHARS[value];\n  };\n  DecodedBitStreamParser.decodeAlphanumericSegment = function (bits, result, count /*int*/, fc1InEffect) {\n    // Read two characters at a time\n    var start = result.length();\n    while (count > 1) {\n      if (bits.available() < 11) {\n        throw new FormatException_1.default();\n      }\n      var nextTwoCharsBits = bits.readBits(11);\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(nextTwoCharsBits % 45));\n      count -= 2;\n    }\n    if (count === 1) {\n      // special case: one character left\n      if (bits.available() < 6) {\n        throw new FormatException_1.default();\n      }\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(bits.readBits(6)));\n    }\n    // See section 6.4.8.1, 6.4.8.2\n    if (fc1InEffect) {\n      // We need to massage the result a bit if in an FNC1 mode:\n      for (var i = start; i < result.length(); i++) {\n        if (result.charAt(i) === '%') {\n          if (i < result.length() - 1 && result.charAt(i + 1) === '%') {\n            // %% is rendered as %\n            result.deleteCharAt(i + 1);\n          } else {\n            // In alpha mode, % should be converted to FNC1 separator 0x1D\n            result.setCharAt(i, String.fromCharCode(0x1D));\n          }\n        }\n      }\n    }\n  };\n  DecodedBitStreamParser.decodeNumericSegment = function (bits, result, count /*int*/) {\n    // Read three digits at a time\n    while (count >= 3) {\n      // Each 10 bits encodes three digits\n      if (bits.available() < 10) {\n        throw new FormatException_1.default();\n      }\n      var threeDigitsBits = bits.readBits(10);\n      if (threeDigitsBits >= 1000) {\n        throw new FormatException_1.default();\n      }\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(threeDigitsBits % 10));\n      count -= 3;\n    }\n    if (count === 2) {\n      // Two digits left over to read, encoded in 7 bits\n      if (bits.available() < 7) {\n        throw new FormatException_1.default();\n      }\n      var twoDigitsBits = bits.readBits(7);\n      if (twoDigitsBits >= 100) {\n        throw new FormatException_1.default();\n      }\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(twoDigitsBits % 10));\n    } else if (count === 1) {\n      // One digit left over to read\n      if (bits.available() < 4) {\n        throw new FormatException_1.default();\n      }\n      var digitBits = bits.readBits(4);\n      if (digitBits >= 10) {\n        throw new FormatException_1.default();\n      }\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(digitBits));\n    }\n  };\n  DecodedBitStreamParser.parseECIValue = function (bits) {\n    var firstByte = bits.readBits(8);\n    if ((firstByte & 0x80) === 0) {\n      // just one byte\n      return firstByte & 0x7F;\n    }\n    if ((firstByte & 0xC0) === 0x80) {\n      // two bytes\n      var secondByte = bits.readBits(8);\n      return (firstByte & 0x3F) << 8 & 0xFFFFFFFF | secondByte;\n    }\n    if ((firstByte & 0xE0) === 0xC0) {\n      // three bytes\n      var secondThirdBytes = bits.readBits(16);\n      return (firstByte & 0x1F) << 16 & 0xFFFFFFFF | secondThirdBytes;\n    }\n    throw new FormatException_1.default();\n  };\n  /**\n   * See ISO 18004:2006, 6.4.4 Table 5\n   */\n  DecodedBitStreamParser.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';\n  DecodedBitStreamParser.GB2312_SUBSET = 1;\n  return DecodedBitStreamParser;\n}();\nexports.default = DecodedBitStreamParser;\nfunction Uint8ArrayToString(a) {\n  var CHUNK_SZ = 0x8000;\n  var c = new StringBuilder_1.default();\n  for (var i = 0, length_1 = a.length; i < length_1; i += CHUNK_SZ) {\n    c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));\n  }\n  return c.toString();\n}","map":{"version":3,"sources":["../../../../src/core/qrcode/decoder/DecodedBitStreamParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BitSource_1 = require(\"../../common/BitSource\");\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\");\nvar DecoderResult_1 = require(\"../../common/DecoderResult\");\nvar StringUtils_1 = require(\"../../common/StringUtils\");\nvar Mode_1 = require(\"./Mode\");\nvar StringBuilder_1 = require(\"../../util/StringBuilder\");\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\nvar FormatException_1 = require(\"../../FormatException\");\n/*import java.io.UnsupportedEncodingException;*/\n/*import java.util.ArrayList;*/\n/*import java.util.Collection;*/\n/*import java.util.List;*/\n/*import java.util.Map;*/\n/**\n * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes\n * in one QR Code. This class decodes the bits back into text.</p>\n *\n * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>\n *\n * @author Sean Owen\n */\nvar DecodedBitStreamParser = /** @class */ (function () {\n    function DecodedBitStreamParser() {\n    }\n    DecodedBitStreamParser.decode = function (bytes, version, ecLevel, hints) {\n        var bits = new BitSource_1.default(bytes);\n        var result = new StringBuilder_1.default();\n        var byteSegments = new Array(); // 1\n        // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below\n        var symbolSequence = -1;\n        var parityData = -1;\n        try {\n            var currentCharacterSetECI = null;\n            var fc1InEffect = false;\n            var mode = void 0;\n            do {\n                // While still another segment to read...\n                if (bits.available() < 4) {\n                    // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here\n                    mode = Mode_1.default.TERMINATOR;\n                }\n                else {\n                    var modeBits = bits.readBits(4);\n                    mode = Mode_1.default.forBits(modeBits); // mode is encoded by 4 bits\n                }\n                switch (mode) {\n                    case Mode_1.default.TERMINATOR:\n                        break;\n                    case Mode_1.default.FNC1_FIRST_POSITION:\n                    case Mode_1.default.FNC1_SECOND_POSITION:\n                        // We do little with FNC1 except alter the parsed result a bit according to the spec\n                        fc1InEffect = true;\n                        break;\n                    case Mode_1.default.STRUCTURED_APPEND:\n                        if (bits.available() < 16) {\n                            throw new FormatException_1.default();\n                        }\n                        // sequence number and parity is added later to the result metadata\n                        // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue\n                        symbolSequence = bits.readBits(8);\n                        parityData = bits.readBits(8);\n                        break;\n                    case Mode_1.default.ECI:\n                        // Count doesn't apply to ECI\n                        var value = DecodedBitStreamParser.parseECIValue(bits);\n                        currentCharacterSetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(value);\n                        if (currentCharacterSetECI === null) {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case Mode_1.default.HANZI:\n                        // First handle Hanzi mode which does not start with character count\n                        // Chinese mode contains a sub set indicator right after mode indicator\n                        var subset = bits.readBits(4);\n                        var countHanzi = bits.readBits(mode.getCharacterCountBits(version));\n                        if (subset === DecodedBitStreamParser.GB2312_SUBSET) {\n                            DecodedBitStreamParser.decodeHanziSegment(bits, result, countHanzi);\n                        }\n                        break;\n                    default:\n                        // \"Normal\" QR code modes:\n                        // How many characters will follow, encoded in this mode?\n                        var count = bits.readBits(mode.getCharacterCountBits(version));\n                        switch (mode) {\n                            case Mode_1.default.NUMERIC:\n                                DecodedBitStreamParser.decodeNumericSegment(bits, result, count);\n                                break;\n                            case Mode_1.default.ALPHANUMERIC:\n                                DecodedBitStreamParser.decodeAlphanumericSegment(bits, result, count, fc1InEffect);\n                                break;\n                            case Mode_1.default.BYTE:\n                                DecodedBitStreamParser.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);\n                                break;\n                            case Mode_1.default.KANJI:\n                                DecodedBitStreamParser.decodeKanjiSegment(bits, result, count);\n                                break;\n                            default:\n                                throw new FormatException_1.default();\n                        }\n                        break;\n                }\n            } while (mode !== Mode_1.default.TERMINATOR);\n        }\n        catch (iae /*: IllegalArgumentException*/) {\n            // from readBits() calls\n            throw new FormatException_1.default();\n        }\n        return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);\n    };\n    /**\n     * See specification GBT 18284-2000\n     */\n    DecodedBitStreamParser.decodeHanziSegment = function (bits, result, count /*int*/) {\n        // Don't crash trying to read more bits than we have available.\n        if (count * 13 > bits.available()) {\n            throw new FormatException_1.default();\n        }\n        // Each character will require 2 bytes. Read the characters as 2-byte pairs\n        // and decode as GB2312 afterwards\n        var buffer = new Uint8Array(2 * count);\n        var offset = 0;\n        while (count > 0) {\n            // Each 13 bits encodes a 2-byte character\n            var twoBytes = bits.readBits(13);\n            var assembledTwoBytes = (((twoBytes / 0x060) << 8) & 0xFFFFFFFF) | (twoBytes % 0x060);\n            if (assembledTwoBytes < 0x003BF) {\n                // In the 0xA1A1 to 0xAAFE range\n                assembledTwoBytes += 0x0A1A1;\n            }\n            else {\n                // In the 0xB0A1 to 0xFAFE range\n                assembledTwoBytes += 0x0A6A1;\n            }\n            buffer[offset] = /*(byte) */ ((assembledTwoBytes >> 8) & 0xFF);\n            buffer[offset + 1] = /*(byte) */ (assembledTwoBytes & 0xFF);\n            offset += 2;\n            count--;\n        }\n        try {\n            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.GB2312));\n            // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            throw new FormatException_1.default(ignored);\n        }\n    };\n    DecodedBitStreamParser.decodeKanjiSegment = function (bits, result, count /*int*/) {\n        // Don't crash trying to read more bits than we have available.\n        if (count * 13 > bits.available()) {\n            throw new FormatException_1.default();\n        }\n        // Each character will require 2 bytes. Read the characters as 2-byte pairs\n        // and decode as Shift_JIS afterwards\n        var buffer = new Uint8Array(2 * count);\n        var offset = 0;\n        while (count > 0) {\n            // Each 13 bits encodes a 2-byte character\n            var twoBytes = bits.readBits(13);\n            var assembledTwoBytes = (((twoBytes / 0x0C0) << 8) & 0xFFFFFFFF) | (twoBytes % 0x0C0);\n            if (assembledTwoBytes < 0x01F00) {\n                // In the 0x8140 to 0x9FFC range\n                assembledTwoBytes += 0x08140;\n            }\n            else {\n                // In the 0xE040 to 0xEBBF range\n                assembledTwoBytes += 0x0C140;\n            }\n            buffer[offset] = /*(byte) */ (assembledTwoBytes >> 8);\n            buffer[offset + 1] = /*(byte) */ assembledTwoBytes;\n            offset += 2;\n            count--;\n        }\n        // Shift_JIS may not be supported in some environments:\n        try {\n            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.SHIFT_JIS));\n            // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            throw new FormatException_1.default(ignored);\n        }\n    };\n    DecodedBitStreamParser.decodeByteSegment = function (bits, result, count /*int*/, currentCharacterSetECI, byteSegments, hints) {\n        // Don't crash trying to read more bits than we have available.\n        if (8 * count > bits.available()) {\n            throw new FormatException_1.default();\n        }\n        var readBytes = new Uint8Array(count);\n        for (var i = 0; i < count; i++) {\n            readBytes[i] = /*(byte) */ bits.readBits(8);\n        }\n        var encoding;\n        if (currentCharacterSetECI === null) {\n            // The spec isn't clear on this mode; see\n            // section 6.4.5: t does not say which encoding to assuming\n            // upon decoding. I have seen ISO-8859-1 used as well as\n            // Shift_JIS -- without anything like an ECI designator to\n            // give a hint.\n            encoding = StringUtils_1.default.guessEncoding(readBytes, hints);\n        }\n        else {\n            encoding = currentCharacterSetECI.getName();\n        }\n        try {\n            result.append(StringEncoding_1.default.decode(readBytes, encoding));\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            throw new FormatException_1.default(ignored);\n        }\n        byteSegments.push(readBytes);\n    };\n    DecodedBitStreamParser.toAlphaNumericChar = function (value /*int*/) {\n        if (value >= DecodedBitStreamParser.ALPHANUMERIC_CHARS.length) {\n            throw new FormatException_1.default();\n        }\n        return DecodedBitStreamParser.ALPHANUMERIC_CHARS[value];\n    };\n    DecodedBitStreamParser.decodeAlphanumericSegment = function (bits, result, count /*int*/, fc1InEffect) {\n        // Read two characters at a time\n        var start = result.length();\n        while (count > 1) {\n            if (bits.available() < 11) {\n                throw new FormatException_1.default();\n            }\n            var nextTwoCharsBits = bits.readBits(11);\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(nextTwoCharsBits % 45));\n            count -= 2;\n        }\n        if (count === 1) {\n            // special case: one character left\n            if (bits.available() < 6) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(bits.readBits(6)));\n        }\n        // See section 6.4.8.1, 6.4.8.2\n        if (fc1InEffect) {\n            // We need to massage the result a bit if in an FNC1 mode:\n            for (var i = start; i < result.length(); i++) {\n                if (result.charAt(i) === '%') {\n                    if (i < result.length() - 1 && result.charAt(i + 1) === '%') {\n                        // %% is rendered as %\n                        result.deleteCharAt(i + 1);\n                    }\n                    else {\n                        // In alpha mode, % should be converted to FNC1 separator 0x1D\n                        result.setCharAt(i, String.fromCharCode(0x1D));\n                    }\n                }\n            }\n        }\n    };\n    DecodedBitStreamParser.decodeNumericSegment = function (bits, result, count /*int*/) {\n        // Read three digits at a time\n        while (count >= 3) {\n            // Each 10 bits encodes three digits\n            if (bits.available() < 10) {\n                throw new FormatException_1.default();\n            }\n            var threeDigitsBits = bits.readBits(10);\n            if (threeDigitsBits >= 1000) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(threeDigitsBits % 10));\n            count -= 3;\n        }\n        if (count === 2) {\n            // Two digits left over to read, encoded in 7 bits\n            if (bits.available() < 7) {\n                throw new FormatException_1.default();\n            }\n            var twoDigitsBits = bits.readBits(7);\n            if (twoDigitsBits >= 100) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(twoDigitsBits % 10));\n        }\n        else if (count === 1) {\n            // One digit left over to read\n            if (bits.available() < 4) {\n                throw new FormatException_1.default();\n            }\n            var digitBits = bits.readBits(4);\n            if (digitBits >= 10) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(digitBits));\n        }\n    };\n    DecodedBitStreamParser.parseECIValue = function (bits) {\n        var firstByte = bits.readBits(8);\n        if ((firstByte & 0x80) === 0) {\n            // just one byte\n            return firstByte & 0x7F;\n        }\n        if ((firstByte & 0xC0) === 0x80) {\n            // two bytes\n            var secondByte = bits.readBits(8);\n            return (((firstByte & 0x3F) << 8) & 0xFFFFFFFF) | secondByte;\n        }\n        if ((firstByte & 0xE0) === 0xC0) {\n            // three bytes\n            var secondThirdBytes = bits.readBits(16);\n            return (((firstByte & 0x1F) << 16) & 0xFFFFFFFF) | secondThirdBytes;\n        }\n        throw new FormatException_1.default();\n    };\n    /**\n     * See ISO 18004:2006, 6.4.4 Table 5\n     */\n    DecodedBitStreamParser.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';\n    DecodedBitStreamParser.GB2312_SUBSET = 1;\n    return DecodedBitStreamParser;\n}());\nexports.default = DecodedBitStreamParser;\nfunction Uint8ArrayToString(a) {\n    var CHUNK_SZ = 0x8000;\n    var c = new StringBuilder_1.default();\n    for (var i = 0, length_1 = a.length; i < length_1; i += CHUNK_SZ) {\n        c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));\n    }\n    return c.toString();\n}\n//# sourceMappingURL=DecodedBitStreamParser.js.map"]},"metadata":{},"sourceType":"script"}