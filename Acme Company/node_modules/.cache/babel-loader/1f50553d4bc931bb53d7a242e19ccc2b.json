{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar DataMaskValues;\n(function (DataMaskValues) {\n  DataMaskValues[DataMaskValues[\"DATA_MASK_000\"] = 0] = \"DATA_MASK_000\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_001\"] = 1] = \"DATA_MASK_001\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_010\"] = 2] = \"DATA_MASK_010\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_011\"] = 3] = \"DATA_MASK_011\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_100\"] = 4] = \"DATA_MASK_100\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_101\"] = 5] = \"DATA_MASK_101\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_110\"] = 6] = \"DATA_MASK_110\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_111\"] = 7] = \"DATA_MASK_111\";\n})(DataMaskValues = exports.DataMaskValues || (exports.DataMaskValues = {}));\n/**\n * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations\n * of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,\n * including areas used for finder patterns, timing patterns, etc. These areas should be unused\n * after the point they are unmasked anyway.</p>\n *\n * <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position\n * and j is row position. In fact, as the text says, i is row position and j is column position.</p>\n *\n * @author Sean Owen\n */\nvar DataMask = /** @class */function () {\n  // See ISO 18004:2006 6.8.1\n  function DataMask(value, isMasked) {\n    this.value = value;\n    this.isMasked = isMasked;\n  }\n  // End of enum constants.\n  /**\n   * <p>Implementations of this method reverse the data masking process applied to a QR Code and\n   * make its bits ready to read.</p>\n   *\n   * @param bits representation of QR Code bits\n   * @param dimension dimension of QR Code, represented by bits, being unmasked\n   */\n  DataMask.prototype.unmaskBitMatrix = function (bits, dimension /*int*/) {\n    for (var i = 0; i < dimension; i++) {\n      for (var j = 0; j < dimension; j++) {\n        if (this.isMasked(i, j)) {\n          bits.flip(j, i);\n        }\n      }\n    }\n  };\n  DataMask.values = new Map([\n  /**\n   * 000: mask bits for which (x + y) mod 2 == 0\n   */\n  [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, function (i /*int*/, j /*int*/) {\n    return (i + j & 0x01) === 0;\n  })],\n  /**\n   * 001: mask bits for which x mod 2 == 0\n   */\n  [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, function (i /*int*/, j /*int*/) {\n    return (i & 0x01) === 0;\n  })],\n  /**\n   * 010: mask bits for which y mod 3 == 0\n   */\n  [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, function (i /*int*/, j /*int*/) {\n    return j % 3 === 0;\n  })],\n  /**\n   * 011: mask bits for which (x + y) mod 3 == 0\n   */\n  [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, function (i /*int*/, j /*int*/) {\n    return (i + j) % 3 === 0;\n  })],\n  /**\n   * 100: mask bits for which (x/2 + y/3) mod 2 == 0\n   */\n  [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, function (i /*int*/, j /*int*/) {\n    return (Math.floor(i / 2) + Math.floor(j / 3) & 0x01) === 0;\n  })],\n  /**\n   * 101: mask bits for which xy mod 2 + xy mod 3 == 0\n   * equivalently, such that xy mod 6 == 0\n   */\n  [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, function (i /*int*/, j /*int*/) {\n    return i * j % 6 === 0;\n  })],\n  /**\n   * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0\n   * equivalently, such that xy mod 6 < 3\n   */\n  [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, function (i /*int*/, j /*int*/) {\n    return i * j % 6 < 3;\n  })],\n  /**\n   * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0\n   * equivalently, such that (x + y + xy mod 3) mod 2 == 0\n   */\n  [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, function (i /*int*/, j /*int*/) {\n    return (i + j + i * j % 3 & 0x01) === 0;\n  })]]);\n  return DataMask;\n}();\nexports.default = DataMask;","map":{"version":3,"sources":["../../../../src/core/qrcode/decoder/DataMask.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DataMaskValues;\n(function (DataMaskValues) {\n    DataMaskValues[DataMaskValues[\"DATA_MASK_000\"] = 0] = \"DATA_MASK_000\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_001\"] = 1] = \"DATA_MASK_001\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_010\"] = 2] = \"DATA_MASK_010\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_011\"] = 3] = \"DATA_MASK_011\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_100\"] = 4] = \"DATA_MASK_100\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_101\"] = 5] = \"DATA_MASK_101\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_110\"] = 6] = \"DATA_MASK_110\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_111\"] = 7] = \"DATA_MASK_111\";\n})(DataMaskValues = exports.DataMaskValues || (exports.DataMaskValues = {}));\n/**\n * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations\n * of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,\n * including areas used for finder patterns, timing patterns, etc. These areas should be unused\n * after the point they are unmasked anyway.</p>\n *\n * <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position\n * and j is row position. In fact, as the text says, i is row position and j is column position.</p>\n *\n * @author Sean Owen\n */\nvar DataMask = /** @class */ (function () {\n    // See ISO 18004:2006 6.8.1\n    function DataMask(value, isMasked) {\n        this.value = value;\n        this.isMasked = isMasked;\n    }\n    // End of enum constants.\n    /**\n     * <p>Implementations of this method reverse the data masking process applied to a QR Code and\n     * make its bits ready to read.</p>\n     *\n     * @param bits representation of QR Code bits\n     * @param dimension dimension of QR Code, represented by bits, being unmasked\n     */\n    DataMask.prototype.unmaskBitMatrix = function (bits, dimension /*int*/) {\n        for (var i = 0; i < dimension; i++) {\n            for (var j = 0; j < dimension; j++) {\n                if (this.isMasked(i, j)) {\n                    bits.flip(j, i);\n                }\n            }\n        }\n    };\n    DataMask.values = new Map([\n        /**\n         * 000: mask bits for which (x + y) mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, function (i /*int*/, j /*int*/) { return ((i + j) & 0x01) === 0; })],\n        /**\n         * 001: mask bits for which x mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, function (i /*int*/, j /*int*/) { return (i & 0x01) === 0; })],\n        /**\n         * 010: mask bits for which y mod 3 == 0\n         */\n        [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, function (i /*int*/, j /*int*/) { return j % 3 === 0; })],\n        /**\n         * 011: mask bits for which (x + y) mod 3 == 0\n         */\n        [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, function (i /*int*/, j /*int*/) { return (i + j) % 3 === 0; })],\n        /**\n         * 100: mask bits for which (x/2 + y/3) mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, function (i /*int*/, j /*int*/) { return ((Math.floor(i / 2) + Math.floor(j / 3)) & 0x01) === 0; })],\n        /**\n         * 101: mask bits for which xy mod 2 + xy mod 3 == 0\n         * equivalently, such that xy mod 6 == 0\n         */\n        [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, function (i /*int*/, j /*int*/) { return (i * j) % 6 === 0; })],\n        /**\n         * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0\n         * equivalently, such that xy mod 6 < 3\n         */\n        [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, function (i /*int*/, j /*int*/) { return ((i * j) % 6) < 3; })],\n        /**\n         * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0\n         * equivalently, such that (x + y + xy mod 3) mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, function (i /*int*/, j /*int*/) { return ((i + j + ((i * j) % 3)) & 0x01) === 0; })],\n    ]);\n    return DataMask;\n}());\nexports.default = DataMask;\n//# sourceMappingURL=DataMask.js.map"]},"metadata":{},"sourceType":"script"}