{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar IndexOutOfBoundsException_1 = require(\"../IndexOutOfBoundsException\");\nvar NullPointerException_1 = require(\"../NullPointerException\");\n/*\n * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n// package java.io;\n/**\n * This abstract class is the superclass of all classes representing\n * an output stream of bytes. An output stream accepts output bytes\n * and sends them to some sink.\n * <p>\n * Applications that need to define a subclass of\n * <code>OutputStream</code> must always provide at least a method\n * that writes one byte of output.\n *\n * @author  Arthur van Hoff\n * @see     java.io.BufferedOutputStream\n * @see     java.io.ByteArrayOutputStream\n * @see     java.io.DataOutputStream\n * @see     java.io.FilterOutputStream\n * @see     java.io.InputStream\n * @see     java.io.OutputStream#write(int)\n * @since   JDK1.0\n */\nvar OutputStream /*implements Closeable, Flushable*/ = /** @class */function () {\n  function OutputStream() {}\n  /**\n   * Writes <code>b.length</code> bytes from the specified byte array\n   * to this output stream. The general contract for <code>write(b)</code>\n   * is that it should have exactly the same effect as the call\n   * <code>write(b, 0, b.length)</code>.\n   *\n   * @param      b   the data.\n   * @exception  IOException  if an I/O error occurs.\n   * @see        java.io.OutputStream#write(byte[], int, int)\n   */\n  OutputStream.prototype.writeBytes = function (b) {\n    this.writeBytesOffset(b, 0, b.length);\n  };\n  /**\n   * Writes <code>len</code> bytes from the specified byte array\n   * starting at offset <code>off</code> to this output stream.\n   * The general contract for <code>write(b, off, len)</code> is that\n   * some of the bytes in the array <code>b</code> are written to the\n   * output stream in order; element <code>b[off]</code> is the first\n   * byte written and <code>b[off+len-1]</code> is the last byte written\n   * by this operation.\n   * <p>\n   * The <code>write</code> method of <code>OutputStream</code> calls\n   * the write method of one argument on each of the bytes to be\n   * written out. Subclasses are encouraged to override this method and\n   * provide a more efficient implementation.\n   * <p>\n   * If <code>b</code> is <code>null</code>, a\n   * <code>NullPointerException</code> is thrown.\n   * <p>\n   * If <code>off</code> is negative, or <code>len</code> is negative, or\n   * <code>off+len</code> is greater than the length of the array\n   * <code>b</code>, then an <tt>IndexOutOfBoundsException</tt> is thrown.\n   *\n   * @param      b     the data.\n   * @param      off   the start offset in the data.\n   * @param      len   the number of bytes to write.\n   * @exception  IOException  if an I/O error occurs. In particular,\n   *             an <code>IOException</code> is thrown if the output\n   *             stream is closed.\n   */\n  OutputStream.prototype.writeBytesOffset = function (b, off, len) {\n    if (b == null) {\n      throw new NullPointerException_1.default();\n    } else if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {\n      throw new IndexOutOfBoundsException_1.default();\n    } else if (len === 0) {\n      return;\n    }\n    for (var i = 0; i < len; i++) {\n      this.write(b[off + i]);\n    }\n  };\n  /**\n   * Flushes this output stream and forces any buffered output bytes\n   * to be written out. The general contract of <code>flush</code> is\n   * that calling it is an indication that, if any bytes previously\n   * written have been buffered by the implementation of the output\n   * stream, such bytes should immediately be written to their\n   * intended destination.\n   * <p>\n   * If the intended destination of this stream is an abstraction provided by\n   * the underlying operating system, for example a file, then flushing the\n   * stream guarantees only that bytes previously written to the stream are\n   * passed to the operating system for writing; it does not guarantee that\n   * they are actually written to a physical device such as a disk drive.\n   * <p>\n   * The <code>flush</code> method of <code>OutputStream</code> does nothing.\n   *\n   * @exception  IOException  if an I/O error occurs.\n   */\n  OutputStream.prototype.flush = function () {};\n  /**\n   * Closes this output stream and releases any system resources\n   * associated with this stream. The general contract of <code>close</code>\n   * is that it closes the output stream. A closed stream cannot perform\n   * output operations and cannot be reopened.\n   * <p>\n   * The <code>close</code> method of <code>OutputStream</code> does nothing.\n   *\n   * @exception  IOException  if an I/O error occurs.\n   */\n  OutputStream.prototype.close = function () {};\n  return OutputStream;\n}();\nexports.default = OutputStream;","map":{"version":3,"names":["IndexOutOfBoundsException_1","require","NullPointerException_1","OutputStream","prototype","writeBytes","b","writeBytesOffset","length","off","len","default","i","write","flush","close"],"sources":["../../../src/core/util/OutputStream.ts"],"sourcesContent":[null],"mappings":";;;;;AAAA,IAAAA,2BAAA,GAAAC,OAAA;AACA,IAAAC,sBAAA,GAAAD,OAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;AAEA;;;;;;;;;;;;;;;;;;AAkBA,IAAAE,YAAA,CAAsD,sCAAmC;EAAzF,SAAAA,aAAA,GA4GA;EA1FE;;;;;;;;;;EAUOA,YAAA,CAAAC,SAAA,CAAAC,UAAU,GAAjB,UAAkBC,CAAa;IAC7B,IAAI,CAACC,gBAAgB,CAACD,CAAC,EAAE,CAAC,EAAEA,CAAC,CAACE,MAAM,CAAC;EACvC,CAAC;EAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA4BOL,YAAA,CAAAC,SAAA,CAAAG,gBAAgB,GAAvB,UAAwBD,CAAa,EAAEG,GAAmB,EAAEC,GAAmB;IAC7E,IAAIJ,CAAC,IAAI,IAAI,EAAE;MACb,MAAM,IAAIJ,sBAAA,CAAAS,OAAoB,EAAE;KACjC,MAAM,IAAKF,GAAG,GAAG,CAAC,IAAMA,GAAG,GAAGH,CAAC,CAACE,MAAO,IAAKE,GAAG,GAAG,CAAE,IACjDD,GAAG,GAAGC,GAAG,GAAIJ,CAAC,CAACE,MAAO,IAAMC,GAAG,GAAGC,GAAG,GAAI,CAAE,EAAE;MAC/C,MAAM,IAAIV,2BAAA,CAAAW,OAAyB,EAAE;KACtC,MAAM,IAAID,GAAG,KAAK,CAAC,EAAE;MACpB;;IAEF,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EAAE;MAC5B,IAAI,CAACC,KAAK,CAACP,CAAC,CAACG,GAAG,GAAGG,CAAC,CAAC,CAAC;;EAE1B,CAAC;EAED;;;;;;;;;;;;;;;;;;EAkBOT,YAAA,CAAAC,SAAA,CAAAU,KAAK,GAAZ,aACA,CAAC;EAED;;;;;;;;;;EAUOX,YAAA,CAAAC,SAAA,CAAAW,KAAK,GAAZ,aACA,CAAC;EAEH,OAAAZ,YAAC;AAAD,CAAC,EA5GD"},"metadata":{},"sourceType":"script"}