{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BitArray_1 = require(\"../common/BitArray\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\nvar ResultPoint_1 = require(\"../ResultPoint\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\n * Encapsulates functionality and implementation that is common to all families\n * of one-dimensional barcodes.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\nvar OneDReader = /** @class */function () {\n  function OneDReader() {}\n  /*\n  @Override\n  public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {\n    return decode(image, null);\n  }\n  */\n  // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n  // @Override\n  OneDReader.prototype.decode = function (image, hints) {\n    try {\n      return this.doDecode(image, hints);\n    } catch (nfe) {\n      var tryHarder = hints && hints.get(DecodeHintType_1.default.TRY_HARDER) === true;\n      if (tryHarder && image.isRotateSupported()) {\n        var rotatedImage = image.rotateCounterClockwise();\n        var result = this.doDecode(rotatedImage, hints);\n        // Record that we found it rotated 90 degrees CCW / 270 degrees CW\n        var metadata = result.getResultMetadata();\n        var orientation_1 = 270;\n        if (metadata !== null && metadata.get(ResultMetadataType_1.default.ORIENTATION) === true) {\n          // But if we found it reversed in doDecode(), add in that result here:\n          orientation_1 = orientation_1 + metadata.get(ResultMetadataType_1.default.ORIENTATION) % 360;\n        }\n        result.putMetadata(ResultMetadataType_1.default.ORIENTATION, orientation_1);\n        // Update result points\n        var points = result.getResultPoints();\n        if (points !== null) {\n          var height = rotatedImage.getHeight();\n          for (var i = 0; i < points.length; i++) {\n            points[i] = new ResultPoint_1.default(height - points[i].getY() - 1, points[i].getX());\n          }\n        }\n        return result;\n      } else {\n        throw new NotFoundException_1.default();\n      }\n    }\n  };\n  // @Override\n  OneDReader.prototype.reset = function () {\n    // do nothing\n  };\n  /**\n   * We're going to examine rows from the middle outward, searching alternately above and below the\n   * middle, and farther out each time. rowStep is the number of rows between each successive\n   * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then\n   * middle + rowStep, then middle - (2 * rowStep), etc.\n   * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily\n   * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the\n   * image if \"trying harder\".\n   *\n   * @param image The image to decode\n   * @param hints Any hints that were requested\n   * @return The contents of the decoded barcode\n   * @throws NotFoundException Any spontaneous errors which occur\n   */\n  OneDReader.prototype.doDecode = function (image, hints) {\n    var width = image.getWidth();\n    var height = image.getHeight();\n    var row = new BitArray_1.default(width);\n    var tryHarder = hints && hints.get(DecodeHintType_1.default.TRY_HARDER) === true;\n    var rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));\n    var maxLines;\n    if (tryHarder) {\n      maxLines = height; // Look at the whole image, not just the center\n    } else {\n      maxLines = 15; // 15 rows spaced 1/32 apart is roughly the middle half of the image\n    }\n\n    var middle = Math.trunc(height / 2);\n    for (var x = 0; x < maxLines; x++) {\n      // Scanning from the middle out. Determine which row we're looking at next:\n      var rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);\n      var isAbove = (x & 0x01) === 0; // i.e. is x even?\n      var rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);\n      if (rowNumber < 0 || rowNumber >= height) {\n        // Oops, if we run off the top or bottom, stop\n        break;\n      }\n      // Estimate black point for this row and load it:\n      try {\n        row = image.getBlackRow(rowNumber, row);\n      } catch (ignored) {\n        continue;\n      }\n      var _loop_1 = function (attempt) {\n        if (attempt === 1) {\n          // trying again?\n          row.reverse(); // reverse the row and continue\n          // This means we will only ever draw result points *once* in the life of this method\n          // since we want to avoid drawing the wrong points after flipping the row, and,\n          // don't want to clutter with noise from every single row scan -- just the scans\n          // that start on the center line.\n          if (hints && hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK) === true) {\n            var newHints_1 = new Map();\n            hints.forEach(function (hint, key) {\n              return newHints_1.set(key, hint);\n            });\n            newHints_1.delete(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n            hints = newHints_1;\n          }\n        }\n        try {\n          // Look for a barcode\n          var result = this_1.decodeRow(rowNumber, row, hints);\n          // We found our barcode\n          if (attempt === 1) {\n            // But it was upside down, so note that\n            result.putMetadata(ResultMetadataType_1.default.ORIENTATION, 180);\n            // And remember to flip the result points horizontally.\n            var points = result.getResultPoints();\n            if (points !== null) {\n              points[0] = new ResultPoint_1.default(width - points[0].getX() - 1, points[0].getY());\n              points[1] = new ResultPoint_1.default(width - points[1].getX() - 1, points[1].getY());\n            }\n          }\n          return {\n            value: result\n          };\n        } catch (re) {\n          // continue -- just couldn't decode this row\n        }\n      };\n      var this_1 = this;\n      // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to\n      // handle decoding upside down barcodes.\n      for (var attempt = 0; attempt < 2; attempt++) {\n        var state_1 = _loop_1(attempt);\n        if (typeof state_1 === \"object\") return state_1.value;\n      }\n    }\n    throw new NotFoundException_1.default();\n  };\n  /**\n   * Records the size of successive runs of white and black pixels in a row, starting at a given point.\n   * The values are recorded in the given array, and the number of runs recorded is equal to the size\n   * of the array. If the row starts on a white pixel at the given start point, then the first count\n   * recorded is the run of white pixels starting from that point; likewise it is the count of a run\n   * of black pixels if the row begin on a black pixels at that point.\n   *\n   * @param row row to count from\n   * @param start offset into row to start at\n   * @param counters array into which to record counts\n   * @throws NotFoundException if counters cannot be filled entirely from row before running out\n   *  of pixels\n   */\n  OneDReader.recordPattern = function (row, start, counters) {\n    var numCounters = counters.length;\n    for (var index = 0; index < numCounters; index++) counters[index] = 0;\n    var end = row.getSize();\n    if (start >= end) {\n      throw new NotFoundException_1.default();\n    }\n    var isWhite = !row.get(start);\n    var counterPosition = 0;\n    var i = start;\n    while (i < end) {\n      if (row.get(i) !== isWhite) {\n        counters[counterPosition]++;\n      } else {\n        if (++counterPosition === numCounters) {\n          break;\n        } else {\n          counters[counterPosition] = 1;\n          isWhite = !isWhite;\n        }\n      }\n      i++;\n    }\n    // If we read fully the last section of pixels and filled up our counters -- or filled\n    // the last counter but ran off the side of the image, OK. Otherwise, a problem.\n    if (!(counterPosition === numCounters || counterPosition === numCounters - 1 && i === end)) {\n      throw new NotFoundException_1.default();\n    }\n  };\n  OneDReader.recordPatternInReverse = function (row, start, counters) {\n    // This could be more efficient I guess\n    var numTransitionsLeft = counters.length;\n    var last = row.get(start);\n    while (start > 0 && numTransitionsLeft >= 0) {\n      if (row.get(--start) !== last) {\n        numTransitionsLeft--;\n        last = !last;\n      }\n    }\n    if (numTransitionsLeft >= 0) {\n      throw new NotFoundException_1.default();\n    }\n    OneDReader.recordPattern(row, start + 1, counters);\n  };\n  /**\n   * Determines how closely a set of observed counts of runs of black/white values matches a given\n   * target pattern. This is reported as the ratio of the total variance from the expected pattern\n   * proportions across all pattern elements, to the length of the pattern.\n   *\n   * @param counters observed counters\n   * @param pattern expected pattern\n   * @param maxIndividualVariance The most any counter can differ before we give up\n   * @return ratio of total variance between counters and pattern compared to total pattern size\n   */\n  OneDReader.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {\n    var numCounters = counters.length;\n    var total = 0;\n    var patternLength = 0;\n    for (var i = 0; i < numCounters; i++) {\n      total += counters[i];\n      patternLength += pattern[i];\n    }\n    if (total < patternLength) {\n      // If we don't even have one pixel per unit of bar width, assume this is too small\n      // to reliably match, so fail:\n      return Number.POSITIVE_INFINITY;\n    }\n    var unitBarWidth = total / patternLength;\n    maxIndividualVariance *= unitBarWidth;\n    var totalVariance = 0.0;\n    for (var x = 0; x < numCounters; x++) {\n      var counter = counters[x];\n      var scaledPattern = pattern[x] * unitBarWidth;\n      var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n      if (variance > maxIndividualVariance) {\n        return Number.POSITIVE_INFINITY;\n      }\n      totalVariance += variance;\n    }\n    return totalVariance / total;\n  };\n  return OneDReader;\n}();\nexports.default = OneDReader;","map":{"version":3,"names":["BitArray_1","require","DecodeHintType_1","ResultMetadataType_1","ResultPoint_1","NotFoundException_1","OneDReader","prototype","decode","image","hints","doDecode","nfe","tryHarder","get","default","TRY_HARDER","isRotateSupported","rotatedImage","rotateCounterClockwise","result","metadata","getResultMetadata","orientation_1","ORIENTATION","putMetadata","points","getResultPoints","height","getHeight","i","length","getY","getX","reset","width","getWidth","row","rowStep","Math","max","maxLines","middle","trunc","x","rowStepsAboveOrBelow","isAbove","rowNumber","getBlackRow","ignored","attempt","reverse","NEED_RESULT_POINT_CALLBACK","newHints_1","Map","forEach","hint","key","set","delete","this_1","decodeRow","re","recordPattern","start","counters","numCounters","index","end","getSize","isWhite","counterPosition","recordPatternInReverse","numTransitionsLeft","last","patternMatchVariance","pattern","maxIndividualVariance","total","patternLength","Number","POSITIVE_INFINITY","unitBarWidth","totalVariance","counter","scaledPattern","variance"],"sources":["../../../src/core/oned/OneDReader.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script"}