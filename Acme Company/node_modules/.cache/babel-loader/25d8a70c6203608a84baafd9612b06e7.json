{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n    i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar AlignmentPattern_1 = require(\"./AlignmentPattern\");\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/*import java.util.ArrayList;*/\n/*import java.util.List;*/\n/**\n * <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder\n * patterns but are smaller and appear at regular intervals throughout the image.</p>\n *\n * <p>At the moment this only looks for the bottom-right alignment pattern.</p>\n *\n * <p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,\n * pasted and stripped down here for maximum performance but does unfortunately duplicate\n * some code.</p>\n *\n * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>\n *\n * @author Sean Owen\n */\nvar AlignmentPatternFinder = /** @class */function () {\n  /**\n   * <p>Creates a finder that will look in a portion of the whole image.</p>\n   *\n   * @param image image to search\n   * @param startX left column from which to start searching\n   * @param startY top row from which to start searching\n   * @param width width of region to search\n   * @param height height of region to search\n   * @param moduleSize estimated module size so far\n   */\n  function AlignmentPatternFinder(image, startX /*int*/, startY /*int*/, width /*int*/, height /*int*/, moduleSize /*float*/, resultPointCallback) {\n    this.image = image;\n    this.startX = startX;\n    this.startY = startY;\n    this.width = width;\n    this.height = height;\n    this.moduleSize = moduleSize;\n    this.resultPointCallback = resultPointCallback;\n    this.possibleCenters = []; // new Array<any>(5))\n    // TYPESCRIPTPORT: array initialization without size as the length is checked below\n    this.crossCheckStateCount = new Int32Array(3);\n  }\n  /**\n   * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since\n   * it's pretty performance-critical and so is written to be fast foremost.</p>\n   *\n   * @return {@link AlignmentPattern} if found\n   * @throws NotFoundException if not found\n   */\n  AlignmentPatternFinder.prototype.find = function () {\n    var startX = this.startX;\n    var height = this.height;\n    var width = this.width;\n    var maxJ = startX + width;\n    var middleI = this.startY + height / 2;\n    // We are looking for black/white/black modules in 1:1:1 ratio\n    // this tracks the number of black/white/black modules seen so far\n    var stateCount = new Int32Array(3);\n    var image = this.image;\n    for (var iGen = 0; iGen < height; iGen++) {\n      // Search from middle outwards\n      var i = middleI + ((iGen & 0x01) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));\n      stateCount[0] = 0;\n      stateCount[1] = 0;\n      stateCount[2] = 0;\n      var j = startX;\n      // Burn off leading white pixels before anything else; if we start in the middle of\n      // a white run, it doesn't make sense to count its length, since we don't know if the\n      // white run continued to the left of the start point\n      while (j < maxJ && !image.get(j, i)) {\n        j++;\n      }\n      var currentState = 0;\n      while (j < maxJ) {\n        if (image.get(j, i)) {\n          // Black pixel\n          if (currentState === 1) {\n            // Counting black pixels\n            stateCount[1]++;\n          } else {\n            // Counting white pixels\n            if (currentState === 2) {\n              // A winner?\n              if (this.foundPatternCross(stateCount)) {\n                // Yes\n                var confirmed = this.handlePossibleCenter(stateCount, i, j);\n                if (confirmed !== null) {\n                  return confirmed;\n                }\n              }\n              stateCount[0] = stateCount[2];\n              stateCount[1] = 1;\n              stateCount[2] = 0;\n              currentState = 1;\n            } else {\n              stateCount[++currentState]++;\n            }\n          }\n        } else {\n          // White pixel\n          if (currentState === 1) {\n            // Counting black pixels\n            currentState++;\n          }\n          stateCount[currentState]++;\n        }\n        j++;\n      }\n      if (this.foundPatternCross(stateCount)) {\n        var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\n        if (confirmed !== null) {\n          return confirmed;\n        }\n      }\n    }\n    // Hmm, nothing we saw was observed and confirmed twice. If we had\n    // any guess at all, return it.\n    if (this.possibleCenters.length !== 0) {\n      return this.possibleCenters[0];\n    }\n    throw new NotFoundException_1.default();\n  };\n  /**\n   * Given a count of black/white/black pixels just seen and an end position,\n   * figures the location of the center of this black/white/black run.\n   */\n  AlignmentPatternFinder.centerFromEnd = function (stateCount, end /*int*/) {\n    return end - stateCount[2] - stateCount[1] / 2.0;\n  };\n  /**\n   * @param stateCount count of black/white/black pixels just read\n   * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios\n   *         used by alignment patterns to be considered a match\n   */\n  AlignmentPatternFinder.prototype.foundPatternCross = function (stateCount) {\n    var moduleSize = this.moduleSize;\n    var maxVariance = moduleSize / 2.0;\n    for (var i = 0; i < 3; i++) {\n      if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * <p>After a horizontal scan finds a potential alignment pattern, this method\n   * \"cross-checks\" by scanning down vertically through the center of the possible\n   * alignment pattern to see if the same proportion is detected.</p>\n   *\n   * @param startI row where an alignment pattern was detected\n   * @param centerJ center of the section that appears to cross an alignment pattern\n   * @param maxCount maximum reasonable number of modules that should be\n   * observed in any reading state, based on the results of the horizontal scan\n   * @return vertical center of alignment pattern, or {@link Float#NaN} if not found\n   */\n  AlignmentPatternFinder.prototype.crossCheckVertical = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n    var image = this.image;\n    var maxI = image.getHeight();\n    var stateCount = this.crossCheckStateCount;\n    stateCount[0] = 0;\n    stateCount[1] = 0;\n    stateCount[2] = 0;\n    // Start counting up from center\n    var i = startI;\n    while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      i--;\n    }\n    // If already too many modules in this state or ran off the edge:\n    if (i < 0 || stateCount[1] > maxCount) {\n      return NaN;\n    }\n    while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {\n      stateCount[0]++;\n      i--;\n    }\n    if (stateCount[0] > maxCount) {\n      return NaN;\n    }\n    // Now also count down from center\n    i = startI + 1;\n    while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      i++;\n    }\n    if (i === maxI || stateCount[1] > maxCount) {\n      return NaN;\n    }\n    while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {\n      stateCount[2]++;\n      i++;\n    }\n    if (stateCount[2] > maxCount) {\n      return NaN;\n    }\n    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n      return NaN;\n    }\n    return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i) : NaN;\n  };\n  /**\n   * <p>This is called when a horizontal scan finds a possible alignment pattern. It will\n   * cross check with a vertical scan, and if successful, will see if this pattern had been\n   * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have\n   * found the alignment pattern.</p>\n   *\n   * @param stateCount reading state module counts from horizontal scan\n   * @param i row where alignment pattern may be found\n   * @param j end of possible alignment pattern in row\n   * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not\n   */\n  AlignmentPatternFinder.prototype.handlePossibleCenter = function (stateCount, i /*int*/, j /*int*/) {\n    var e_1, _a;\n    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n    var centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j);\n    var centerI = this.crossCheckVertical(i, /*(int) */centerJ, 2 * stateCount[1], stateCountTotal);\n    if (!isNaN(centerI)) {\n      var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;\n      try {\n        for (var _b = __values(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var center = _c.value;\n          // Look for about the same center and module size:\n          if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n            return center.combineEstimate(centerI, centerJ, estimatedModuleSize);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      // Hadn't found this before; save it\n      var point = new AlignmentPattern_1.default(centerJ, centerI, estimatedModuleSize);\n      this.possibleCenters.push(point);\n      if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {\n        this.resultPointCallback.foundPossibleResultPoint(point);\n      }\n    }\n    return null;\n  };\n  return AlignmentPatternFinder;\n}();\nexports.default = AlignmentPatternFinder;","map":{"version":3,"names":["AlignmentPattern_1","require","NotFoundException_1","AlignmentPatternFinder","image","startX","startY","width","height","moduleSize","resultPointCallback","possibleCenters","crossCheckStateCount","Int32Array","prototype","find","maxJ","middleI","stateCount","iGen","i","Math","floor","j","get","currentState","foundPatternCross","confirmed","handlePossibleCenter","length","default","centerFromEnd","end","maxVariance","abs","crossCheckVertical","startI","centerJ","maxCount","originalStateCountTotal","maxI","getHeight","NaN","stateCountTotal","centerI","isNaN","estimatedModuleSize","_b","__values","_c","next","done","center","value","aboutEquals","combineEstimate","point","push","undefined","foundPossibleResultPoint"],"sources":["../../../../src/core/qrcode/detector/AlignmentPatternFinder.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script"}