{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar Result_1 = require(\"../Result\");\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\nvar ResultPoint_1 = require(\"../ResultPoint\");\nvar UPCEANExtensionSupport_1 = require(\"./UPCEANExtensionSupport\");\nvar AbstractUPCEANReader_1 = require(\"./AbstractUPCEANReader\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\nvar FormatException_1 = require(\"../FormatException\");\nvar ChecksumException_1 = require(\"../ChecksumException\");\n/**\n * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n * of one-dimensional barcodes.</p>\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n * @author alasdair@google.com (Alasdair Mackintosh)\n */\nvar UPCEANReader = /** @class */function (_super) {\n  __extends(UPCEANReader, _super);\n  function UPCEANReader() {\n    var _this = _super.call(this) || this;\n    _this.decodeRowStringBuffer = '';\n    UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map(function (arr) {\n      return arr.slice();\n    });\n    for (var i = 10; i < 20; i++) {\n      var widths = UPCEANReader.L_PATTERNS[i - 10];\n      var reversedWidths = new Array(widths.length);\n      for (var j = 0; j < widths.length; j++) {\n        reversedWidths[j] = widths[widths.length - j - 1];\n      }\n      UPCEANReader.L_AND_G_PATTERNS[i] = reversedWidths;\n    }\n    return _this;\n  }\n  UPCEANReader.prototype.decodeRow = function (rowNumber, row, hints) {\n    var startGuardRange = UPCEANReader.findStartGuardPattern(row);\n    var resultPointCallback = hints == null ? null : hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n    if (resultPointCallback != null) {\n      var resultPoint_1 = new ResultPoint_1.default((startGuardRange[0] + startGuardRange[1]) / 2.0, rowNumber);\n      resultPointCallback.foundPossibleResultPoint(resultPoint_1);\n    }\n    var budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);\n    var endStart = budello.rowOffset;\n    var result = budello.resultString;\n    if (resultPointCallback != null) {\n      var resultPoint_2 = new ResultPoint_1.default(endStart, rowNumber);\n      resultPointCallback.foundPossibleResultPoint(resultPoint_2);\n    }\n    var endRange = UPCEANReader.decodeEnd(row, endStart);\n    if (resultPointCallback != null) {\n      var resultPoint_3 = new ResultPoint_1.default((endRange[0] + endRange[1]) / 2.0, rowNumber);\n      resultPointCallback.foundPossibleResultPoint(resultPoint_3);\n    }\n    // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The\n    // spec might want more whitespace, but in practice this is the maximum we can count on.\n    var end = endRange[1];\n    var quietEnd = end + (end - endRange[0]);\n    if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {\n      throw new NotFoundException_1.default();\n    }\n    var resultString = result.toString();\n    // UPC/EAN should never be less than 8 chars anyway\n    if (resultString.length < 8) {\n      throw new FormatException_1.default();\n    }\n    if (!UPCEANReader.checkChecksum(resultString)) {\n      throw new ChecksumException_1.default();\n    }\n    var left = (startGuardRange[1] + startGuardRange[0]) / 2.0;\n    var right = (endRange[1] + endRange[0]) / 2.0;\n    var format = this.getBarcodeFormat();\n    var resultPoint = [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)];\n    var decodeResult = new Result_1.default(resultString, null, 0, resultPoint, format, new Date().getTime());\n    var extensionLength = 0;\n    try {\n      var extensionResult = UPCEANExtensionSupport_1.default.decodeRow(rowNumber, row, endRange[1]);\n      decodeResult.putMetadata(ResultMetadataType_1.default.UPC_EAN_EXTENSION, extensionResult.getText());\n      decodeResult.putAllMetadata(extensionResult.getResultMetadata());\n      decodeResult.addResultPoints(extensionResult.getResultPoints());\n      extensionLength = extensionResult.getText().length;\n    } catch (err) {}\n    var allowedExtensions = hints == null ? null : hints.get(DecodeHintType_1.default.ALLOWED_EAN_EXTENSIONS);\n    if (allowedExtensions != null) {\n      var valid = false;\n      for (var length_1 in allowedExtensions) {\n        if (extensionLength.toString() === length_1) {\n          // check me\n          valid = true;\n          break;\n        }\n      }\n      if (!valid) {\n        throw new NotFoundException_1.default();\n      }\n    }\n    if (format === BarcodeFormat_1.default.EAN_13 || format === BarcodeFormat_1.default.UPC_A) {\n      // let countryID = eanManSupport.lookupContryIdentifier(resultString); todo\n      // if (countryID != null) {\n      //     decodeResult.putMetadata(ResultMetadataType.POSSIBLE_COUNTRY, countryID);\n      // }\n    }\n    return decodeResult;\n  };\n  UPCEANReader.checkChecksum = function (s) {\n    return UPCEANReader.checkStandardUPCEANChecksum(s);\n  };\n  UPCEANReader.checkStandardUPCEANChecksum = function (s) {\n    var length = s.length;\n    if (length === 0) return false;\n    var check = parseInt(s.charAt(length - 1), 10);\n    return UPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n  };\n  UPCEANReader.getStandardUPCEANChecksum = function (s) {\n    var length = s.length;\n    var sum = 0;\n    for (var i = length - 1; i >= 0; i -= 2) {\n      var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n      if (digit < 0 || digit > 9) {\n        throw new FormatException_1.default();\n      }\n      sum += digit;\n    }\n    sum *= 3;\n    for (var i = length - 2; i >= 0; i -= 2) {\n      var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n      if (digit < 0 || digit > 9) {\n        throw new FormatException_1.default();\n      }\n      sum += digit;\n    }\n    return (1000 - sum) % 10;\n  };\n  UPCEANReader.decodeEnd = function (row, endStart) {\n    return UPCEANReader.findGuardPattern(row, endStart, false, UPCEANReader.START_END_PATTERN, new Array(UPCEANReader.START_END_PATTERN.length).fill(0));\n  };\n  return UPCEANReader;\n}(AbstractUPCEANReader_1.default);\nexports.default = UPCEANReader;","map":{"version":3,"sources":["../../../src/core/oned/UPCEANReader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar Result_1 = require(\"../Result\");\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\nvar ResultPoint_1 = require(\"../ResultPoint\");\nvar UPCEANExtensionSupport_1 = require(\"./UPCEANExtensionSupport\");\nvar AbstractUPCEANReader_1 = require(\"./AbstractUPCEANReader\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\nvar FormatException_1 = require(\"../FormatException\");\nvar ChecksumException_1 = require(\"../ChecksumException\");\n/**\n * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n * of one-dimensional barcodes.</p>\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n * @author alasdair@google.com (Alasdair Mackintosh)\n */\nvar UPCEANReader = /** @class */ (function (_super) {\n    __extends(UPCEANReader, _super);\n    function UPCEANReader() {\n        var _this = _super.call(this) || this;\n        _this.decodeRowStringBuffer = '';\n        UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map(function (arr) {\n            return arr.slice();\n        });\n        for (var i = 10; i < 20; i++) {\n            var widths = UPCEANReader.L_PATTERNS[i - 10];\n            var reversedWidths = new Array(widths.length);\n            for (var j = 0; j < widths.length; j++) {\n                reversedWidths[j] = widths[widths.length - j - 1];\n            }\n            UPCEANReader.L_AND_G_PATTERNS[i] = reversedWidths;\n        }\n        return _this;\n    }\n    UPCEANReader.prototype.decodeRow = function (rowNumber, row, hints) {\n        var startGuardRange = UPCEANReader.findStartGuardPattern(row);\n        var resultPointCallback = hints == null ? null : hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n        if (resultPointCallback != null) {\n            var resultPoint_1 = new ResultPoint_1.default((startGuardRange[0] + startGuardRange[1]) / 2.0, rowNumber);\n            resultPointCallback.foundPossibleResultPoint(resultPoint_1);\n        }\n        var budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);\n        var endStart = budello.rowOffset;\n        var result = budello.resultString;\n        if (resultPointCallback != null) {\n            var resultPoint_2 = new ResultPoint_1.default(endStart, rowNumber);\n            resultPointCallback.foundPossibleResultPoint(resultPoint_2);\n        }\n        var endRange = UPCEANReader.decodeEnd(row, endStart);\n        if (resultPointCallback != null) {\n            var resultPoint_3 = new ResultPoint_1.default((endRange[0] + endRange[1]) / 2.0, rowNumber);\n            resultPointCallback.foundPossibleResultPoint(resultPoint_3);\n        }\n        // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The\n        // spec might want more whitespace, but in practice this is the maximum we can count on.\n        var end = endRange[1];\n        var quietEnd = end + (end - endRange[0]);\n        if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {\n            throw new NotFoundException_1.default();\n        }\n        var resultString = result.toString();\n        // UPC/EAN should never be less than 8 chars anyway\n        if (resultString.length < 8) {\n            throw new FormatException_1.default();\n        }\n        if (!UPCEANReader.checkChecksum(resultString)) {\n            throw new ChecksumException_1.default();\n        }\n        var left = (startGuardRange[1] + startGuardRange[0]) / 2.0;\n        var right = (endRange[1] + endRange[0]) / 2.0;\n        var format = this.getBarcodeFormat();\n        var resultPoint = [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)];\n        var decodeResult = new Result_1.default(resultString, null, 0, resultPoint, format, new Date().getTime());\n        var extensionLength = 0;\n        try {\n            var extensionResult = UPCEANExtensionSupport_1.default.decodeRow(rowNumber, row, endRange[1]);\n            decodeResult.putMetadata(ResultMetadataType_1.default.UPC_EAN_EXTENSION, extensionResult.getText());\n            decodeResult.putAllMetadata(extensionResult.getResultMetadata());\n            decodeResult.addResultPoints(extensionResult.getResultPoints());\n            extensionLength = extensionResult.getText().length;\n        }\n        catch (err) {\n        }\n        var allowedExtensions = hints == null ? null : hints.get(DecodeHintType_1.default.ALLOWED_EAN_EXTENSIONS);\n        if (allowedExtensions != null) {\n            var valid = false;\n            for (var length_1 in allowedExtensions) {\n                if (extensionLength.toString() === length_1) { // check me\n                    valid = true;\n                    break;\n                }\n            }\n            if (!valid) {\n                throw new NotFoundException_1.default();\n            }\n        }\n        if (format === BarcodeFormat_1.default.EAN_13 || format === BarcodeFormat_1.default.UPC_A) {\n            // let countryID = eanManSupport.lookupContryIdentifier(resultString); todo\n            // if (countryID != null) {\n            //     decodeResult.putMetadata(ResultMetadataType.POSSIBLE_COUNTRY, countryID);\n            // }\n        }\n        return decodeResult;\n    };\n    UPCEANReader.checkChecksum = function (s) {\n        return UPCEANReader.checkStandardUPCEANChecksum(s);\n    };\n    UPCEANReader.checkStandardUPCEANChecksum = function (s) {\n        var length = s.length;\n        if (length === 0)\n            return false;\n        var check = parseInt(s.charAt(length - 1), 10);\n        return UPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n    };\n    UPCEANReader.getStandardUPCEANChecksum = function (s) {\n        var length = s.length;\n        var sum = 0;\n        for (var i = length - 1; i >= 0; i -= 2) {\n            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            if (digit < 0 || digit > 9) {\n                throw new FormatException_1.default();\n            }\n            sum += digit;\n        }\n        sum *= 3;\n        for (var i = length - 2; i >= 0; i -= 2) {\n            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            if (digit < 0 || digit > 9) {\n                throw new FormatException_1.default();\n            }\n            sum += digit;\n        }\n        return (1000 - sum) % 10;\n    };\n    UPCEANReader.decodeEnd = function (row, endStart) {\n        return UPCEANReader.findGuardPattern(row, endStart, false, UPCEANReader.START_END_PATTERN, new Array(UPCEANReader.START_END_PATTERN.length).fill(0));\n    };\n    return UPCEANReader;\n}(AbstractUPCEANReader_1.default));\nexports.default = UPCEANReader;\n//# sourceMappingURL=UPCEANReader.js.map"]},"metadata":{},"sourceType":"script"}