{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n    i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BitMatrix_1 = require(\"../../common/BitMatrix\");\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\nvar BitMatrixParser_1 = require(\"./BitMatrixParser\");\nvar QRCodeDecoderMetaData_1 = require(\"./QRCodeDecoderMetaData\");\nvar DataBlock_1 = require(\"./DataBlock\");\nvar DecodedBitStreamParser_1 = require(\"./DecodedBitStreamParser\");\nvar ChecksumException_1 = require(\"../../ChecksumException\");\n/*import java.util.Map;*/\n/**\n * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting\n * the QR Code from an image.</p>\n *\n * @author Sean Owen\n */\nvar Decoder = /** @class */function () {\n  function Decoder() {\n    this.rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256);\n  }\n  // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {\n  //   return decode(image, null)\n  // }\n  /**\n   * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.\n   * \"true\" is taken to mean a black module.</p>\n   *\n   * @param image booleans representing white/black QR Code modules\n   * @param hints decoding hints that should be used to influence decoding\n   * @return text and bytes encoded within the QR Code\n   * @throws FormatException if the QR Code cannot be decoded\n   * @throws ChecksumException if error correction fails\n   */\n  Decoder.prototype.decodeBooleanArray = function (image, hints) {\n    return this.decodeBitMatrix(BitMatrix_1.default.parseFromBooleanArray(image), hints);\n  };\n  // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {\n  //   return decode(bits, null)\n  // }\n  /**\n   * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken to mean a black module.</p>\n   *\n   * @param bits booleans representing white/black QR Code modules\n   * @param hints decoding hints that should be used to influence decoding\n   * @return text and bytes encoded within the QR Code\n   * @throws FormatException if the QR Code cannot be decoded\n   * @throws ChecksumException if error correction fails\n   */\n  Decoder.prototype.decodeBitMatrix = function (bits, hints) {\n    // Construct a parser and read version, error-correction level\n    var parser = new BitMatrixParser_1.default(bits);\n    var ex = null;\n    try {\n      return this.decodeBitMatrixParser(parser, hints);\n    } catch (e /*: FormatException, ChecksumException*/) {\n      ex = e;\n    }\n    try {\n      // Revert the bit matrix\n      parser.remask();\n      // Will be attempting a mirrored reading of the version and format info.\n      parser.setMirror(true);\n      // Preemptively read the version.\n      parser.readVersion();\n      // Preemptively read the format information.\n      parser.readFormatInformation();\n      /*\n       * Since we're here, this means we have successfully detected some kind\n       * of version and format information when mirrored. This is a good sign,\n       * that the QR code may be mirrored, and we should try once more with a\n       * mirrored content.\n       */\n      // Prepare for a mirrored reading.\n      parser.mirror();\n      var result = this.decodeBitMatrixParser(parser, hints);\n      // Success! Notify the caller that the code was mirrored.\n      result.setOther(new QRCodeDecoderMetaData_1.default(true));\n      return result;\n    } catch (e /*FormatException | ChecksumException*/) {\n      // Throw the exception from the original reading\n      if (ex !== null) {\n        throw ex;\n      }\n      throw e;\n    }\n  };\n  Decoder.prototype.decodeBitMatrixParser = function (parser, hints) {\n    var e_1, _a, e_2, _b;\n    var version = parser.readVersion();\n    var ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();\n    // Read codewords\n    var codewords = parser.readCodewords();\n    // Separate into data blocks\n    var dataBlocks = DataBlock_1.default.getDataBlocks(codewords, version, ecLevel);\n    // Count total number of data bytes\n    var totalBytes = 0;\n    try {\n      for (var dataBlocks_1 = __values(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {\n        var dataBlock = dataBlocks_1_1.value;\n        totalBytes += dataBlock.getNumDataCodewords();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    var resultBytes = new Uint8Array(totalBytes);\n    var resultOffset = 0;\n    try {\n      // Error-correct and copy data blocks together into a stream of bytes\n      for (var dataBlocks_2 = __values(dataBlocks), dataBlocks_2_1 = dataBlocks_2.next(); !dataBlocks_2_1.done; dataBlocks_2_1 = dataBlocks_2.next()) {\n        var dataBlock = dataBlocks_2_1.value;\n        var codewordBytes = dataBlock.getCodewords();\n        var numDataCodewords = dataBlock.getNumDataCodewords();\n        this.correctErrors(codewordBytes, numDataCodewords);\n        for (var i = 0; i < numDataCodewords; i++) {\n          resultBytes[resultOffset++] = codewordBytes[i];\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (dataBlocks_2_1 && !dataBlocks_2_1.done && (_b = dataBlocks_2.return)) _b.call(dataBlocks_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    // Decode the contents of that stream of bytes\n    return DecodedBitStreamParser_1.default.decode(resultBytes, version, ecLevel, hints);\n  };\n  /**\n   * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n   * correct the errors in-place using Reed-Solomon error correction.</p>\n   *\n   * @param codewordBytes data and error correction codewords\n   * @param numDataCodewords number of codewords that are data bytes\n   * @throws ChecksumException if error correction fails\n   */\n  Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords /*int*/) {\n    var numCodewords = codewordBytes.length;\n    // First read into an array of ints\n    var codewordsInts = new Int32Array(codewordBytes);\n    // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?\n    // const codewordsInts = new Int32Array(numCodewords)\n    // for (let i = 0; i < numCodewords; i++) {\n    //   codewordsInts[i] = codewordBytes[i] & 0xFF\n    // }\n    try {\n      this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n    } catch (ignored /*: ReedSolomonException*/) {\n      throw new ChecksumException_1.default();\n    }\n    // Copy back into array of bytes -- only need to worry about the bytes that were data\n    // We don't care about errors in the error-correction codewords\n    for (var i = 0; i < numDataCodewords; i++) {\n      codewordBytes[i] = /*(byte) */codewordsInts[i];\n    }\n  };\n  return Decoder;\n}();\nexports.default = Decoder;","map":{"version":3,"sources":["../../../../src/core/qrcode/decoder/Decoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BitMatrix_1 = require(\"../../common/BitMatrix\");\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\nvar BitMatrixParser_1 = require(\"./BitMatrixParser\");\nvar QRCodeDecoderMetaData_1 = require(\"./QRCodeDecoderMetaData\");\nvar DataBlock_1 = require(\"./DataBlock\");\nvar DecodedBitStreamParser_1 = require(\"./DecodedBitStreamParser\");\nvar ChecksumException_1 = require(\"../../ChecksumException\");\n/*import java.util.Map;*/\n/**\n * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting\n * the QR Code from an image.</p>\n *\n * @author Sean Owen\n */\nvar Decoder = /** @class */ (function () {\n    function Decoder() {\n        this.rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256);\n    }\n    // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {\n    //   return decode(image, null)\n    // }\n    /**\n     * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.\n     * \"true\" is taken to mean a black module.</p>\n     *\n     * @param image booleans representing white/black QR Code modules\n     * @param hints decoding hints that should be used to influence decoding\n     * @return text and bytes encoded within the QR Code\n     * @throws FormatException if the QR Code cannot be decoded\n     * @throws ChecksumException if error correction fails\n     */\n    Decoder.prototype.decodeBooleanArray = function (image, hints) {\n        return this.decodeBitMatrix(BitMatrix_1.default.parseFromBooleanArray(image), hints);\n    };\n    // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {\n    //   return decode(bits, null)\n    // }\n    /**\n     * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken to mean a black module.</p>\n     *\n     * @param bits booleans representing white/black QR Code modules\n     * @param hints decoding hints that should be used to influence decoding\n     * @return text and bytes encoded within the QR Code\n     * @throws FormatException if the QR Code cannot be decoded\n     * @throws ChecksumException if error correction fails\n     */\n    Decoder.prototype.decodeBitMatrix = function (bits, hints) {\n        // Construct a parser and read version, error-correction level\n        var parser = new BitMatrixParser_1.default(bits);\n        var ex = null;\n        try {\n            return this.decodeBitMatrixParser(parser, hints);\n        }\n        catch (e /*: FormatException, ChecksumException*/) {\n            ex = e;\n        }\n        try {\n            // Revert the bit matrix\n            parser.remask();\n            // Will be attempting a mirrored reading of the version and format info.\n            parser.setMirror(true);\n            // Preemptively read the version.\n            parser.readVersion();\n            // Preemptively read the format information.\n            parser.readFormatInformation();\n            /*\n             * Since we're here, this means we have successfully detected some kind\n             * of version and format information when mirrored. This is a good sign,\n             * that the QR code may be mirrored, and we should try once more with a\n             * mirrored content.\n             */\n            // Prepare for a mirrored reading.\n            parser.mirror();\n            var result = this.decodeBitMatrixParser(parser, hints);\n            // Success! Notify the caller that the code was mirrored.\n            result.setOther(new QRCodeDecoderMetaData_1.default(true));\n            return result;\n        }\n        catch (e /*FormatException | ChecksumException*/) {\n            // Throw the exception from the original reading\n            if (ex !== null) {\n                throw ex;\n            }\n            throw e;\n        }\n    };\n    Decoder.prototype.decodeBitMatrixParser = function (parser, hints) {\n        var e_1, _a, e_2, _b;\n        var version = parser.readVersion();\n        var ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();\n        // Read codewords\n        var codewords = parser.readCodewords();\n        // Separate into data blocks\n        var dataBlocks = DataBlock_1.default.getDataBlocks(codewords, version, ecLevel);\n        // Count total number of data bytes\n        var totalBytes = 0;\n        try {\n            for (var dataBlocks_1 = __values(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {\n                var dataBlock = dataBlocks_1_1.value;\n                totalBytes += dataBlock.getNumDataCodewords();\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var resultBytes = new Uint8Array(totalBytes);\n        var resultOffset = 0;\n        try {\n            // Error-correct and copy data blocks together into a stream of bytes\n            for (var dataBlocks_2 = __values(dataBlocks), dataBlocks_2_1 = dataBlocks_2.next(); !dataBlocks_2_1.done; dataBlocks_2_1 = dataBlocks_2.next()) {\n                var dataBlock = dataBlocks_2_1.value;\n                var codewordBytes = dataBlock.getCodewords();\n                var numDataCodewords = dataBlock.getNumDataCodewords();\n                this.correctErrors(codewordBytes, numDataCodewords);\n                for (var i = 0; i < numDataCodewords; i++) {\n                    resultBytes[resultOffset++] = codewordBytes[i];\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (dataBlocks_2_1 && !dataBlocks_2_1.done && (_b = dataBlocks_2.return)) _b.call(dataBlocks_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        // Decode the contents of that stream of bytes\n        return DecodedBitStreamParser_1.default.decode(resultBytes, version, ecLevel, hints);\n    };\n    /**\n     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n     * correct the errors in-place using Reed-Solomon error correction.</p>\n     *\n     * @param codewordBytes data and error correction codewords\n     * @param numDataCodewords number of codewords that are data bytes\n     * @throws ChecksumException if error correction fails\n     */\n    Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords /*int*/) {\n        var numCodewords = codewordBytes.length;\n        // First read into an array of ints\n        var codewordsInts = new Int32Array(codewordBytes);\n        // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?\n        // const codewordsInts = new Int32Array(numCodewords)\n        // for (let i = 0; i < numCodewords; i++) {\n        //   codewordsInts[i] = codewordBytes[i] & 0xFF\n        // }\n        try {\n            this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n        }\n        catch (ignored /*: ReedSolomonException*/) {\n            throw new ChecksumException_1.default();\n        }\n        // Copy back into array of bytes -- only need to worry about the bytes that were data\n        // We don't care about errors in the error-correction codewords\n        for (var i = 0; i < numDataCodewords; i++) {\n            codewordBytes[i] = /*(byte) */ codewordsInts[i];\n        }\n    };\n    return Decoder;\n}());\nexports.default = Decoder;\n//# sourceMappingURL=Decoder.js.map"]},"metadata":{},"sourceType":"script"}