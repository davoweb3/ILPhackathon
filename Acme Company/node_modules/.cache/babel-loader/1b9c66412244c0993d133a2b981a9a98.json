{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n    i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// package com.google.zxing.pdf417.decoder;\n// import java.util.Formatter;\nvar Formatter_1 = require(\"../../util/Formatter\");\nvar BoundingBox_1 = require(\"./BoundingBox\");\n/**\n * @author Guenther Grau\n */\nvar DetectionResultColumn = /** @class */function () {\n  function DetectionResultColumn(boundingBox) {\n    this.boundingBox = new BoundingBox_1.default(boundingBox);\n    // this.codewords = new Codeword[boundingBox.getMaxY() - boundingBox.getMinY() + 1];\n    this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);\n  }\n  /*final*/\n  DetectionResultColumn.prototype.getCodewordNearby = function (imageRow) {\n    var codeword = this.getCodeword(imageRow);\n    if (codeword != null) {\n      return codeword;\n    }\n    for (var i = 1; i < DetectionResultColumn.MAX_NEARBY_DISTANCE; i++) {\n      var nearImageRow = this.imageRowToCodewordIndex(imageRow) - i;\n      if (nearImageRow >= 0) {\n        codeword = this.codewords[nearImageRow];\n        if (codeword != null) {\n          return codeword;\n        }\n      }\n      nearImageRow = this.imageRowToCodewordIndex(imageRow) + i;\n      if (nearImageRow < this.codewords.length) {\n        codeword = this.codewords[nearImageRow];\n        if (codeword != null) {\n          return codeword;\n        }\n      }\n    }\n    return null;\n  };\n  /*final int*/\n  DetectionResultColumn.prototype.imageRowToCodewordIndex = function (imageRow) {\n    return imageRow - this.boundingBox.getMinY();\n  };\n  /*final void*/\n  DetectionResultColumn.prototype.setCodeword = function (imageRow, codeword) {\n    this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;\n  };\n  /*final*/\n  DetectionResultColumn.prototype.getCodeword = function (imageRow) {\n    return this.codewords[this.imageRowToCodewordIndex(imageRow)];\n  };\n  /*final*/\n  DetectionResultColumn.prototype.getBoundingBox = function () {\n    return this.boundingBox;\n  };\n  /*final*/\n  DetectionResultColumn.prototype.getCodewords = function () {\n    return this.codewords;\n  };\n  // @Override\n  DetectionResultColumn.prototype.toString = function () {\n    var e_1, _a;\n    var formatter = new Formatter_1.default();\n    var row = 0;\n    try {\n      for (var _b = __values(this.codewords), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var codeword = _c.value;\n        if (codeword == null) {\n          formatter.format('%3d:    |   %n', row++);\n          continue;\n        }\n        formatter.format('%3d: %3d|%3d%n', row++, codeword.getRowNumber(), codeword.getValue());\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return formatter.toString();\n  };\n  DetectionResultColumn.MAX_NEARBY_DISTANCE = 5;\n  return DetectionResultColumn;\n}();\nexports.default = DetectionResultColumn;","map":{"version":3,"sources":["../../../../src/core/pdf417/decoder/DetectionResultColumn.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// package com.google.zxing.pdf417.decoder;\n// import java.util.Formatter;\nvar Formatter_1 = require(\"../../util/Formatter\");\nvar BoundingBox_1 = require(\"./BoundingBox\");\n/**\n * @author Guenther Grau\n */\nvar DetectionResultColumn = /** @class */ (function () {\n    function DetectionResultColumn(boundingBox) {\n        this.boundingBox = new BoundingBox_1.default(boundingBox);\n        // this.codewords = new Codeword[boundingBox.getMaxY() - boundingBox.getMinY() + 1];\n        this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);\n    }\n    /*final*/ DetectionResultColumn.prototype.getCodewordNearby = function (imageRow) {\n        var codeword = this.getCodeword(imageRow);\n        if (codeword != null) {\n            return codeword;\n        }\n        for (var i = 1; i < DetectionResultColumn.MAX_NEARBY_DISTANCE; i++) {\n            var nearImageRow = this.imageRowToCodewordIndex(imageRow) - i;\n            if (nearImageRow >= 0) {\n                codeword = this.codewords[nearImageRow];\n                if (codeword != null) {\n                    return codeword;\n                }\n            }\n            nearImageRow = this.imageRowToCodewordIndex(imageRow) + i;\n            if (nearImageRow < this.codewords.length) {\n                codeword = this.codewords[nearImageRow];\n                if (codeword != null) {\n                    return codeword;\n                }\n            }\n        }\n        return null;\n    };\n    /*final int*/ DetectionResultColumn.prototype.imageRowToCodewordIndex = function (imageRow) {\n        return imageRow - this.boundingBox.getMinY();\n    };\n    /*final void*/ DetectionResultColumn.prototype.setCodeword = function (imageRow, codeword) {\n        this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;\n    };\n    /*final*/ DetectionResultColumn.prototype.getCodeword = function (imageRow) {\n        return this.codewords[this.imageRowToCodewordIndex(imageRow)];\n    };\n    /*final*/ DetectionResultColumn.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n    /*final*/ DetectionResultColumn.prototype.getCodewords = function () {\n        return this.codewords;\n    };\n    // @Override\n    DetectionResultColumn.prototype.toString = function () {\n        var e_1, _a;\n        var formatter = new Formatter_1.default();\n        var row = 0;\n        try {\n            for (var _b = __values(this.codewords), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var codeword = _c.value;\n                if (codeword == null) {\n                    formatter.format('%3d:    |   %n', row++);\n                    continue;\n                }\n                formatter.format('%3d: %3d|%3d%n', row++, codeword.getRowNumber(), codeword.getValue());\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return formatter.toString();\n    };\n    DetectionResultColumn.MAX_NEARBY_DISTANCE = 5;\n    return DetectionResultColumn;\n}());\nexports.default = DetectionResultColumn;\n//# sourceMappingURL=DetectionResultColumn.js.map"]},"metadata":{},"sourceType":"script"}